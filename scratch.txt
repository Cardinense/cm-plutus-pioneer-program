what they have paid
up to that point so when we start with
blockly
there is a contract and it's just a
closed contract which
in this case doesn't do anything if
there was money in
internal accounts it would pay back the
money to the owners of the accounts
but we want to do something else so
let's first wait for a deposit by alice
and because that's an
external action that's triggered by one
of the parties in this case alice
we need this when construct that simon
mentioned
and we can slide that into here and we
see all the
slots where other things need to go
and we see some fields that we have to
set so let's start here
so um we can set a timeout so let's say
this deposit by alice has to happen
until slot 10
and if it doesn't happen we can say what
should happen afterwards
and there is not really a good choice to
do anything except
close in that case so in that case
nothing will happen so we can
slide that in there so now here we say
what external actions we wait for let's
say we
only wait for one action namely that
alice makes a deposit
so we can check for actions and pick the
deposit
one and slide it in here and we see a
couple of slots we have to fill
first of all who has to make the deposit
that's
a party and there are two choices public
key or role
let's take roll because then i
can just say ls normally this would be
the name of the role token
so whoever owns that token can
incorporate that role
okay so alice makes a deposit now the
amount
that's a value and let's say we just
pick a constant amount of
10 eta so amount is 10
and that it is ada we must specify here
in the currency slot
there's also the option to use other
tokens than ada but let's stick with ada
okay now there are these internal
accounts
that also belong to one of the parties
so
let's say alice pays it into her own
internal account
so i just copy pasted this and now we
must say what happens
next if alice makes this deposit
so afterwards we want bob to make a
deposit
so i can just copy this whole when block
here
and slide it in here and now
change so first of all i change the
timeout to 20.
so to give bob also 10 slots to do
something
and then wherever i set alice i now say
bob
so at this point if both these actions
happen
alice has deposited 10 into her internal
account and bob has deposited 10
into his inter external account so now
we want
charlie to make a choice so we need and
this is again an external action
so again we need a win
and put that in here but this time it's
not a deposit so let me delete
the deposit but let's change the timeout
to 30
to give charlie 10 slots to make his
choice
and now i need a different action where
earlier i had deposit
now i pick the choice action
i can give it a name let's say winner
i must say who makes the choice so
that's supposed to be
charlie
and now i must specify what values this
choice can have
and that's numeric so
somehow because l charlie is supposed to
choose between alice and bobs where
that's two choices
so i can pick arbitrary values like one
and two
one for ls two for bob so
that's already the default so that's
fine so this allows charlie to only
choose one or two
and then after he has made the choice if
he has made the choice
we continue and now it depends of course
on
what choice charlie has made if he chose
alice then alice must get all the money
if
he chose bob then bob must get all the
money so
here in this continued contract we now
can use
if simple conditional
slide that in here so first we need the
observation
so we must somehow check whether the
choice was
let's say one for alice so this is an
observation
and there is value equality is one of
the options
so we want to compare the choice that
charlie made
with one or two it doesn't matter but
let's say one
so value
there is this one
which gives us the value of a choice so
here we need the name
again so winner was our name for that
choice because there can be several
choices so we must
be able to distinguish between them and
we again need who made that choice
so this is now either one or two and we
can compare to for example one
so we can use the constant value one
okay and in this case so if this is true
then charlie chose
alice so we want alice to get all the
money
so in the then branch we can now
take a pay contract
the payees who gets the money and now we
have two choices that can be an internal
account or it can be an external party
and in this case it doesn't matter
because in the end when we close
all the parties get the money from the
internal accounts as well so i
it doesn't matter i can just pick the
internal account alice's
internal account so let's do that
pick ls
so this now means that the payee is
alice's internal account
now how much that's this constant
10 the amount that bob paid in
currency is ada
and now who pays and that must be an
internal account
because this is something the this pay
contract is something the
contract has control over so that's not
an external action
so payments are triggered from internal
accounts that are
under the control of the contract and
that in this case is bob's account
so this now says if charlie picked one
which stands for alice then pay
from bob's internal account 10 ada to
alice's internal account
and afterwards we can just close
and when we close all the internal
accounts will be
paid to the external owners so
at this point alice's internal account
will have 28r and when we close
she will get the 28 are paid out
okay and else this is now if charlie
didn't choose alice if he chose bob
well then we must do the same but with
reversed roles so let me
copy paste this whole pay thing and just
exchange bob and alice
and this should do it now we can
for example look at the pure mallow
so this is now the value what i did
graphically as a milo
value a value of the haskell data type
called
marlow or called contract actually
and i can send it to the simulator
i can start the simulation
and now whenever there is a when so when
there are
available actions i get prompted
which of those to take in our case we
always only had
one available action at every point
so in the first when there are only two
possibilities either alice makes her
deposit
or she doesn't until the timeout is
reached so in this case if we
wait for the timeout it's very boring
the contract is over
is reduced to close and nothing happened
so if she makes the deposit
then this contract simplifies so it's
now reduced
to what happens after she made the
deposit
and we see now we are in the second when
where we are waiting for
bob's deposit and again he can
choose not to deposit so if he does that
then we see here the actions alice
deposits the 10
and then after the timeout because bob
didn't do any anything
the contract paid 10 back to alice
okay of course it's more interesting if
bob also makes this deposit
so we see that locked here as well
and now we are the contract has
simplified again
so now we are in the when where the
only available action is that charlie
chooses so
charlie can now choose one or two if he
chooses or
don't do anything if he doesn't do
anything
bob and alice both get her money their
money back
if he picks alice so choice one
then we see that the contract pays 20
units of ada to alice
so she gets all the money and
if instead we pick two
then the contract pays 20 units to bob
so it seems to work let me
reset this now and let me
copy this marlo contract
and do a new project and go to the
haskell editor instead
and let's not save
and here in this haskell editor there's
a template
basically all this haskell pro program
does
is it takes a contract this is a milo
contract
and then it's a it's a simple executable
haskell executable
that just pretty prints the contract so
all it does is it basically produces
a nicely printed value of type contract
and this is then used to for example run
in the simulator
so we should be able to simply instead
of close paste
this expression here that we got
from our blockly probably i should
indent okay and
that should compile so i can compile
this
and i can send it to the simulator and
it should behave exactly as before
so alice makes a deposit bob makes his
deposit
let's say charlie picks bob
and bob gets the money so
there we don't really see a benefit of
twins and haskell we could just as well
do it in broccoli although
i find that blockly is really only
useful
for learning and for writing extremely
simple contracts because
this is arguably a simple contract and
already it
was quite unwieldy in the blockly editor
and if you do something slightly more
complicated
it gets really very confusing in the
editor
but the point is we can do other things
in this haskell program as well we don't
have to
literally define a contract we can use
the whole power of haskell to help us
write this contract
so for example we see there's lots of
repetition because we always have these
roles
ls bob and charlie so for example we can
define them separately and just say
alice
the type is party
and the role constructor
we can just use this overloaded string
here to
skip the role constructor and just write
it like this
so party implements is string
and the from string method uses the role
constructor
charlie
okay and now i can replace
this everywhere with those
here as well
and here as well i can do the
same for bob and charlie
okay i think i have all the places
now i can do the same this constant 10
is all over the place
so let's give that a name as well let's
call it deposit
and that's of type value
okay
um this token empty empty there's
the ada abbreviation for that
okay and there's slightly more
computation
duplication this choice id so let's also
give that a name
choice id type
choice id
and it takes two parameters the name
which was winner in our case
and the role which is char
okay now it's already
cleaned up quite a bit
and now it's also easy to do more
sophisticated things for example
our contract is slightly asymmetric even
though it sounds like a
symmetric situation i mean alice and bob
are completely symmetric but in our
contract
alice has to deposit first and what we
could do instead is
allow bob to deposit first as well so in
the outermost when
we have two cases one where ls deposits
and one where bob deposits
so we can of course just now copy this
case here and paste it
below and change alice and bob
where appropriate which is not
everywhere because in this choice thing
here
um alice keeps being choice one and bob
keeps being choice too
so would have to concentrate on that but
of course it's much nicer to
extract that into a helper function so
this is of type case
so let me just copy paste or copy this
until there
and now make a local definition
and i don't know what to call it let's
just call it f
and it takes two parties the party that
deposits first
and the party that deposits afterwards
and it gives us a case
let's call it x and y
and just paste this whole thing there
okay and now of course i am not using
the x and y so in this case
alex alice was first so alice is x
and after alice's deposit
we wait for bob okay and this here
can stay the same this
choice okay now i can replace this whole
thing
with my helper function
and write f lsbop
and the advantage is that i know it's
now easy to also add the symmetric case
that
bob can deposit first so i just add a
new line
with another case bob alice
and if all goes well that should still
compile
and if i now send it to the simulator
and start the simulation
now i have two possible actions that can
happen in the first step
alice can deposit 10 or bob can deposit
10.
so let's bob start this time so bob
deposits 10
and now it's alice's turn
and if charlie picks alice then as
before alice wins
so the point i'm making is that
it's of a big advantage to use the
haskell editor to write milo contracts
in haskell
so basically you write a program that
produces
something of type contract and you can
use all the features of haskell
like local functions or whatever to make
your life
easier and avoid co-duplication
and in the blocky editor there's no such
option if we had
wanted to do the same in blockly because
there are no local definitions that you
can do you can't
define local contracts or something like
that so we would have to
paste copy paste this whole big
case and then manually change ls to bob
and bob to alice in the first two
deposits
and we would have lots of good
duplication because this
choice thing here the third win would
have been copy-pasted and there would
have been no way to
abstract that away and only write it
once
and of course you have other options for
example we could also parameterize our
contract
so for example we could use the leaflet
deposit
variable so we could instead do
contract is a function from value to
contract and the first parameter is
deposit
and i delete this here
and now in the main program i can pick a
value for the parameter for example 50
and now if i compile
oh sorry it must be constant 50.
so now if i compile
i have a version of the contract where
now
alice and bob have to deposit 58 each
and then the winner gets 100.
and obviously i could do the same for
the parties
so i could parameterize it over the
three parties
party party
party
and then if i call those ls bob and
charlie
delete this here
then i must also be careful and this
must now depend on a party
let's call it p
and at the appropriate spot here where
the choice happens
i must say choice at d charlie
here as well and now
the contract is parameterized by all
participants
so instead of alice bob and charlie i
can use
charts simon
and alex and
constant 100
what did i do now
oh yes just a parenthesis
problem
okay and now i have
charles and simon and deposits of 100
and alex picks the winner
and it works as before so it's
very nice and easy to using haskell
parameterizing contracts and saving a
lot of
code duplication by just using usual
haskell thank
features like local definitions helper
functions and so on
i could even relatively easily
generalize this to more than three
participants
maybe there are three people i could
even write a contract that's
generic in the number of parties so i
get a list of parties
and then each of them has to deposit and
that would be
very inconvenient if i had to do that by
hand
but just using haskell it's quite
straightforward
and what is also noteworthy here is that
milo
in contrast to pluto's is extremely
basic haskell
so the milo team made a point of only
using very basic haskell functions
of on features so you don't need
lenses you don't need template haskell
you don't even need monarchs
um type level programming all of that is
not present in
malo it's extremely basic standard
haskell
so after what you have learned while
learning pluto is about haskell
milo should be a walk in the park for
you and
very relaxing and simple of course marlo
is not always appropriate because it's
specifically for financial contracts but
if it is appropriate it's a very nice
option because of all the
safety assurances that simon mentioned
and because it's much simpler and easier
to get right than pluto's
for homework i would like you to modify
the contract that i wrote
as follows charlie should
put down a deposit in the very beginning
of twice
the deposit that alice and bob put down
and if he then doesn't choose when it's
his turn to choose
alice and bob get half of what he put
down so
alice and bob each end up with 20 in
this example
so in the very beginning charlie
supposed to put down 20 then
it proceeds as usual so if all goes well
as
and bob both put down 10 and charlie
makes this choice
for example for alice then as before
alice gets the 20 and charlie gets his
original deposit back
but if charlie does not make a choice
and the deadline is reached then his 20
are split amongst alice and bob so
alice and bob both end up with 20.




