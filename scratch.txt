


Then we define the actions, that's basically the redeemers.
So create with argument liquidity pool is for creating a new liquidity
pool closes for closing one, swap is for swapping, remove is for removing
liquidity and add is for adding liquidity.
Note that in the diagrams I showed earlier for simplicity, I
called the redeemer simply create.
So I didn't mention this argument of type liquidity pool.
The datum is a bit more complex than we have seen before.
So it's not just a simple integer or similarly simple
type, it's a type Uniswap datum.
And there are two constructors, one for the factory and one for each pool.
So the factory will use the factory constructor and the pool
will use the pool constructor.
And as I explained before, the datum contains...
for the factory contains a list of all liquidity pools that currently exist.
And the datum for pool contains the liquidity pool that I
didn't mention in the diagram.
And what I did mention in the diagram, it contains the amount of liquidity
that has been minted for this pool.
Remember that gets updated when somebody adds liquidity or removes liquidity.
Next let's look at the pool module, which as I explained before, contains
the business logic, the calculations.
So we have calculate initial liquidity.
It gets the initial amount of token A and B that I put into the pool and
returns the liquidity tokens that are returned in exchange for those.
Then calculate additional liquidity for the case that the pool already exists and
somebody provides additional liquidity.
So the first two arguments are the amount of token already in there.
Then the third one is the liquidity that has already been
minted for the pool, the...
not the liquidity, the liquidity tokens that have already been minted.
And the next two arguments are how many As and Bs are added to the pool.
And the result is how many liquidity tokens will be minted in exchange
for this additional amount.
That's additional liquidity.
Calculate removal is for the opposite case.
So given how many tokens are in the pool how much liquidity
tokens have been minted.
How many liquidity tokens to be removed?
It gives how many token's A and B remain in the pool.
Check swap is arguably the central function of the whole
Uniswap system, calculates a swap.
So this, and this is how many As and Bs are originally in the pool and
this and this says how many As and Bs are after the swap in the pool.
And it just returns whether that's okay or not.
So in principle, it just checks that the product of the last two arguments is
larger than the product of the first two.
And as I explained before, it's a bit more complicated because
the fee is taken into account.
So in this case, it's Oh, 0.3%.
So you can see this is taking into account here.
It also makes sure that none of the amounts ever drops to zero.
So it's not allowed to remove all coins, have one sort or both from a pool.
And that also makes sense because of this product, if one of the
factors was zero, then of course it couldn't be larger than it was before.
Finally, there's this LP ticker function.
It's just a helper function that given a liquidity pool, computes a
token name for the liquidity token.
And the idea here is that this token name should only depend on the
liquidity pool and should be unique.
So each pair of tokens should result in a unique token name.
And in principle it just takes the currency symbols and the token names of
the two tokens or coins, concatenates all of them and hashes that, and then uses
the hash of the concatenation just to get something unique and a slight complication
is here that again must make sure that the order of coins in the pool doesn't matter.
So this way there's a condition here.
So it's checked that they are sorted and if they are not
sorted, then you swap them around.
So the, this function should return the same token name for liquidity pool
with token A and B and for liquidity pool, with token B and A which also
corresponds to what I said earlier about equality for liquidity pools.
Now let's look at the on-chain part.
Only two functions are exported to make the validator for the Uniswap
both factory and pools, because they share the same script address.
They address distinguished by the datum and by the coins that identify
them and validate liquidity forging.
So that's the monetary policy script for the liquidity tokens, but there...
it's a lot of code in this module.
And as I said, I don't want to go through it in detail, let's
rather look at the structure.
So this is the make Uniswap validator function.
And this function contains all the cases for factories and
pools and the various redeemers.
And we have the function validated liquidity forging, which is the
monetary policy for liquidity tokens.
And the idea here is that it doesn't contain any logic and simply delegates
the logic to the Uniswap validator.
And the way it does that is it checks the inputs of the forging transaction
and checks that it's either contains a factory or contains a pool, because if
it does, then this validator will run.
We know that this validator will run and then the validator can
check that the forging is okay.
And the way it does check with the...
Either the factory bool is an input is why are the coins that
identify a factory or pool?
So it checks whether this Uniswap factory coin is in the input or whether
one of the pool coins is in the input.
And then we just have helper functions for all the various
cases and they haven't looked quite long but it's all straightforward.
And it's basically what I explained in the diagram, just spelled out in
detail that all these conditions are satisfied for all the different cases.
One thing I should mention is I didn't use state machines
and I'm not sure it's possible.
I was thinking about that and it wasn't obvious to me, the problem
is, I mean, one should think that both the factory and the individual
pools behave like state machines.
I mean, they are identified by their tokens and they are these
legal transitions and then the data gets updated and so on.
But the problem are, is that sometimes we have both of them invoice the
factory and one of the pools.
And it's not obvious to me whether that's possible with the
current state machine machinery.
So I basically did it by hand and I've wrote this.
Finally, let's look at the off-chain code.
Also no surprises here, it's the usual boiler plate, be
defined two different schemas.
The idea is that one is for the entity that creates the Uniswap factory.
And that only has one endpoint start and no parameters.
And then once that is created a second schema for people that make use of this
Uniswap system, and all the contracts in here will be parameterized by the uniswap
instance that this first action creates.
we make use of the state mechanism.
So of this monad writer mechanism that is accessible via tell, and basically for
all the user operations, we have our own state, we call it user contract state.
So there will be a helper contract that queries for all existing pools.
So then the state would be using this pools constructor and return a
list of pools in a simplified form, it's just a nested pair of pairs
of coin and amount in each pool.
Now the helper function to query the existing funds of a wallet that will
just return a value and then construct us for all the other operations.
So if they have happened, then one of those will be the state.
So for example, if we did a swap, then afterwards the status
will be updated to swapped.
If we removed liquidity, it will be updated to removed and so on.
Then some names for the various tokens, so you need swap for, with the token
name of the NFT in the Uniswap factory, pool state will be the token name for the
coins that identify the liquidity pools.
Then our usual boiler plate to actually get a script instance and
the policy for the liquidity tokens.
Some various helper functions, then all the parameters for the endpoints.
So for example, if we want to create a pool we need to know
the tokens and the amounts.
If you want to swap, it must know the tokens and how much to swap and
the idea is here that one of these two last fields should be zero.
So if you want to put in A and get our B we've would specify the SP amount, how
many As we want to put in, but we would leave the B at zero and the other way
round if we want to swap B against As.
Close if you want to close a pool, we just have to specify which pool.
So we give to two tokens that are in there.
Remove you have to specify the pool and how much liquidity we want to burn and
add again, identify the pool and how many As and how many Bs we want to add.
Now here we have the implementation.
So start, as I said, sets up the whole system and did again, makes use of this
other use case we have used before, the currency forge contract to mint
this NFT, the factory NFT that's then used to identify the Uniswap factory.
Create it's the contract that creates a liquidity pool.
And we see all of these will be, as I mentioned before, identified
by the Uniswap value, which is the result of this start contract here.
So if we have create, we have close, again parameterized by
Uniswap, remove, add, and swap.
And all these functions also make use of the functions from the pools
module, that contain the business logic.
So that will be used both in the validator, on the on-chain
side, as well as on the off chain side in these contracts here.
Swap.
Pools as I said just curious the existing pools.
So it looks for the factory UTXO and checks the datum of that.
And as we know, the datum of the factory contains the list of all pools.
And finally funds just checks our own funds, the funds in
the wallet and returns them.
So these all return values or I mean, funds for example returns
value, pools returns a list of this.
But I mentioned earlier, we want to write that in the state, and this is now
done in, in these endpoint definitions.
So first we have the owner endpoint for setting up the whole system,
which just uses the stop contract.
And then we have the user endpoints, which combined all these
operations that a user can do.
And now there is no return value anymore, and instead we make use of the state.
So we use the last monoid again.
So only the last toll state will be kept.
And we also allow for error.
So if there's an error in one of these contracts, then we will catch that error,
but use a left to write it in the state.
And if there was no error we write the appropriate user contract
state value in the state with the right constructor for either.
So this is done here.
Finally, we also have a stop endpoint that simply stops, it doesn't do anything.
Just, if you look at the definition here at any time you can invoke stop
or one of the others, and if it was one of the others then recursively user
endpoints is called again, but in the case of stop not, so if stop endpoint
is ever called then the contract stops.
There are also tests for Uniswap contained in this Plutus use cases library,
but I don't want to look at them now.
Let's rather look at the Plutus PAB path and how you can
write a front-end for Uniswap.
There is actually one also contained in the Plutus repo.
It's in the Plutus PAB library and there in the examples folder,
so there's a Uniswap folder that contains the simulation monad path
of, of an example, how to do that.
And I took this and copied it into our Plutus pioneer program repo and
slightly modified it to make it more suitable for what I wanted to show you.
When we look at the cabal file for this week's code, there are two executables.
One Uniswap minus PAB, which will run the PAB Memphis solver, and then
one Uniswap minus client, which is a simple console based front-end
for the Uniswap application.
And you see, in the other modules field there is a module Uniswap
and that's listed in both.
So that will contain some common definitions that are used by both paths.
So let's first look at that.
First of all, as I explained when I presented the Oracle demo, we need some
data type that captures the various instances we can run for the wallets.
And in this case, I have three in it.
Hasn't been mentioned before.
That has nothing specifically to do with Uniswap.
This is just used to create some example tokens and
distribute them in the beginning.
Then Uniswap start correponds to the Uniswap start or Uniswap owner schema that
I showed you just now for setting up the whole system and Uniswap user corresponds
to the other path, to the various endpoints to interact with the system.
And this task construct is parameterized by a value of type Uniswap,
which is the result of starting.
So after having started the system, the result would be of type Uniswap and this
is then needed to parameterize the client.
This is just boiler plate, this is this init contract that
distributes the initial funds.
So it again makes use of the forge contract that we have seen before.
And it now producers tokens with token names A, B, C, D and 1 million of each.
And actually it also multiplies that by the number of wallets.
So in this case, I want to use four wallets, wallets one to four,
it's actually 4 million of each of the tokens will be forged.
And once they have been forged, I sent from the forging wallet to all the
other wallets, 1 billion of the tokens.
So one wallet forges 4 million of each, and then loops over the other
wallets and sends them 1 million each.
So this is just needed to set up example tokens and distribute
them amongst the wallets.
This is just a helper function because in order to communicate the various
contract instance IDs and other things I need, I just use helper files and this
is the file name for a given wallet.
So now let's look at the PAB part we will look at the main program in a second,
just this here is the boiler plate I showed you earlier to actually hook up
the PAB mechanism with actual contracts.
So this is all boiler plate, and it uses this Uniswap contracts that are justified
with the three constructors in it Uniswap start and Uniswap user, and in this
part, this is linked with the schema.
So Uniswap user will use the Uniswap user schema that we defined before.
Uniswap start will use the Uniswap owner schema that we defined before and in it
we'll use a schema without endpoints.
And this part here connects these constructors with actual contracts.
So Uniswap user with argument US will use the user endpoints that we looked
at earlier Uniswap start will use the owner endpoint that we looked at earlier.
And init will use the init contract that we just defined in the Uniswap
that's just for demonstration to create these initial coins.
This here is again boiler plate.
Now we can look at the main program.
So in the simulator monad, we execute certain things.
So first we set up the whole system, we start the server and get
the handle to shut it down again.
And then in the end we just wait until the user types a key
and then we shut it down again.
Okay.
So first thing we do is wallet one activates this init contract.
So we know from looking at the code what that will do, it will mint all
these example tokens, ABCD, 4 million of each, and then distribute them.
So that wallets one to four end up with 1 million of each of the
four different tokens and we wait.
So, I mean, this will concurrently start this contract, but then immediately
continue at one block, so we use this wait for state that I explained when
we talked about Oracles to wait until init returns and what init will do is
it will write the currency symbol of the forged example tokens into the state.
So we wait until we see that and then we remember it and we wait until
this init contract has finished.
And then we write the currency symbol into a file that I called symbol dot json.
And we just use encode that comes from data dot aeson, the json
standard json library for Haskell.
So we take this currency symbol and encode it to json and write it in
this file and we write a log message.
Then again for wallet one, we start the Uniswap system.
So we use the Uniswap start constructor and we again use wait for state to
wait until we get the result and the result of the Uniswap start, I explained
it earlier will be a value of type Uniswap, and we need that value in order
to parameterize the user contracts.
So we wait until we get this, I called it US and will log and now Uniswap, the
system is running and now we can start the user instances for all the wallets.
So I loop all our wallets and activate the Uniswap user contract which is
now parameterized by the US value I got in the previous step here.
Okay.
Now I have these handles and in order to interact, to communicate
from the front-end with the server, I need these handles.
So I write them into a file and this is where you says helper function
CID file that I showed you earlier.
So I will end up with four files W one dot CID until W four dot CID, which
contains these contract instance IDs for the four contracts, log message, and
then I just wait until the user types a key and I can shut down the server.
Let's try this out with cabal run Uniswap minus PAB, and now a lot of stuff is
happening, remember, first we forge these example tokens ABCD, and then we need
to distribute them to the other wallets.
Then we have to start the Uniswap system.
And for that, we again have to first forge the Uniswap NFT that identifies
the factory and then create the initial UTXO for the factory that
contains an empty list of pools.
And now we see that all the Uniswap user contracts have started for
wallets one, two, three, four.
If we look, we see the various files that I wrote, so we can look at those.
So symbol dot json is the currency symbol of the example tokens I created.
So I need that to refer to them.
And then we have these W one to W four.
So if you look at one of those, that's the contract instance IDs for the
contract instances for the four wallets.
And in order to find the correct HTTP endpoints to communicate
with them, I need these.
Let's look at the client next.
So as for the Oracle, I also wrote that in Haskell using the same library for
doing HTTP requests and in the main program, first of all, I expect one
command line parameter, just a number from one to four, so that the main program
knows for which wallet it's running.
Then I read the corresponding CID file to get the contract
instance ID for that wallet.
And I read this symbol dot json file to get the currency
symbol of the example tokens.
I read that with something, read file coming from the byte string library, and
decode comes from the aeson library to decode the json back to Haskell data type,
I just check whether there was an error.
And if not, I invoke this go function where give as parameters
the CID, the contracts instance ID and the currency symbol.
And here it's just a loop, I read a command from the console, we get to the
commands a second, and then depending on the command, I involve various helper
functions and the commands exactly correspond to the endpoints we have,
except for stop, I didn't implement stop.
So we can carry our funds, we can look for existing pools, we can create
a pool, we can add liquidity to a pool, we can remove liquidity from
a pool, we can close a pool, and we can swap, which is the whole point.
And commands, it's just this.
So for each of those, we have a command and in order to enter amounts and currency
tokens, currency symbols and token names.
Because the currency symbol will always be the CS, we are only using
our example tokens, I don't need that and for the token name, because the
token names for ABCD I just use a character for that, it's easier to type.
So for example, create Integer Character Integer Character.
So that means create a liquidity pool with that amount of the token with
that token name and that amount of the token with this token name and so on.
This read command, it's just straightforward reads from the
keyboard and then tries to pass that as a command and if it fails it will
just recursively read command again.
And if it succeeds, it returns this command.
Then there are just various helper functions to convert something of
type command into the corresponding parameter types, like create params
or add params from the Uniswap module that I showed you earlier.
This here show coin header and show coin are just to make it look a bit prettier
when we query the funds or the pools, and then we have the various endpoints
and that all makes use a helper function.
Last time, I think for the Oracle I spelled it out, now extracted it.
So I have these helper functions get status, which we need in
order to get something back from the contracts and call endpoint.
So I'm just using this library, this IQ library as last time.
And here, this is the interesting part, this is the request.
So it will be the post request, this is the URL, and I must give
the instance ID, this is here.
So this is of type UUID, so I just convert it into a string and then pick
it to a text because this HTTP library expects text here and the name of the
endpoint and the request body that depends, of course, what parameters.
So this is just a parameter here, that's the third argument in the function.
The response will always be unit and I just check whether
I get a 200 status code or not.
And the get status is a get request that invokes this HTTP endpoint
called status, again with the CID.
And it doesn't take a request body and I have to tell it what I'm dealing with.
So that's why I need this Uniswap contracts type here.
And that's also why this Uniswap client executable also needs
access to this Uniswap module.
And then I just check if the state is empty, which happens right in the
beginning because before in anything else told anything to the state, then I wait a
second and recurse and if there's a state, so it's just E, then I know that this is
of type either text a user contract state.
Recall this user contract state that was one constructor for each
of the endpoints, but if there's an error during contract execution,
I get the error message as a text.
And if something went wrong, then I end in this third case.
And with these two it's easy to write all the cases for the endpoints.
So let's maybe look at one, it get funds.
So I use this call endpoint helper function that I stress short.
So for the endpoint named funds, and in this case, the argument, the request body.
The argument, the request body is just unit.
And I wait for two seconds and then I use this get status helper function.
And if I get a right, then I show the funds that I got and otherwise I recurse.
So I wait until I get the right, because in this case,
there's funds should never fail.
There's no way that can fail.
Therefore I can safely wait forever.
Get pools is similar.
So it's more or less the same, except that instead of funds, I have pools now.
And let's look at one more example, for example, for creating a pool.
So again, I call the endpoint.
I wait for two seconds.
Now that could actually go something wrong.
For example, if I try to create a pool where both coins are the same, or if I
specify a larger liquidity than I have in my wallet, then I would get an error.
So in this case, I, if I get an error, I just log it for the console
and the others are very similar.
Now let's try it out.
Let's start three instances for wallets one, two, three, and try
to recreate the scenario from the diagrams in the beginning.
So I can start it simply by a cabal run Uniswap minus client.
And then as command line parameter, I give one for wallet one, and I do the
same for wallet two and for wallet three.
And I see here that these log messages, that the contract instance
ID and the symbol for token that I can use, the ABCD read correctly.
So now what can I do?
I can, for example, clearing my funds and I see I have A, B, C, D, 1 million
each and a lot of lovelace, let's see three, six, nine, 100,000 ADA.
And I can also look for pools, but right now, there shouldn't be
any, and indeed none are listed.
So let's switch to wallet one, let's say this is Alice, Bob
is two and Charlie is three.
And in the diagrams, we started with Alice setting up a liquidity pool
for tokens A and B, 1,000 and 2,000.
So to do this here, we can type, create thousand A.
Remember that was of type character, so I have to use single quotes and 2000 B.
And I get the created status spec.
So it seems to have worked.
I can query for pools again, and indeed there is one now.
So I see it has A and B and with the correct amounts, 1,000 and 2,000.
The next step was that Bob swaps 100 A for Bs.
So let's do swap 100 A for Bs.
Okay.
Let's check how many funds Bob now has and indeed he has 100 less As and 181 more Bs.
Next Charlie added liquidity.
I think it was 400 and 800, so we can use add 400 A, 800 B.
Now check the pools.
Let me see, it's 1500 and 2619.
Is that correct, so we have 1000 at the beginning, then 100 for
add it by Bob and now 400 by Charlie, so I think that's correct.
Now, if we go back to Alice, she wants to remove her liquidity.
So let's first create her funds.
So she has less A and Bs now because she provided them as liquidity for the pool,
but she has this liquidity token 1,415.
So for example, she can burn them and get tokens in exchange.
She doesn't have to burn all, but in the diagram she did.
So let's do this, so remove 1415 A B, and let's clear her funds again.
So now she doesn't have liquidity token anymore, but she got As and Bs back.
So if we compare, so was 8,000 here so now it's 9,869.
So she got 1,869 Bs and 1,070 As.
And I think the last step was that Charlie closes the pool.
So let's switch to Charlie and let's say, close A B.
And if now we look for pools, then again, we don't get any.
So it all seems to work.
Finally, I want to show how to do this without Haskell, the front-end, and
just use something like curl because somebody in the Q & A asked for that.
So let's see, I have For example, status dot SH you will also find
it in the code folder and I expect one argument, that's the wallet.
And then I just curl to this URL and I interpolate the content of that
file, the correct wallet file given by the first parameter here and status.
And because that's very unwieldy, I pass it on at Piper through tool JQ.
And then I only interested in the current state and dot observable state of the
corresponding json after resulting json.
So if I try this right now for wallet one, for example, and see
that wallet one at the moment has these amounts of the tokens ABCD.
Okay, and...
At least that was the last status.
Maybe it's not up to date.
So for example, I can do funds let's first look at the funds script.
So that again, only takes one parameter, one argument, the wallet, and that that's
a call to this so, same here to put the correct constance, contract instance
ID there, and then endpoint funds.
And this is a post request, so I need a request body.
So this is unit because the funds endpoint doesn't require any
arguments except the unit argument.
So now that I've invoked that if I query status again, it should have been updated.
Probably it hasn't changed yet.
Bit more interesting is what to do with the post requested.
We have interesting arguments, for example, if now, wallet
one wants to create a pool again with 1,000 A and 2000 B.
So we need a request body for the correct parameters for the create params.
So let's look at this.
So I say if it's shared script for that.
So in principle, the call is simple, so now again, contract instance ID
and now it's endpoint create, but the question is what to write in this body.
So I have it here.
So I use similar arguments to in the Haskell implementation.
So first the wallet and then the A amount, A token, B amount, B token.
So maybe we should first check whether it works, so I can do create wallet.
What was it one?
It doesn't matter.
Let's say wallet one, 1,000 A 2,000 B.
Okay.
And now if I query the status, now it hasn't updated yet.
So it's the, it's still the funds status.
So let's try again.
Now I get the created.
So also I have pools.
Sorry.
Pools, wallet one.
Okay, and now the status.
Okay.
Now I see, I have this new liquidity pool with A and B.
So remains the question, how I got this, this body, because that's complicated.
It's hard to do this by hand, but if we look back at the Haskell output, What I
did was here, for example, for create, I always write the URL, where do the
request to, and also the request body.
And we can actually check the code for this.
So if we look at Uniswap client.
This is in the, in this helper function called endpoint.
I brushed over that earlier when I show you the code.
So this is this line here, there write the request body.
So I get the A, that's just a Haskell value that can be encoded to json and I
here in this, in this line where I log, I just use encode from the json library
from sorry, from the aeson library.
So this is now a byte string.
And in order to write that to the console, I need two strings, so I use something
from the byte string library it's called a byte string dot lazy dot character
eight, for character eight encoding.
And so I unpack this byte string to a string and then I log it.
And that's the way I would recommend in order to figure
out what requests bodies to use.
I mean, you don't of course have to write a whole program, you can
also do that in the repl so you just need a value of the correct type.
And then use aeson to encode it and look at the result and then you see
the shape of the json that is expected, and then you can use that and then it's
straightforward to do the call request.
So we don't need a Haskell backend.
You, I mean, once you have curl you can use anything like JavaScript,
for example, to write the front-end.
Okay, that concludes the lecture.
And I think because it's the last lecture, I also don't want to give you homework,
of course you can, if you like play around with this demo and set up your
own liquidity pools and do some swaps, and of course, whatever you want, I
mean, you for example, can try to write a JavaScript front-end, a nice graphical
UI, or you could also as a challenge, think about whether it is possible
to, use the state machine mechanism instead of doing it by hand, as I did.
So this, as I said was the last regular lecture of this course.
I thank you very much again, for all your hard work and your
attention and your enthusiasm.
And I hope you learned a lot and are eager to try it out once
plutus is available on the Testnet.
And then later on the main net.
And I hope to see you again soon in, in a future course about some other
technologies like Atala PRISM or Marlowe.
Thank you very much again, it was a great pleasure teaching this course.
