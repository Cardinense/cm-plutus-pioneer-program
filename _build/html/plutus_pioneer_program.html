

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>1. Plutus Pioneer Program &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Alonzo White Walkthrough" href="alonzo_white.html" />
    <link rel="prev" title="Plutus Pioneer Program Video Notes" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Plutus Pioneer Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#week-01-english-auction">1.1. Week 01 - English Auction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#welcome">1.1.1. Welcome</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-e-utxo-model">1.1.2. The (E)UTxO Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">1.1.2.1. Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-is-spending-allowed">1.1.2.2. When Is Spending Allowed?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#script-context">1.1.2.3. Script Context</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#running-an-example-auction-contract-on-a-local-playground">1.1.3. Running an example auction contract on a local Playground</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-english-auction-contract">1.1.3.1. The English Auction contract</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#to-the-playground">1.1.4. To the Playground</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#plutus-setup">1.1.4.1. Plutus Setup</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-02-validation">1.2. Week 02 - Validation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#before-we-start">1.2.1. Before We Start</a></li>
<li class="toctree-l3"><a class="reference internal" href="#introduction">1.2.2. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plutustx-data">1.2.3. PlutusTx.Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plutus-validator">1.2.4. Plutus Validator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-1-the-gift-contract">1.2.4.1. Example 1 - The Gift Contract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-2-burn">1.2.4.2. Example 2 - Burn</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-3-forty-two">1.2.4.3. Example 3 - Forty Two</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-4-typed">1.2.4.4. Example 4 - Typed</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-5-custom-isdata-types">1.2.4.5. Example 5 - Custom IsData types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#summary">1.2.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-03-script-context">1.3. Week 03 - Script Context</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">1.3.1. Before We Start</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recap">1.3.2. Recap</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scriptcontext">1.3.3. ScriptContext</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#txinfovalidrange">1.3.3.1. txInfoValidRange</a></li>
<li class="toctree-l4"><a class="reference internal" href="#posixtimerange">1.3.3.2. POSIXTimeRange</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-vesting">1.3.4. Example - Vesting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#in-the-playground">1.3.4.1. In the playground</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-2-parameterized-contract">1.3.5. Example 2 - Parameterized Contract</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">1.3.5.1. On-Chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">1.3.5.2. Off-Chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#back-to-the-playground">1.3.5.3. Back to the playground</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-04-monads">1.4. Week 04 - Monads</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">1.4.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monads">1.4.2. Monads</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#hello-world">1.4.2.1. Hello World</a></li>
<li class="toctree-l4"><a class="reference internal" href="#getline">1.4.2.2. getLine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maybe">1.4.2.3. Maybe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#either">1.4.2.4. Either</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writer">1.4.2.5. Writer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-is-a-monad">1.4.2.6. What is a Monad?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-is-this-useful">1.4.2.7. Why Is This useful?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#do-notation">1.4.2.8. ‘do’ notation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#plutus-monads">1.4.3. Plutus Monads</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-emulatortrace-monad">1.4.3.1. The EmulatorTrace Monad</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-contract-monad">1.4.3.2. The Contract Monad</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-05-native-tokens">1.5. Week 05 - Native Tokens</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">1.5.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value">1.5.2. Value</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-value-type">1.5.2.1. The Value Type</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#minting-policies">1.5.3. Minting Policies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-1-free">1.5.4. Example 1 - Free</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">1.5.4.1. On chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">1.5.4.2. Off chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">1.5.4.3. In The Playground</a></li>
<li class="toctree-l4"><a class="reference internal" href="#testing-with-emulatortrace">1.5.4.4. Testing with EmulatorTrace</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-2-signed">1.5.5. Example 2 - Signed</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">1.5.5.1. On-chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">1.5.5.2. Off-chain</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#nfts">1.5.6. NFTs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-3-nft">1.5.6.1. Example 3 - NFT</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-06-oracles">1.6. Week 06 - Oracles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">1.6.1. Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">1.6.1.1. Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#oracle-core">1.6.2. Oracle Core</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id21">1.6.2.1. On-chain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">1.6.2.2. Off-chain</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#swap-validation">1.6.3. Swap Validation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#offerswap">1.6.3.1. offerSwap</a></li>
<li class="toctree-l4"><a class="reference internal" href="#findswaps">1.6.3.2. findSwaps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#retrieveswaps">1.6.3.3. retrieveSwaps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#useswaps">1.6.3.4. useSwaps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#contract-bundle">1.6.3.5. Contract bundle</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#funds-module">1.6.4. Funds Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing">1.6.5. Testing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#test-in-the-repl">1.6.5.1. Test in the REPL</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#plutus-application-backend">1.6.6. Plutus Application Backend</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#oracle-pab">1.6.6.1. Oracle PAB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#oracle-client">1.6.6.2. Oracle Client</a></li>
<li class="toctree-l4"><a class="reference internal" href="#swap-client">1.6.6.3. Swap Client</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-07-state-machines">1.7. Week 07 - State Machines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id23">1.7.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-example-1">1.7.2. Code Example 1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id24">1.7.2.1. On chain</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#code-example-2">1.7.3. Code Example 2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-a-state-machine">1.7.3.1. What is a state machine?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#conclusion">1.7.4. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-08-property-based-testing">1.8. Week 08 - Property Based Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#token-sale">1.8.1. Token Sale</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#on-chain-code">1.8.1.1. On-chain code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#off-chain-code">1.8.1.2. Off-chain code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">1.8.1.3. Testing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unit-testing">1.8.2. Unit Testing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tasty">1.8.2.1. Tasty</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#optics-and-lenses">1.8.3. Optics and Lenses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#property-based-testing">1.8.4. Property Based Testing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#quickcheck">1.8.4.1. QuickCheck</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-09-marlowe">1.9. Week 09 - Marlowe</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id26">1.9.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lecture-by-prof-simon-thompson">1.9.2. Lecture by Prof. Simon Thompson</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#why-do-we-build-dsls">1.9.2.1. Why do we build DSLs?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-kind-of-assurance-can-we-give">1.9.2.2. What kind of assurance can we give?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-does-a-financial-contract-do">1.9.2.3. What does a financial contract do?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#language-design">1.9.2.4. Language design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-marlowe-language">1.9.2.5. The Marlowe Language</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-marlowe-product">1.9.2.6. The Marlowe Product</a></li>
<li class="toctree-l4"><a class="reference internal" href="#demonstration">1.9.2.7. Demonstration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#engineering">1.9.2.8. Engineering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#system-design">1.9.2.9. System Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usability">1.9.2.10. Usability</a></li>
<li class="toctree-l4"><a class="reference internal" href="#assurance">1.9.2.11. Assurance</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">1.9.2.12. Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lecture-by-alex-nemish">1.9.3. Lecture by Alex Nemish</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#follower-contract">1.9.3.1. Follower Contract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-contract">1.9.3.2. Control Contract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#companion-contract">1.9.3.3. Companion Contract</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#playing-in-the-playground">1.9.4. Playing in the Playground</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#blockly">1.9.4.1. Blockly</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#week-10-uniswap">1.10. Week 10 - Uniswap</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-uniswap">1.10.1. What is Uniswap</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uniswap-in-plutus">1.10.2. Uniswap in Plutus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#trying-it-out">1.10.3. Trying it Out</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="alonzo_white.html">2. Alonzo White Walkthrough</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">1. </span>Plutus Pioneer Program</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/plutus_pioneer_program.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="plutus-pioneer-program">
<h1><span class="section-number">1. </span>Plutus Pioneer Program<a class="headerlink" href="#plutus-pioneer-program" title="Permalink to this headline">¶</a></h1>
<div class="section" id="week-01-english-auction">
<h2><span class="section-number">1.1. </span>Week 01 - English Auction<a class="headerlink" href="#week-01-english-auction" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=_zr3W8cgzIQ&amp;t=2394s">Lecture
#1 - Iteration #2</a>.</p>
<p>It covers an introduction to Plutus, the (E)UTxO model (and how it
compares to other models), and concludes with an example English Auction
managed with a Plutus smart contract running on the Plutus Playground.</p>
<p>These notes have been updated to reflect the changes in iteration two of the
program.</p>
<p>The Plutus commit used in these notes is ea0ca4e9f9821a9dbfc5255fa0f42b6f2b3887c4.</p>
</div>
<div class="section" id="welcome">
<h3><span class="section-number">1.1.1. </span>Welcome<a class="headerlink" href="#welcome" title="Permalink to this headline">¶</a></h3>
<p>Learning Plutus isn’t easy, and there are a number of reasons for that.</p>
<ol class="arabic simple">
<li><p>Plutus uses the (E)UTxO model. This is different and less intuitive
than the Ethereum method for creating smart contracts. It has a lot
of advantages, but it requires a new way of thinking about smart
contracts. And that’s before we even start with the language itself.</p></li>
<li><p>Plutus is new and still under rapid development.</p></li>
<li><p>Tooling is not ideal, yet. So, experienced Haskell developers will
notice that the experience with Plutus is not as pleasant, for
example, when trying to access documentation or get syntax hints from
the REPL. It can also be a challenge to build Plutus in the first
place. The easiest way currently is to use Nix. The Plutus team is
working on providing a Docker image, which will help.</p></li>
<li><p>Plutus is Haskell, more or less, which can have a tough learning
curve for those coming from an imperative programming background.</p></li>
<li><p>Plutus is brand new and this means that there are not many help
resources available, such as StackOverflow posts.</p></li>
</ol>
</div>
<div class="section" id="the-e-utxo-model">
<h3><span class="section-number">1.1.2. </span>The (E)UTxO Model<a class="headerlink" href="#the-e-utxo-model" title="Permalink to this headline">¶</a></h3>
<div class="section" id="overview">
<h4><span class="section-number">1.1.2.1. </span>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h4>
<p>One of the most important things you need to understand in order to
write Plutus smart contracts is the accounting model that Cardano uses,
the Extended Unspent Transaction Output model.</p>
<p>The UTxO model, without the (E) is the one that was introduced by
Bitcoin, but there are other models. Ethereum for example, uses the
so-called account-based model, which is what you are used to from normal
banking, where everybody has an account, each account has a balance
and if you transfer money from one account to another then the balances
get updated accordingly.</p>
<p>That is not how the UTxO model works.</p>
<p>Unspent transaction outputs are exactly what the name says. They are
transaction outputs from previous transactions that have happened on the
blockchain that have not yet been spent.</p>
<p>Let’s look at an example where we have two such UTxOs. One belonging to Alice of 100 Ada, and another belonging to Bob of 50 Ada.</p>
<div class="figure align-default">
<img alt="Alice and Bob's UTxOs" src="_images/pic__00000.png" />
</div>
<p>Alice wants to send 10 ADA to Bob, so she needs to create a transaction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A transaction is something that contains an arbitrary number of inputs and
an arbitrary number of outputs. The effect of a transaction is to consume
inputs and produce new outputs.</p>
</div>
<p>The important thing is that you can only ever use complete UTxOs as
input. Alice cannot simply split her existing 100 ADA into a 90 and a
10, she has to use the full 100 ADA as the input to a transaction.</p>
<div class="figure align-default">
<img alt="Alice Creates a Transaction" src="_images/2.png" />
</div>
<p>Once consumed by the transaction, Alice’s input is no longer a UTxO (an unspent transaction). It will
have been spent as an input to Tx 1. So, she needs to create outputs for her transaction.</p>
<p>She wants to pay 10 ADA to Bob, so one output will be 10 ADA (to Bob).
She then wants her change back, so she creates a second output of 90
ADA (to herself). The full UTxO of 100 ADA has been spent, with Bob
receiving a new transaction of 10 ADA, and Alice receiving the change
of 90 ADA.</p>
<div class="figure align-default">
<img alt="Alice's Transaction Generates Two New UTxOs" src="_images/3.png" />
</div>
<p>In any transaction, the sum of the output values must match the sum of
the input values. Although, strictly speaking, this is not true. There
are two exceptions.</p>
<ol class="arabic simple">
<li><p>Transaction fees. In a real blockchain, you have to pay fees for each
transactions.</p></li>
<li><p>Native Tokens. It’s possible for transactions to create new tokens,
or to burn tokens, in which case the inputs will be lower or higher
than the outputs, depending on the scenario.</p></li>
</ol>
<p>Let’s take a look at a slightly more complicated example.</p>
<p>Alice and Bob want to transfer 55 ADA each to Charlie. Alice has no
choice, as she only has one UTxO. Bob also has no choice as neither of
his two UTxOs is large enough to cover the 55 ADA he wishes to send to
Charlie. Bob will have to use both his UTxOs as input.</p>
<div class="figure align-default">
<img alt="Alice and Bob Create a Transaction With Three Outputs" src="_images/4.png" />
</div>
</div>
<div class="section" id="when-is-spending-allowed">
<h4><span class="section-number">1.1.2.2. </span>When Is Spending Allowed?<a class="headerlink" href="#when-is-spending-allowed" title="Permalink to this headline">¶</a></h4>
<p>Obviously it wouldn’t be a good idea if any transaction could spend
arbitrary UTxOs. If that was the case then Bob could spend Alice’s money
without her consent.</p>
<p>The way it works is by adding signatures to transactions.</p>
<p>In transaction 1, Alice’s signature has to be added to the transaction.
In transaction 2, both Alice and Bob need to sign the transaction. Incidentally, this second, more complex, transaction cannot be done in Daedalus, so you would need
to use the CLI for this.</p>
<p>Everything explained so far is just about the UTxO model, not the
(E)UTxO model.</p>
<p>The extended part comes in when we talk about smart contracts, so in
order to understand that, let’s concentrate on the consumption of
Alice’s UTxO of 100 ADA.</p>
<div class="figure align-default">
<img alt="Alice's UTxO as an Input (Blue Line)" src="_images/5.png" />
</div>
<p>In the UTxO model, the validation that decides whether the transaction
that this input belongs to is allowed to consume the UTxO, relies on
digital signatures. In this case, that means that Alice has to sign the
transaction in order for the consumption of the UTxO to be valid.</p>
<p>The idea of the (E)UTxO model is to make this more general.</p>
<p>Instead of having just one condition, namely that the appropriate
signature is present in the transaction, we replace this with arbitrary
logic.</p>
<p>This is where Plutus comes in.</p>
<p>Instead of just having an address that corresponds to a public key that
can be verified by a signature that is added to the transaction, we have
more general addresses, not based on public keys or the hashes of public
keys, but instead contain arbitrary logic which decides under which conditions a
particular UTxO can be spent by a particular transaction.</p>
<p>So, instead of an input being validated simply by its public key, the input will
justify that it is allowed to consume this output with some arbitrary piece of data
that we call the <em>Redeemer</em>.</p>
<div class="figure align-default">
<img alt="The Redeemer Is Used To Validate Spending of the UTxO" src="_images/6.png" />
</div>
<p>We replace the public key address (Alice’s in our example), with a script, and we replace the digital signature with a <em>Redeemer</em>.</p>
<p>What exactly does that mean? What do we mean by <em>arbitrary logic</em>?</p>
<p>It is important to consider the context that the script has. There are several options.</p>
</div>
<div class="section" id="script-context">
<h4><span class="section-number">1.1.2.3. </span>Script Context<a class="headerlink" href="#script-context" title="Permalink to this headline">¶</a></h4>
<div class="section" id="the-bitcoin-approach">
<h5><span class="section-number">1.1.2.3.1. </span>The Bitcoin approach<a class="headerlink" href="#the-bitcoin-approach" title="Permalink to this headline">¶</a></h5>
<p>One option is that all the script sees is the Redeemer. In this case,
the Redeemer contains all the logic necessary to verify the transaction.
This is, incidentally, what Bitcoin does. In Bitcoin, there are smart
contracts, but they are just not very smart. They are called Bitcoin
Script, which works exactly like this. There is a script on the UTxO
side and a redeemer on the input side, and the script gets the redeemer
and uses it to determine if it is ok to consume the UTxO or not.</p>
<p>But this is not the only option. We can decide to give more information
to the script.</p>
</div>
<div class="section" id="the-ethereum-approach">
<h5><span class="section-number">1.1.2.3.2. </span>The Ethereum approach<a class="headerlink" href="#the-ethereum-approach" title="Permalink to this headline">¶</a></h5>
<p>Ethereum uses a different concept. In Ethereum, the script can see
everything - the whole blockchain - the opposite extreme of Bitcoin. In
Bitcoin, the script has very little context, all it can see is the
redeemer. In Ethereum, the Solidity scripts can see the complete state
of the blockchain.</p>
<p>This makes Ethereum scripts more powerful, but it also comes with
problems. Because the scripts are so powerful it is difficult to predict
what a given script will do and that opens the door to all sorts of
security issues and dangers. It is very hard for the developers of an
Ethereum smart contract to predict everything that can happen.</p>
</div>
<div class="section" id="the-cardano-approach">
<h5><span class="section-number">1.1.2.3.3. </span>The Cardano approach<a class="headerlink" href="#the-cardano-approach" title="Permalink to this headline">¶</a></h5>
<p>What Cardano does is something in the middle.</p>
<p>In Plutus, the script cannot see the whole blockchain, but it can see
the whole transaction that is being validated. In contrast to Bitcoin,
it can’t see only the redeemer of the one input, but it can also see all
the inputs and outputs of the transaction, and the transaction itself.
The Plutus script can use this information to decide whether it is ok to
consume the output.</p>
<p>There is one last ingredient that Plutus scripts need in order to be as
powerful and expressive as Ethereum scripts. That is the so-called
Datum. That is a piece of data that can be associated with a UTxO along
with the UTxO value.</p>
<div class="figure align-default">
<img alt="Datum" src="_images/7.png" />
</div>
<p>With this it is possible to prove mathematically that Plutus is at least
as powerful as the Ethereum model - any logic you can express in
Ethereum you can also it can express using the (E)UTxO model.</p>
<p>But it also has a lot of advantages compared to the Ethereum model. For
example, in Plutus, it is possible to check whether a transaction will
validate in your wallet, before you ever send it to the chain.</p>
<p>Things can still go wrong with off-chain validation, however. For
example in the situation where you submit a transaction that has been
validated in the wallet but gets rejected when it attempts to consume an
output on-chain that has already been consumed by another transaction.</p>
<p>In this case, your transaction will fail without you having to pay any
fees.</p>
<p>But if all the inputs are still there that your transaction expects,
then you can be sure that the transaction will validate and will have
the predicted effect.</p>
<p>This is not the case with Ethereum. In Ethereum, the time between you
constructing a transaction and it being incorporated into the
blockchain, a lot of stuff can happen concurrently, and that is
unpredictable and can have unpredictable effects on what will happen
when your script finally executes.</p>
<p>In Ethereum it is always possible that you have to pay gas fees for a
transaction even if the transaction eventually fails with an error. And
that is guaranteed to never happen with Cardano.</p>
<p>In addition to that, it is also easier to analyse a Plutus script and to
check, or even prove, that it is secure, because you don’t have to
consider the whole state of the blockchain, which is unknowable. You can
concentrate on this context that just consists of the spending
transaction. So you have a much more limited scope and that makes it
much easier to understand what a script is actually doing and what can
possibly go wrong.</p>
<p>Who is responsible for providing the datum, redeemer and the validator? The rule in Plutus is that the spending transaction has to do that whereas the producing transaction only has to provide hashes.</p>
<p>That means that if I produce an output that sits at a script address then this producing transaction only has to include the hash of the script
and the hash of the datum that belongs to the output. Optionally it can include the datum and the script as well.</p>
<p>If a transaction wants to consume such an output then <em>that</em> transaction has to provide the datum, the redeemer and the script. Which means that in order to spend a
given input, you need to know the datum, because only the hash is publicly visible on the blockchain.</p>
<p>This is sometimes a problem and not what you want and that’s why you have the option to include the datum in the producing transaction. If this were not possible, only
people that knew the datum by some means other than looking at the blockchain would ever be able to spend such an output.</p>
<p>The (E)UTxO model is not tied to a particular programming language. What
we have is Plutus, which is Haskell, but in principal you could use the
same model with a completely different programming language, and we
intend to write compilers for other programming languages to Plutus
Script which is the “assembly” language underlying Plutus.</p>
</div>
</div>
</div>
<div class="section" id="running-an-example-auction-contract-on-a-local-playground">
<h3><span class="section-number">1.1.3. </span>Running an example auction contract on a local Playground<a class="headerlink" href="#running-an-example-auction-contract-on-a-local-playground" title="Permalink to this headline">¶</a></h3>
<p>Rather than start the traditional way, i.e. starting very simple and
doing a crash course on Haskell, followed by some simple Plutus
contracts and slowly add more complicated stuff, it will be more
interesting, especially for the first lecture, to showcase a more
interesting contract and demonstrate what Plutus can do. We can then use
that to look at certain concepts in more detail.</p>
<div class="section" id="the-english-auction-contract">
<h4><span class="section-number">1.1.3.1. </span>The English Auction contract<a class="headerlink" href="#the-english-auction-contract" title="Permalink to this headline">¶</a></h4>
<p>As our introductory example we are going to look at an English Auction. Somebody wants to auction an NFT (Non-fungible token) - a native token on Cardano that
exists only once. An NFT can represent some digital art or maybe some real-world asset.</p>
<p>The auction is parameterised by the owner of the token, the token itself, a minimal bid and a deadline.</p>
<p>So let’s say that Alice has an NFT and wants to auction it.</p>
<div class="figure align-default">
<img alt="Alice Creates an English Auction" src="_images/pic__000001.png" />
</div>
<p>She creates a UTxO at the script output. We will look at the code later, but first we will just examine the ideas of the UTxO model.</p>
<p>The value of the UTxO is the NFT, and the datum is <em>Nothing</em>. Later on it will be the highest bidder and the highest bid. But right now, there hasn’t yet been a bid.</p>
<p>In the real blockchain you can’t have a UTxO that just contains native tokens, they always have to be accompanied by some Ada, but for simplicity we will ignore that here.</p>
<p>Not let’s say that Bob wants to bid 100 Ada.</p>
<div class="figure align-default">
<img alt="Bob Makes a Bid" src="_images/pic__00001.png" />
</div>
<p>In order to do this, Bob creates a transaction with two inputs and one output. The first input is the auction UTxO and the second input is Bob’s bid of 100 Ada. The output
is, again, at the output script, but now the value and the datum has changed. Previously the datum was <em>Nothing</em> but now it is (Bob, 100).</p>
<p>The value has changed because now there is not only the NFT in the UTxO, but also the 100 Ada bid.</p>
<p>As a redeemer, in order to unlock the original auction UTxO, we use something called <em>Bid</em>. This is just an algebraic data type. There will be other values as well but one
of those is <em>Bid</em>. And the auction script will check that all the conditions are satisfied. So, in this case the script has to check that the bid happens before the deadline,
that the bid is high enough.</p>
<p>It also has to check that the correct inputs and outputs are present. In this case that means checking that the auction is an output containing the NFT and has the correct datum.</p>
<p>Next, let’s assume that Charlie wants to outbid Bob and bid 200 Ada.</p>
<div class="figure align-default">
<img alt="Charlie Makes a Bid" src="_images/pic__00002.png" />
</div>
<p>Charlie will create another transaction, this time one with two inputs and two outputs. As in the first case, the two inputs are the bid (this time Charlie’s bid of 200 Ada),
and the auction UTxO. One of the outputs is the updated auction UTxO. There will also be a second output, which will be a UTxO which returns Bob’s bid of 100 Ada.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In reality the auction UTxO is not updated because nothing ever changes.</p>
<p>What really happens is that the old auction UTxO is spent and a new one is created, but it has the feel of updating the state of the auction UTxO</p>
</div>
<p>This time we again use the <em>Bid</em> redeemer. This time the script has to check that the deadline has been reached, that the bid is higher than the previous bid, it has to
check that the auction UTxO is correctly created and it has to check that the previous highest bidder gets their bid back.</p>
<p>Finally, let’s assume that there won’t be another bid, so once the deadline has been reached, the auction can be closed.</p>
<p>In order to do that, somebody has to create yet another transaction. That could be Alice who wants to collect the bid or it could be Charlie who wants to collect the NFT. It
can be anybody, but Alice and Charlie have an incentive to do so.</p>
<p>This transaction will have one input - the auction UTxO, this time with the <em>Close</em> redeemer - and it will have two outputs. One of the outputs is for highest bidder,
Charlie, and he gets the NFT and the second output goes to Alice who gets the highest bid.</p>
<p>In the <em>Close</em> case, the script has to check that the deadline has been reached and that the winner gets the NFT and the auction owner gets the highest bid.</p>
<p>There is one more scenario for us to consider, namely that nobody makes any bid.</p>
<div class="figure align-default">
<img alt="Nobody Makes a Bid" src="_images/pic__00002.png" />
</div>
<p>Alice creates the auction, but receives no bids. In this case, there must be a mechanism for Alice to retrieve her NFT.</p>
<p>For that she creates a transaction with the <em>Close</em> redeemer, but now because there is no bidder, the NFT doesn’t go to the highest bidder but simply goes back to Alice.</p>
<p>The logic in this case is slightly different. It will check that the NFT goes back to Alice, however, it doesn’t really need to check the recipient because the transaction
will be triggered by Alice and she can send the NFT wherever she wants.</p>
<div class="section" id="on-chain-and-off-chain-code">
<h5><span class="section-number">1.1.3.1.1. </span>On-chain and Off-chain code<a class="headerlink" href="#on-chain-and-off-chain-code" title="Permalink to this headline">¶</a></h5>
<p>The important thing to realise about Plutus is that there is on-chain and off-chain code.</p>
<div class="section" id="on-chain">
<h6><span class="section-number">1.1.3.1.1.1. </span>On-chain<a class="headerlink" href="#on-chain" title="Permalink to this headline">¶</a></h6>
<p>On-chain code is the scripts we were discussing - the scripts from the UTxO model. In addition to public key addresses we have script address and outputs can sit at
such an address, and if a transaction tries to consume such an output, the script is executed, and the transaction is only valid if the script succeeds.</p>
<p>If a node receives a new transaction, it validates it before accepting it into its mempool and eventually into a block. For each input of the transaction, if that input
happens to be a script address, the corresponding script is executed. If the script does not succeed, the transaction is invalid.</p>
<p>The programming language this script is expressed in is called Plutus Core, but you never write Plutus Core by hand. Instead, you write Haskell and that gets compiled
down to Plutus Core. EVentually there may be other high-level languages such as Solidity, C or Python that can compile down to Plutus Core.</p>
<p>The task of a script is to say yes or no to whether a transaction can consume an output.</p>
</div>
<div class="section" id="off-chain">
<h6><span class="section-number">1.1.3.1.1.2. </span>Off-chain<a class="headerlink" href="#off-chain" title="Permalink to this headline">¶</a></h6>
<p>In order to unlock a UTxO, you must be able to construct a transaction that will pass validation and that is the responsibility of the off-chain part of Plutus. This
is the part that runs on the wallet and not on the blockchain and will construct suitable transactions.</p>
<p>One of the nice things about Plutus is that both the on-chain parts and the off-chain parts are written in Haskell. One obvious advantage of that is that you don’t
have to learn two programming languages. The other advantage is that you can share code between the on-chain and off-chain parts.</p>
<p>Later in this course we talk about state machines and then this sharing between on-chain and off-chain code becomes even more direct, but even without state machines
there is still a lot of opportunities to share code.</p>
<p>We will have a brief look at the code but don’t worry, you are not expected to understand it at this point.</p>
<p>The code for the English Auction contract is at</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">/</span><span class="n">repo</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">week01</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">Week01</span><span class="o">/</span><span class="n">EnglishAuction</span><span class="o">.</span><span class="n">hs</span>
</pre></div>
</div>
<p>We see a data type <em>Auction</em> which represents the parameters for the contract that, in our example, Alice starts. The <em>aCurrency</em> and <em>aToken</em> parameters represent the
NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Auction</span> <span class="ow">=</span> <span class="kt">Auction</span>
   <span class="p">{</span> <span class="n">aSeller</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">aDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">POSIXTime</span>
   <span class="p">,</span> <span class="n">aMinBid</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
   <span class="p">,</span> <span class="n">aCurrency</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
   <span class="p">,</span> <span class="n">aToken</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>You also see other data types, but the heart of the code is the <em>mkAuctionValidator</em> function. This is the function that determines whether a given transaction is allowed
to spend a UTxO sitting at this script address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkAuctionValidator #-}</span>
<span class="nf">mkAuctionValidator</span> <span class="ow">::</span> <span class="kt">AuctionDatum</span> <span class="ow">-&gt;</span> <span class="kt">AuctionAction</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkAuctionValidator</span> <span class="n">ad</span> <span class="n">redeemer</span> <span class="n">ctx</span> <span class="ow">=</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong input value&quot;</span> <span class="n">correctInputValue</span> <span class="o">&amp;&amp;</span>
    <span class="kr">case</span> <span class="n">redeemer</span> <span class="kr">of</span>
        <span class="kt">MkBid</span> <span class="n">b</span><span class="o">@</span><span class="kt">Bid</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">-&gt;</span>
            <span class="n">traceIfFalse</span> <span class="s">&quot;bid too low&quot;</span> <span class="p">(</span><span class="n">sufficientBid</span> <span class="n">bBid</span><span class="p">)</span>                <span class="o">&amp;&amp;</span>
            <span class="n">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span> <span class="p">(</span><span class="n">correctBidOutputDatum</span> <span class="n">b</span><span class="p">)</span>    <span class="o">&amp;&amp;</span>
            <span class="n">traceIfFalse</span> <span class="s">&quot;wrong output value&quot;</span> <span class="p">(</span><span class="n">correctBidOutputValue</span> <span class="n">bBid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">traceIfFalse</span> <span class="s">&quot;wrong refund&quot;</span>       <span class="n">correctBidRefund</span>             <span class="o">&amp;&amp;</span>
            <span class="n">traceIfFalse</span> <span class="s">&quot;too late&quot;</span>           <span class="n">correctBidSlotRange</span>
        <span class="kt">Close</span>           <span class="ow">-&gt;</span>
            <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span> <span class="n">correctCloseSlotRange</span> <span class="o">&amp;&amp;</span>
            <span class="kr">case</span> <span class="n">adHighestBid</span> <span class="n">ad</span> <span class="kr">of</span>
                <span class="kt">Nothing</span>      <span class="ow">-&gt;</span>
                    <span class="n">traceIfFalse</span> <span class="s">&quot;expected seller to get token&quot;</span> <span class="p">(</span><span class="n">getsValue</span> <span class="p">(</span><span class="n">aSeller</span> <span class="n">auction</span><span class="p">)</span> <span class="n">tokenValue</span><span class="p">)</span>
                <span class="kt">Just</span> <span class="kt">Bid</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">-&gt;</span>
                    <span class="n">traceIfFalse</span> <span class="s">&quot;expected highest bidder to get token&quot;</span> <span class="p">(</span><span class="n">getsValue</span> <span class="n">bBidder</span> <span class="n">tokenValue</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                    <span class="n">traceIfFalse</span> <span class="s">&quot;expected seller to get highest bid&quot;</span> <span class="p">(</span><span class="n">getsValue</span> <span class="p">(</span><span class="n">aSeller</span> <span class="n">auction</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">bBid</span><span class="p">)</span>

  <span class="kr">where</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>And then here is where the compilation to Plutus Core happens. It uses something called Template Haskell to take the Haskell function above and compile it to Plutus Core.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">auctionTypedValidator</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Auctioning</span>
<span class="nf">auctionTypedValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Auctioning</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkAuctionValidator</span> <span class="o">||</span><span class="p">])</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span>
</pre></div>
</div>
<p>The off-chain part of the code defines the endpoints that can be invoked.</p>
<p>We have three endpoints for this example, and each has a datatype defined to represent their parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">StartParams</span> <span class="ow">=</span> <span class="kt">StartParams</span>
   <span class="p">{</span> <span class="n">spDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">POSIXTime</span>
   <span class="p">,</span> <span class="n">spMinBid</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
   <span class="p">,</span> <span class="n">spCurrency</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
   <span class="p">,</span> <span class="n">spToken</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">BidParams</span> <span class="ow">=</span> <span class="kt">BidParams</span>
   <span class="p">{</span> <span class="n">bpCurrency</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
   <span class="p">,</span> <span class="n">bpToken</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
   <span class="p">,</span> <span class="n">bpBid</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">CloseParams</span> <span class="ow">=</span> <span class="kt">CloseParams</span>
   <span class="p">{</span> <span class="n">cpCurrency</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
   <span class="p">,</span> <span class="n">cpToken</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>Then the off-chain operations are defined.</p>
<p>First the <em>start</em> logic.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">start</span> <span class="ow">::</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">StartParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">start</span> <span class="kt">StartParams</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Auction</span>
                <span class="p">{</span> <span class="n">aSeller</span>   <span class="ow">=</span> <span class="n">pkh</span>
                <span class="p">,</span> <span class="n">aDeadline</span> <span class="ow">=</span> <span class="n">spDeadline</span>
                <span class="p">,</span> <span class="n">aMinBid</span>   <span class="ow">=</span> <span class="n">spMinBid</span>
                <span class="p">,</span> <span class="n">aCurrency</span> <span class="ow">=</span> <span class="n">spCurrency</span>
                <span class="p">,</span> <span class="n">aToken</span>    <span class="ow">=</span> <span class="n">spToken</span>
                <span class="p">}</span>
        <span class="n">d</span> <span class="ow">=</span> <span class="kt">AuctionDatum</span>
                <span class="p">{</span> <span class="n">adAuction</span>    <span class="ow">=</span> <span class="n">a</span>
                <span class="p">,</span> <span class="n">adHighestBid</span> <span class="ow">=</span> <span class="kt">Nothing</span>
                <span class="p">}</span>
        <span class="n">v</span> <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">spCurrency</span> <span class="n">spToken</span> <span class="mi">1</span>
        <span class="n">tx</span> <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="n">d</span> <span class="n">v</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="n">auctionTypedValidator</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;started auction %s for token %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">show</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p>Then the <em>bid</em> logic.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bid</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">BidParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">bid</span> <span class="kt">BidParams</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="o">@</span><span class="kt">AuctionDatum</span><span class="p">{</span><span class="o">..</span><span class="p">})</span> <span class="ow">&lt;-</span> <span class="n">findAuction</span> <span class="n">bpCurrency</span> <span class="n">bpToken</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;found auction utxo with datum %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">d</span><span class="p">)</span>

    <span class="n">when</span> <span class="p">(</span><span class="n">bpBid</span> <span class="o">&lt;</span> <span class="n">minBid</span> <span class="n">d</span><span class="p">)</span> <span class="o">$</span>
        <span class="n">throwError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;bid lower than minimal bid %d&quot;</span> <span class="p">(</span><span class="n">minBid</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">b</span>  <span class="ow">=</span> <span class="kt">Bid</span> <span class="p">{</span><span class="n">bBidder</span> <span class="ow">=</span> <span class="n">pkh</span><span class="p">,</span> <span class="n">bBid</span> <span class="ow">=</span> <span class="n">bpBid</span><span class="p">}</span>
        <span class="n">d&#39;</span> <span class="ow">=</span> <span class="n">d</span> <span class="p">{</span><span class="n">adHighestBid</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">b</span><span class="p">}</span>
        <span class="n">v</span>  <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">bpCurrency</span> <span class="n">bpToken</span> <span class="mi">1</span> <span class="o">&lt;&gt;</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">bpBid</span>
        <span class="n">r</span>  <span class="ow">=</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">MkBid</span> <span class="n">b</span>

        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">typedValidatorLookups</span> <span class="n">auctionTypedValidator</span> <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">auctionValidator</span>                <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>
        <span class="n">tx</span>      <span class="ow">=</span> <span class="kr">case</span> <span class="n">adHighestBid</span> <span class="kr">of</span>
                    <span class="kt">Nothing</span>      <span class="ow">-&gt;</span> <span class="n">mustPayToTheScript</span> <span class="n">d&#39;</span> <span class="n">v</span>                            <span class="o">&lt;&gt;</span>
                                    <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">aDeadline</span> <span class="n">adAuction</span><span class="p">)</span>          <span class="o">&lt;&gt;</span>
                                    <span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="n">r</span>
                    <span class="kt">Just</span> <span class="kt">Bid</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">-&gt;</span> <span class="n">mustPayToTheScript</span> <span class="n">d&#39;</span> <span class="n">v</span>                            <span class="o">&lt;&gt;</span>
                                    <span class="n">mustPayToPubKey</span> <span class="n">bBidder</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">bBid</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                    <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">aDeadline</span> <span class="n">adAuction</span><span class="p">)</span>          <span class="o">&lt;&gt;</span>
                                    <span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="n">r</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="n">lookups</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made bid of %d lovelace in auction %s for token (%s, %s)&quot;</span>
        <span class="n">bpBid</span>
        <span class="p">(</span><span class="n">show</span> <span class="n">adAuction</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="n">bpCurrency</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="n">bpToken</span><span class="p">)</span>
</pre></div>
</div>
<p>And finally the <em>close</em> logic.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">close</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">CloseParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">close</span> <span class="kt">CloseParams</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">d</span><span class="o">@</span><span class="kt">AuctionDatum</span><span class="p">{</span><span class="o">..</span><span class="p">})</span> <span class="ow">&lt;-</span> <span class="n">findAuction</span> <span class="n">cpCurrency</span> <span class="n">cpToken</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;found auction utxo with datum %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">d</span><span class="p">)</span>

    <span class="kr">let</span> <span class="n">t</span>      <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">cpCurrency</span> <span class="n">cpToken</span> <span class="mi">1</span>
        <span class="n">r</span>      <span class="ow">=</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Close</span>
        <span class="n">seller</span> <span class="ow">=</span> <span class="n">aSeller</span> <span class="n">adAuction</span>

        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">typedValidatorLookups</span> <span class="n">auctionTypedValidator</span> <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">auctionValidator</span>                <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>
        <span class="n">tx</span>      <span class="ow">=</span> <span class="kr">case</span> <span class="n">adHighestBid</span> <span class="kr">of</span>
                    <span class="kt">Nothing</span>      <span class="ow">-&gt;</span> <span class="n">mustPayToPubKey</span> <span class="n">seller</span> <span class="n">t</span>                          <span class="o">&lt;&gt;</span>
                                    <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="n">aDeadline</span> <span class="n">adAuction</span><span class="p">)</span>       <span class="o">&lt;&gt;</span>
                                    <span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="n">r</span>
                    <span class="kt">Just</span> <span class="kt">Bid</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">-&gt;</span> <span class="n">mustPayToPubKey</span> <span class="n">bBidder</span> <span class="n">t</span>                         <span class="o">&lt;&gt;</span>
                                    <span class="n">mustPayToPubKey</span> <span class="n">seller</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">bBid</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                    <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="n">aDeadline</span> <span class="n">adAuction</span><span class="p">)</span>       <span class="o">&lt;&gt;</span>
                                    <span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="n">r</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="n">lookups</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;closed auction %s for token (%s, %s)&quot;</span>
        <span class="p">(</span><span class="n">show</span> <span class="n">adAuction</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="n">cpCurrency</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="n">cpToken</span><span class="p">)</span>
</pre></div>
</div>
<p>There is some code to tie everything up.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">AuctionSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">start&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">bid&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">close&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">start&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">start</span>
    <span class="n">bid&#39;</span>   <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;bid&quot;</span>   <span class="o">&gt;&gt;=</span> <span class="n">bid</span>
    <span class="n">close&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;close&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">close</span>
</pre></div>
</div>
<p>And the last lines are just helpers to create a sample NFT to allow us to try the auctioning of this NFT in the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSchemaDefinitions</span> <span class="kt">&#39;&#39;AuctionSchema</span>

<span class="nf">myToken</span> <span class="ow">::</span> <span class="kt">KnownCurrency</span>
<span class="nf">myToken</span> <span class="ow">=</span> <span class="kt">KnownCurrency</span> <span class="p">(</span><span class="kt">ValidatorHash</span> <span class="s">&quot;f&quot;</span><span class="p">)</span> <span class="s">&quot;Token&quot;</span> <span class="p">(</span><span class="kt">TokenName</span> <span class="s">&quot;T&quot;</span> <span class="kt">:|</span> <span class="kt">[]</span><span class="p">)</span>

<span class="nf">mkKnownCurrencies</span> <span class="p">[</span><span class="n">&#39;myToken</span><span class="p">]</span>
</pre></div>
</div>
<p>An example of code reuse is the <em>minBid</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">minBid</span> <span class="ow">::</span> <span class="kt">AuctionDatum</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">minBid</span> <span class="kt">AuctionDatum</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">adHighestBid</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>      <span class="ow">-&gt;</span> <span class="n">aMinBid</span> <span class="n">adAuction</span>
    <span class="kt">Just</span> <span class="kt">Bid</span><span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="ow">-&gt;</span> <span class="n">bBid</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This function gets used in the on-chain part for validation, but also in the off-chain code, in the wallet, before it even bothers to create the transaction, to check
whether it is worth doing so.</p>
</div>
</div>
</div>
</div>
<div class="section" id="to-the-playground">
<h3><span class="section-number">1.1.4. </span>To the Playground<a class="headerlink" href="#to-the-playground" title="Permalink to this headline">¶</a></h3>
<p>We will run this contract in our local Plutus Playground.</p>
<div class="section" id="plutus-setup">
<h4><span class="section-number">1.1.4.1. </span>Plutus Setup<a class="headerlink" href="#plutus-setup" title="Permalink to this headline">¶</a></h4>
<p>Before compiling the sample contract code, we need to setup Plutus. It
is advisable to set up a Nix shell from the main Plutus repository at
which can also be used to compile the example contracts.</p>
<p><a class="reference external" href="https://www.evernote.com/shard/s426/client/snv?noteGuid=b34acc67-c94b-fc64-9350-398a8f6fc6ec&amp;noteKey=7e6b84c9501e9949eef2cadf6e35eaff&amp;sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs426%2Fsh%2Fb34acc67-c94b-fc64-9350-398a8f6fc6ec%2F7e6b84c9501e9949eef2cadf6e35eaff&amp;title=Installation">There are detailed notes on how to do this
here</a>.</p>
<p>This will setup your environment with the dependencies necessary to
compile the sample contracts.</p>
<p>Once you are inside the Nix shell, you can start the Plutus client and
server from the cloned Plutus repository.</p>
<p>The lecture videos were recorded at various times and the Plutus code
that goes along with them was compiled against specific commits of the
Plutus main branch. You can find the commit tag in the cabal.project
file.</p>
<div class="section" id="server">
<h5><span class="section-number">1.1.4.1.1. </span>Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h5>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /path/to/plutus/repo/plutus-playground-client
plutus-playground-server
</pre></div>
</div>
</div>
<div class="section" id="client">
<h5><span class="section-number">1.1.4.1.2. </span>Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h5>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /path/to/plutus/repo/plutus-playground-client
npm run start
</pre></div>
</div>
<p>To check that everything is in order, you can then compile the code for
Week 01. This is not necessary to run the code in the playground, as the
playground can compile the code itself.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /path/to/plutus-pioneer-program/repo/code/week01
cabal build all
</pre></div>
</div>
<p>If all went well in the setup above, you should be able to open the playground at
<a class="reference external" href="https://localhost:8009">https://localhost:8009</a>. You will likely receive a certificate error,
which can be bypassed.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/plutus_playground.png" />
</div>
<p>Copy and paste the EnglishAuction.sh file contents into the playground,
replacing the existing demo contract.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/playground_2.png" />
</div>
<p>Click the compile button. Once it has compiled, click the Simulate
button.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/playground_3.png" />
</div>
<p>The default wallets are setup with 10 Lovelace and 10 T, where T is a
native token simulated by the script in the following lines:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myToken</span> <span class="ow">::</span> <span class="kt">KnownCurrency</span>
<span class="nf">myToken</span> <span class="ow">=</span> <span class="kt">KnownCurrency</span> <span class="p">(</span><span class="kt">ValidatorHash</span> <span class="s">&quot;f&quot;</span><span class="p">)</span> <span class="s">&quot;Token&quot;</span> <span class="p">(</span><span class="kt">TokenName</span> <span class="s">&quot;T&quot;</span> <span class="kt">:|</span> <span class="kt">[]</span><span class="p">)</span>

<span class="nf">mkKnownCurrencies</span> <span class="p">[</span><span class="n">&#39;myToken</span><span class="p">]</span>
</pre></div>
</div>
<p>We are going to treat the token T as a non-fungible token (NFT), and
simulate this by changing the wallets such that Wallet 1 has 1 T and the
other wallets have 0 T.</p>
<p>Also, 10 lovelace is ridiculously low, so let’s give each wallet 1000 Ada, which is 1,000,000,000 lovelace.</p>
<p>Click the “Add Wallet” option, then adjust the balances accordingly:</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00005.png" />
</div>
<p>You can see in the playground that the contract has three endpoints:
start, bid, and close.</p>
<p>The “Pay to Wallet” endpoint is always there by default in the
playground. It allows a simple transfer of Lovelace from one wallet to
another.</p>
<p>Click “start” on wallet 1, to create an auction:</p>
<p>This is where the seller is going to set the rules for the auction.</p>
<p>The getSlot field specifies the deadline for the auction. Bidding after
this deadline will not be allowed by the contract.</p>
<p>Let’s say that the deadline is Slot 10.</p>
<p>Time is measured in POSIX time (seconds since 1st January 1970), so we need to calculate this value. Luckily in the <em>plutus-ledger</em> package in module <em>Ledger.Timeslot</em>,
there is a function <em>slotToPOSIXTime</em>. If we import this into the REPL, we can get the value we need. The simulation starts at the beginning of the Shelley era, so this
value - 1596059101 - reflects that and this will be on July 29th 2020 - the 10th slot of the Shelley era.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week01</span><span class="o">.</span><span class="kt">EnglishAuction</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger.TimeSlot</span>
<span class="kt">Prelude</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Week01</span><span class="o">.</span><span class="kt">EnglishAuction</span><span class="o">&gt;</span> <span class="n">slotToPOSIXTime</span> <span class="mi">10</span>
<span class="kt">POSIXTime</span> <span class="p">{</span><span class="n">getPOSIXTime</span> <span class="ow">=</span> <span class="mi">1596059101</span><span class="p">}</span>
</pre></div>
</div>
<p>Add this value to the deadline field.</p>
<p>The spMinField specifies the minimum amount of ADA that must be bid. If
this minimum is not met by the deadline, no bid will succeed. Let’s make this 100 Ada.</p>
<p>Enter 100000000 into the spMinBid field.</p>
<p>The last two fields - spCurrencySymbol and unTokenName specify the
currency of the NFT that is the subject of the auction. In Plutus a
native token is defined by a currency symbol and a name.</p>
<p>In this case, the symbol is 66 and the token name, as we have seen is T.</p>
<p>Enter these values into their respective fields.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00006.png" />
</div>
<p>We can also insert “wait” actions, to wait for a certain number of
slots. We will need to wait for at least one slot in order for the
transaction to start the auction to complete.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00007.png" />
</div>
<p>Now bidding can start.</p>
<p>Let’s say that Wallets 2 and 3 want to bid for this token.</p>
<p>Wallet 2 is faster, and bids 100 Ada by invoking the bid endpoint
with the parameters as shown below.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00008.png" />
</div>
<p>We now insert another wait action, and now we add a bid by Charlie (Wallet 3) for 200 Ada.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00009.png" />
</div>
<p>Let’s say that these two bids are the only bids.</p>
<p>We now add a wait action that will wait until slot 11, which is the slot after the deadline of
the auction.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00010.png" />
</div>
<p>At this point, anybody can invoke the <em>close</em> endpoint. The auction will
not settle on its own, it needs to be triggered by an endpoint.</p>
<p>When the <em>close</em> endpoint is triggered, the auction will be settled
according to the rules.</p>
<ul class="simple">
<li><p>If there was at least one bid, the highest bidder will receive the
token. This will always be the last bidder as the script will not
allow bids that are not higher than the existing highest bid or bids
that are lower than the minimum bid level.</p></li>
<li><p>If there were no bidders, Wallet 1 will get the token back.</p></li>
</ul>
<p>Let’s say that Alice (Wallet 1) invokes the <em>close</em> endpoint. We will add this
and also add another wait action, which we need at the end in order to
see the final transaction when we run the simulation.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00011.png" />
</div>
<p>Now, click the “Evaluate” button - either the one at the bottom or the
one at the top of the page.</p>
<p>After a little while, you will see the simulator view.</p>
<p>Towards the top of the page you will see the slots that are relevant to
the simulation, that is, the slots where an action occurred. Here we see
that these are slots 1,2,3,4 and 20.</p>
<p>Slot zero is not caused by our contract, it is the Genesis transaction
that sets up the initial balances of the wallets. There are three
outputs for this transaction.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00012.png" />
</div>
<p>Now click on the Slot 1 transaction.</p>
<p>The transaction has one input and three outputs. The input is the
only UTxO that Wallet 1 has. Even though it is two tokens, 1000 Ada
and 1T, they sit in one UTxO. As mentioned earlier, UTxOs always need
to be consumed in their entirety, so the entire UTxO is sent as input.</p>
<p>The outputs are a 10 lovelace fee (this is a demo fee and does not reflect what a real fee would be), 999,999,990 lovelace back Wallet 1, and 1 T to the contract to hold
onto while the bidding takes place. Here you also see the script address.</p>
<p>As we know from the introduction to the UTxO model, there can also be a
datum, and there is a datum, but this is not visible in this display.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00013.png" />
</div>
<p>So now the auction is set up, let’s look at the next transaction, where
Bob (Wallet 2) makes a bid of 100 Ada.</p>
<p>There are two inputs - the script UTxO and the UTxO that Bob owns.</p>
<p>There are also three outputs. The first is a fee of 14,129 lovelace. The second gives Bob his change - his original sum minus the fees and bid. The third
output locks the bid into the contract.</p>
<p>The script validator here must make sure that Wallet 2 can’t just take
the token, so it will only validate in a scenario where there is an
output where the token ends up in the contract again. Remember that in
the (E)UTxO model, all inputs and outputs are visible to the script.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00014.png" />
</div>
<p>Now let’s look at the next transaction. This is where Charlie bids 200 Ada
Lovelace (it is 5 Lovelace in Lars’ videos, but I entered it as 4 and
I’d rather not take all those screenshots again).</p>
<p>The inputs here are Wallet 3’s UTxO and the script address.</p>
<p>The outputs are the change of 6 Lovelace to Wallet 3, the updated script
with the new high bid of 4 Lovelace, and the return of Wallet 2’s bid of
3 Lovelace to Wallet 2’s address.</p>
<p>Again, the logic in the script must make sure that all of this is
handled correctly, i.e. that the new bid is higher than the previous bid
and that the token T continues to be locked in the contract along with
the new bid.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00015.png" />
</div>
<p>The last transaction is the <em>close</em> action. This two inputs - one from Alice
in order to pay for the fees, and the second is the script UTxO as input. There are four outputs - the fees from Alice and the change back to Alice,
and then the successful bid of 200 Ada to Alice and the transfer of the NFT to Charlie.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00016.png" />
</div>
<p>If we scroll down, we can now see the final balances.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00017.png" />
</div>
<p>Let’s check what happens when something goes wrong, for example, if Charlie makes a bid that is lower than Bob’s bid. Let’s say Charlie makes a mistake and bids
only 20 Ada.</p>
<p>Now we see that we have only four transactions, and Bob wins the auction.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00018.png" />
</div>
<p>Let’s see what happens if there are no valid bids.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00019.png" />
</div>
<p>Now there are only three transactions, the last of which is the close transaction. As this is a failed auction, where there was no successful bid, this transaction returns the
NFT to Wallet 1.</p>
<div class="figure align-default">
<img alt="Plutus Playground" src="_images/pic__00020.png" />
</div>
</div>
</div>
</div>
</div>
<div class="section" id="week-02-validation">
<h2><span class="section-number">1.2. </span>Week 02 - Validation<a class="headerlink" href="#week-02-validation" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=sN3BIa3GAOc">Lecture
#2, Iteration #2</a>.</p>
<p>It covers low-level, untyped on-chain validation scripts and high-level,
typed on-chain validation scripts.</p>
<p>The code in this lecture uses the Plutus commit 81ba78edb1d634a13371397d8c8b19829345ce0d</p>
</div>
<div class="section" id="before-we-start">
<h3><span class="section-number">1.2.1. </span>Before We Start<a class="headerlink" href="#before-we-start" title="Permalink to this headline">¶</a></h3>
<p>Let’s talk about an important point that was brought up by one of the pioneers following lecture #1.</p>
<p>You will recall in the auction example, we created three endpoints - <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">bid</span></code> and <code class="docutils literal notranslate"><span class="pre">close</span></code>. For <code class="docutils literal notranslate"><span class="pre">close</span></code> there were two scenarios. If there was a
high-enough bid, the token goes to the highest bidder. If there was not a high-enough bid, the token goes back to the seller.</p>
<p>What would happen if the <code class="docutils literal notranslate"><span class="pre">close</span></code> endpoint wasn’t there? Could the money be locked forever in the contract?</p>
<p>This is a really important point, because what you have to realise is that that UTxOs on the blockchain are just data, they are absolutely passive. In order
for anything to happen there must be a transaction. In order to make progress and to change the state of the blockchain, there must be a new transaction submitted
that consumes various UTxOs and produces new UTxOs.</p>
<p>Only new transactions change the state. A UTxO will never spring into action by itself and do something. You can’t have a smart contract that sits on the blockchain and
the, at some point, suddenly performs an action.</p>
<p>So, we really need the <code class="docutils literal notranslate"><span class="pre">close</span></code> endpoint if we want the auction to be settled. In our case, the endpoint was manually triggered. You could write a contract that
runs in the wallet that would automatically generate the <code class="docutils literal notranslate"><span class="pre">close</span></code> transaction - it is possible to write quite sophisticated off-chain code.</p>
<p>However, from the point-of-view of the blockchain, it is always an external trigger that does something. Nothing happens if it is not externally triggered.</p>
<p>So, if there were no <code class="docutils literal notranslate"><span class="pre">close</span></code> endpoint, or the <code class="docutils literal notranslate"><span class="pre">close</span></code> endpoint never got triggered, the funds would remain sitting at the script address forever.</p>
</div>
<div class="section" id="introduction">
<h3><span class="section-number">1.2.2. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>We saw in the first lecture that there are two sides to a smart contract
- an on-chain part and an off-chain part.</p>
<p>The on-chain part is about validation. It allows nodes to validate a
given transaction and whether it is allowed to consume a given UTxO.</p>
<p>The off-chain part lives in the user’s wallet. It constructs and submits
suitable transactions.</p>
<p>Both are important topics. We have to master both in order to write
smart contracts, but for now we will concentrate on the on-chain part.</p>
<p>Let’s recall the Extended UTxO model where the idea is that we introduce
a new type of address.</p>
<div class="figure align-default">
<img alt="_images/1.png" src="_images/1.png" />
</div>
<p>In the simple UTxO model are so-called public key addresses, where the
address is given by the hash of the public key. If a UTxO sits at such a
public key address, then a transaction can consume that UTxO as an input
if the signature belonging to that public key is included in the
transaction.</p>
<p>What the (E)UTxO model does is extend this by adding script addresses
that can run arbitrary logic.</p>
<p>When a transaction wants to consume a UTxO sitting at a script address
is validated by a node, the node will run the script and then, depending
on the result of the script, decide whether the transaction is valid or
not.</p>
<p>And recall that two were three more additions:</p>
<ol class="arabic simple">
<li><p>Instead of just having signatures on transactions, we have so-called
Redeemers - arbitrary pieces of data.</p></li>
<li><p>On the UTxO output side, we have an additional arbitrary piece of
data called Datum, which you can think of as a little piece of state
that sits on the UTxO.</p></li>
</ol>
<p>Finally, we have the context. There are various choices of what this context can be. It can be very restrictive, consisting just of the Redeemer (as in Bitcoin), or very global, consisting of the whole
state of the blockchain (as in Ethereum). In Cardano, it is the transaction that is being validated, including all its inputs and outputs.</p>
<p>So, there are three pieces of data that a Plutus script gets. The Datum,
sitting at the UTxO, the redeemer, coming from the input and the
validation, and the context, consisting of the transaction being
validated and its inputs and outputs.</p>
<p>In a concrete implementation like Plutus, these pieces of information need to be represented by a concrete data type - a Haskell data type. As it happens,
the choice was made to use the same data type for all three of them. At least at the low-level implementation.</p>
<p>We will look at that first, but in real life nobody would actually use this low-level approach. There are more convenient ways to use more suitable data
types for these things, and we will come to that later in this lecture.</p>
</div>
<div class="section" id="plutustx-data">
<h3><span class="section-number">1.2.3. </span>PlutusTx.Data<a class="headerlink" href="#plutustx-data" title="Permalink to this headline">¶</a></h3>
<p>As mentioned, the datum, redeemer and context share a data type.</p>
<p>That data type is defined in the package <code class="docutils literal notranslate"><span class="pre">plutus-core</span></code>, in the module <code class="docutils literal notranslate"><span class="pre">PlutusCore.Data</span></code>.</p>
<p>It is called, simply, <code class="docutils literal notranslate"><span class="pre">Data</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Data</span> <span class="ow">=</span>
     <span class="kt">Constr</span> <span class="kt">Integer</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
   <span class="o">|</span> <span class="kt">Map</span> <span class="p">[(</span><span class="kt">Data</span><span class="p">,</span> <span class="kt">Data</span><span class="p">)]</span>
   <span class="o">|</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
   <span class="o">|</span> <span class="kt">I</span> <span class="kt">Integer</span>
   <span class="o">|</span> <span class="kt">B</span> <span class="kt">BS</span><span class="o">.</span><span class="kt">ByteString</span>
   <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">)</span>
   <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">NFData</span><span class="p">)</span>
</pre></div>
</div>
<p>It has five constructors.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Constr</span></code> takes an Integer and, recursively, a list of <code class="docutils literal notranslate"><span class="pre">Data</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Map</span></code> takes a list of pairs of <em>Data</em>. You can think of this as a lookup table of key-value pairs where both the key and the value are of type <code class="docutils literal notranslate"><span class="pre">Data</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">List</span></code> takes a list of <code class="docutils literal notranslate"><span class="pre">Data</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> takes a single Integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code> takes a Bytestring</p></li>
</ul>
<p>For those familiar with the JSON format, this is very similar. The constructors are not exactly the same, but, like JSON, you can represent
numbers, strings, lists of data and key-value pairs. It can represent arbitrary data, which makes it very suitable for our purpose.</p>
<p>We can also explore this type in the REPL.</p>
<p>Run the following from the plutus-pioneers-program repository. You may need to start a nix-shell from the Plutus repository before changing into the <code class="docutils literal notranslate"><span class="pre">week02</span></code> directory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">code</span><span class="o">/</span><span class="n">week02</span>
<span class="n">cabal</span> <span class="n">repl</span>
</pre></div>
</div>
<p>From with the REPL, we need to import <code class="docutils literal notranslate"><span class="pre">PlutusTx</span></code> so that we have access to the <code class="docutils literal notranslate"><span class="pre">Data</span></code> type. <code class="docutils literal notranslate"><span class="pre">Data</span></code> is not defined in <code class="docutils literal notranslate"><span class="pre">PlutusTx</span></code>, but it gets re-exported from there.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">PlutusTx</span>
</pre></div>
</div>
<p>We can now get some information about <code class="docutils literal notranslate"><span class="pre">Data</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">:</span><span class="n">i</span> <span class="n">Data</span>
</pre></div>
</div>
<p>This will give information about the type <em>Data</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">PlutusTx</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Data</span>
<span class="kr">type</span> <span class="kt">Data</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">Data</span>
  <span class="ow">=</span> <span class="kt">Constr</span> <span class="kt">Integer</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
  <span class="o">|</span> <span class="kt">Map</span> <span class="p">[(</span><span class="kt">Data</span><span class="p">,</span> <span class="kt">Data</span><span class="p">)]</span>
  <span class="o">|</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Data</span><span class="p">]</span>
  <span class="o">|</span> <span class="kt">I</span> <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">B</span> <span class="n">bytestring</span><span class="o">-</span><span class="mf">0.10</span><span class="o">.</span><span class="mf">12.0</span><span class="kt">:Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Internal</span><span class="o">.</span><span class="kt">ByteString</span>
        <span class="c1">-- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Data</span>
  <span class="c1">-- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="kt">Data</span>
  <span class="c1">-- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Data</span>
  <span class="c1">-- Defined in ‘plutus-core-0.1.0.0:PlutusCore.Data’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="kt">Data</span> <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
</pre></div>
</div>
<p>Now we can play with it. We can use the <code class="docutils literal notranslate"><span class="pre">I</span></code> constructor to create a value of type <code class="docutils literal notranslate"><span class="pre">Data</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">I</span> <span class="mi">42</span>
<span class="kt">I</span> <span class="mi">42</span>
</pre></div>
</div>
<p>We can ask for its type, and confirm that it is indeed of type <code class="docutils literal notranslate"><span class="pre">Data</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">I</span> <span class="mi">42</span>
<span class="kt">I</span> <span class="mi">42</span> <span class="ow">::</span> <span class="kt">Data</span>
</pre></div>
</div>
<p>The easiest way to create a value of type <code class="docutils literal notranslate"><span class="pre">Data</span></code> using the <code class="docutils literal notranslate"><span class="pre">B</span></code> constructor is to use the GHC Extension <code class="docutils literal notranslate"><span class="pre">OverloadedStrings</span></code>. This allows
literal strings to be used in place of string-like data types and the compiler will interpret them as their intended type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">set</span> <span class="o">-</span><span class="kt">XOverloadedStrings</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span>
<span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">Data</span>
</pre></div>
</div>
<p>We can also use more complicated constructors, like <code class="docutils literal notranslate"><span class="pre">Map</span></code> and <code class="docutils literal notranslate"><span class="pre">List</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Data</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Map</span> <span class="p">[(</span><span class="kt">I</span> <span class="mi">42</span><span class="p">,</span> <span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">I</span> <span class="mi">0</span><span class="p">],</span> <span class="kt">I</span> <span class="mi">1000</span><span class="p">)]</span>
<span class="kt">Map</span> <span class="p">[(</span><span class="kt">I</span> <span class="mi">42</span><span class="p">,</span> <span class="kt">B</span> <span class="s">&quot;Haskell&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">I</span> <span class="mi">0</span><span class="p">],</span> <span class="kt">I</span> <span class="mi">1000</span><span class="p">)]</span> <span class="ow">::</span> <span class="kt">Data</span>
</pre></div>
</div>
</div>
<div class="section" id="plutus-validator">
<h3><span class="section-number">1.2.4. </span>Plutus Validator<a class="headerlink" href="#plutus-validator" title="Permalink to this headline">¶</a></h3>
<p>Now we are ready to implement our very first validator.</p>
<div class="section" id="example-1-the-gift-contract">
<h4><span class="section-number">1.2.4.1. </span>Example 1 - The Gift Contract<a class="headerlink" href="#example-1-the-gift-contract" title="Permalink to this headline">¶</a></h4>
<p>We start the script by copy pasting a list of GHC language extensions, plus some dependency imports from the example we used in the last lecture.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE DataKinds           #-}</span>
<span class="cm">{-# LANGUAGE FlexibleContexts    #-}</span>
<span class="o">...</span>

<span class="kr">module</span> <span class="nn">Week02.Gift</span> <span class="kr">where</span>

<span class="kr">import</span>           <span class="nn">Control.Monad</span>       <span class="k">hiding</span> <span class="p">(</span><span class="nf">fmap</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Data.Map</span>            <span class="k">as</span> <span class="n">Map</span>
<span class="o">...</span>
<span class="kr">import</span>           <span class="nn">Text.Printf</span>         <span class="p">(</span><span class="nf">printf</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we write the validator. Ultimately, the validator will be a script, living on the blockchain in Plutus Core, which is a lower-level language based on the
lambda calculus. But, we don’t have to write Plutus Core. We can write Haskell and we will see later how we convert that Haskell into Plutus Core script.</p>
<p>So, we write a Haskell function that represents our validator. As we know, a validator is a script that takes three pieces of
input - the datum, the redeemer and the context, respectively, which, at the lowest level are represented by the <code class="docutils literal notranslate"><span class="pre">Data</span></code> data type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Somewhat surprisingly, the result of the function is <code class="docutils literal notranslate"><span class="pre">()</span></code>. This is the Haskell <code class="docutils literal notranslate"><span class="pre">Unit</span></code> type, similar to <code class="docutils literal notranslate"><span class="pre">void</span></code> in some other languages, like C
or C# or Java - it’s the type that carries no information.</p>
<p><code class="docutils literal notranslate"><span class="pre">Unit</span></code> is a built-in type in Haskell and it has just one value, which is written in the same way as the type itself, as we can see from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="nb">()</span>
<span class="nb">()</span>
<span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="nb">()</span>
<span class="nb">()</span> <span class="ow">::</span> <span class="nb">()</span>
</pre></div>
</div>
<p>A function with a return type of <code class="docutils literal notranslate"><span class="pre">()</span></code> is quite unusual in Haskell. In more mainstream languages, it is quite common for functions or procedures to
return no value. In these situations, the functions are only important for their side-effects, such as a Java function that prints something to
the console.</p>
<p>But Haskell is a pure language. If you want side-effects, this will be shown by the type system. For example if the mkValidator were to perform
any IO, it would have a type signature of:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>This would indicate a function that performs IO side-effects but has no interesting return value.</p>
<p>But, as we know that the real <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function performs no side-effects and returns no value, there is really nothing useful that it can do.</p>
<p>However, there is something that the function can do as well as returning <code class="docutils literal notranslate"><span class="pre">()</span></code>, namely it can throw an exception or have an error. And that’s what Plutus uses.</p>
<p>The idea is that if the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function does not run into an error or throw an exception, then validation succeeds. If it throws an error then
validation fails and the transaction is rejected.</p>
<p>Let’s write the simplest validator that we can.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>The first argument is the datum, the second argument is the redeemer and the third argument is the context. The most simple thing we can do is to completely ignore all three arguments and immediately return <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
<p>What this means is that the script address that corresponds to this validator doesn’t care about the datum, it doesn’t care about the redeemer, and
it doesn’t care about the Context. It will always succeed, and this means that any transaction can consume the script at this address as an input. It does not matter
what datum exists for a UTxO at this script address, it doesn’t matter which redeemer is used for the transaction and it doesn’t matter what structure the transaction has.</p>
<p>If you send any funds to this script address, anybody can immediately take it.</p>
<p>This function is not yet Plutus code, it is just a Haskell function. In order to turn it into a Plutus script, we need to compile it.</p>
<p>The result of our compilation to Plutus will be of type <code class="docutils literal notranslate"><span class="pre">Validator</span></code>. Below the function in <code class="docutils literal notranslate"><span class="pre">Gift.hs</span></code>, we add the following code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">validator</span> <span class="ow">::</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="n">mkValidatorScript</span> <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">mkValidatorScript</span></code> function takes the type <code class="docutils literal notranslate"><span class="pre">CompiledCode</span> <span class="pre">(Data</span> <span class="pre">-&gt;</span> <span class="pre">Data</span> <span class="pre">-&gt;</span> <span class="pre">Data</span> <span class="pre">-&gt;</span> <span class="pre">())</span> <span class="pre">-&gt;</span> <span class="pre">Validator</span></code>. In order to create this type, we must compile
the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> script using something called Template Haskell.</p>
<p>Template Haskell is an advanced feature of Haskell that solves a similar problem as macro systems in other languages. A macro being something that gets
expanded at compile time.</p>
<p>So, with this code</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>We are asking the compiler to write the code for the <code class="docutils literal notranslate"><span class="pre">validator</span></code> function at compile time based on our <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function, and then proceed
with the normal compilation.</p>
<p>You do not need to understand very much about Template Haskell to write Plutus as it is always the same pattern. Once you have seen a couple of
examples, you can more or less just copy and paste.</p>
<p>Template Haskell expects all the code to be available within the Oxford Brackets - <code class="docutils literal notranslate"><span class="pre">[|</span> <span class="pre">|]</span></code>.</p>
<p>With more complicated validators you will likely be relying on multiple helper functions, and you do not want to have to add them within the Oxford Brackets. To avoid this, there is one thing we
need to do to the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function, and that is to make it inlinable by adding the <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>You will see this often in Plutus scripts, and it is usually an indication that a function is meant to be used within a validation script. All
the functions on which the validator depends must be inlinable.</p>
<p>Let’s go back to the REPL and take a look at the validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>:l src/Week02/Gift.hs
Ok, one module loaded.
Prelude PlutusTx Week02.Gift&gt; import Ledger.Scripts
Prelude PlutusTx Ledger.Scripts Week02.Gift&gt; validator
Validator { &lt;script&gt; }
</pre></div>
</div>
<p>We can ask for information about <code class="docutils literal notranslate"><span class="pre">Validator</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Scripts</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Validator</span>
<span class="kr">type</span> <span class="kt">Validator</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">newtype</span> <span class="kt">Validator</span> <span class="ow">=</span> <span class="kt">Validator</span> <span class="p">{</span><span class="n">getValidator</span> <span class="ow">::</span> <span class="kt">Script</span><span class="p">}</span>
        <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Validator</span>
  <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="kt">Validator</span>
  <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Validator</span>
  <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
</pre></div>
</div>
<p>We see that it is a wrapper around <code class="docutils literal notranslate"><span class="pre">getValidator</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Scripts</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="n">getValidator</span> <span class="n">validator</span>
<span class="o">&lt;</span><span class="kt">Script</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>We can then get some information about <code class="docutils literal notranslate"><span class="pre">Script</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Scripts</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Script</span>
<span class="kr">type</span> <span class="kt">Script</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">newtype</span> <span class="kt">Script</span>
  <span class="ow">=</span> <span class="kt">Script</span> <span class="p">{</span><span class="n">unScript</span> <span class="ow">::</span> <span class="n">plutus</span><span class="o">-</span><span class="n">core</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="kt">:UntypedPlutusCore</span><span class="o">.</span><span class="kt">Core</span><span class="o">.</span><span class="kt">Type</span><span class="o">.</span><span class="kt">Program</span>
                          <span class="n">plutus</span><span class="o">-</span><span class="n">core</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="kt">:PlutusCore</span><span class="o">.</span><span class="kt">DeBruijn</span><span class="o">.</span><span class="kt">Internal</span><span class="o">.</span><span class="kt">DeBruijn</span>
                          <span class="n">plutus</span><span class="o">-</span><span class="n">core</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="kt">:PlutusCore</span><span class="o">.</span><span class="kt">Default</span><span class="o">.</span><span class="kt">Universe</span><span class="o">.</span><span class="kt">DefaultUni</span>
                          <span class="n">plutus</span><span class="o">-</span><span class="n">core</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="kt">:PlutusCore</span><span class="o">.</span><span class="kt">Default</span><span class="o">.</span><span class="kt">Builtins</span><span class="o">.</span><span class="kt">DefaultFun</span>
                          <span class="nb">()</span><span class="p">}</span>
        <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Script</span>
  <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="kt">Script</span>
  <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Script</span>
  <span class="c1">-- Defined in ‘plutus-ledger-api-0.1.0.0:Plutus.V1.Ledger.Scripts’</span>
</pre></div>
</div>
<p>And here we see that we have an <code class="docutils literal notranslate"><span class="pre">unScript</span></code> function, which we can run</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Scripts</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="n">unScript</span> <span class="o">$</span> <span class="n">getValidator</span> <span class="n">validator</span>
<span class="kt">Program</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Version</span> <span class="nb">()</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">})))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">5</span><span class="p">}))))))))</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">})))))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">}))))))))))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">5</span><span class="p">}))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">6</span><span class="p">})))))))))))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">4</span><span class="p">}))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">7</span><span class="p">})))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">6</span><span class="p">}))))))))))))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">}))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">6</span><span class="p">})))))))))))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">}))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">6</span><span class="p">})))))))))))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">}))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">6</span><span class="p">})))))))))))</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">})))))))</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">})))))))</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">}))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">4</span><span class="p">})))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">}))))))))))</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">})))))))</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Apply</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">}))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">3</span><span class="p">})))</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">2</span><span class="p">}))))))))))</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">Delay</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">LamAbs</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">0</span><span class="p">})</span> <span class="p">(</span><span class="kt">Var</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">DeBruijn</span> <span class="p">{</span><span class="n">dbnIndex</span> <span class="ow">=</span> <span class="mi">1</span><span class="p">}))))))</span>
</pre></div>
</div>
<p>And here you can see an honest-to-goodness representation of the Plutus Core script for the validator.</p>
<p>Back to the code.</p>
<p>Now we have our first validator, there are two more types that we can define.</p>
<p>One is the <code class="docutils literal notranslate"><span class="pre">ValidatorHash</span></code>, which, as the name suggests is the hash of the validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">valHash</span> <span class="ow">::</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">ValidatorHash</span>
<span class="nf">valHash</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorHash</span> <span class="n">validator</span>
</pre></div>
</div>
<p>And, we can also turn the validator into a script address, which is the script’s address on the blockchain.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="kt">ScriptAddress</span> <span class="n">valHash</span>
</pre></div>
</div>
<p>Now we have a script address represented as <code class="docutils literal notranslate"><span class="pre">scrAddress</span></code>.</p>
<p>We can look at these two results in the REPL</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Scripts</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="n">valHash</span>
<span class="nf">c3168d465a84b7f50c2eeb51ccacd53a305bd7883787adb54236d8d17535ca14</span>

<span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Scripts</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Gift</span><span class="o">&gt;</span> <span class="n">scrAddress</span>
<span class="kt">Address</span> <span class="p">{</span><span class="n">addressCredential</span> <span class="ow">=</span> <span class="kt">ScriptCredential</span> <span class="n">c3168d465a84b7f50c2eeb51ccacd53a305bd7883787adb54236d8d17535ca14</span><span class="p">,</span> <span class="n">addressStakingCredential</span> <span class="ow">=</span> <span class="kt">Nothing</span><span class="p">}</span>
</pre></div>
</div>
<p>With the exception of the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function logic (in our case, one
line), the rest of the code we have written so far is boilerplate and
will be very similar for all Plutus scripts.</p>
<p>In order to actually try this script, we need wallet code. The focus of
this lecture is validation and not wallet code, but briefly, here is the
rest of the code.</p>
<p>Two endpoints are defined. Endpoints are ways for a user to trigger something with input parameters.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint will take an <code class="docutils literal notranslate"><span class="pre">Integer</span></code> argument to specify the number of lovelace that will be deposited to the contract.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint will take no argument and will simply look for UTxOs at this script address and consume them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">GiftSchema</span> <span class="ow">=</span>
            <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">Integer</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint uses the helper function <code class="docutils literal notranslate"><span class="pre">mustPayToOtherScript</span></code> which takes the <code class="docutils literal notranslate"><span class="pre">valHash</span></code> of the recipient script and a <code class="docutils literal notranslate"><span class="pre">Datum</span></code> that, in this example, is
completely ignored. It uses the <code class="docutils literal notranslate"><span class="pre">Datum</span></code> constructor to turn a <code class="docutils literal notranslate"><span class="pre">Data</span></code> into a <code class="docutils literal notranslate"><span class="pre">Datum</span></code>. In this case the <code class="docutils literal notranslate"><span class="pre">Data</span></code> is created using
the <code class="docutils literal notranslate"><span class="pre">Constr</span></code> constructor taking a 0 and an empty list.</p>
<p>Finally the amount to send to the address is specified using the helper function <code class="docutils literal notranslate"><span class="pre">Ada.lovelaceValueOf</span></code>.</p>
<p>The transaction is then submitted, the script waits for it to be confirmed and then prints a log message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">amount</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="n">mustPayToOtherScript</span> <span class="n">valHash</span> <span class="p">(</span><span class="kt">Datum</span> <span class="o">$</span> <span class="kt">Constr</span> <span class="mi">0</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">amount</span>
   <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTx</span> <span class="n">tx</span>
   <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
   <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace&quot;</span> <span class="n">amount</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint is a little bit more complicated.</p>
<p>We use <code class="docutils literal notranslate"><span class="pre">utxoAt</span></code> with our new script address <code class="docutils literal notranslate"><span class="pre">scrAddress</span></code> to lookup all the UTxOs sitting at that address. We then need lookups, which will be used by the wallet
to construct the transaction. Here, we tell the wallet where to find all the UTxOs, and we inform it about the validator. Remember, if you want to consume a UTxO
sitting at a script address, then the spending transaction needs to provide the validator code, whereas the transaction that produces the UTxO only needs to provide the hash.</p>
<p>We then define the transaction by using <code class="docutils literal notranslate"><span class="pre">mustSpendScriptOutput</span></code> for each UTxO found. This is saying that every UTxO sitting at this script address must be spent
by the transaction we are constructing.</p>
<p>We also pass a redeemer which is completely ignored in our example, so we can put anything there - in this case a redeemer created using the <code class="docutils literal notranslate"><span class="pre">I</span></code> constructor of type <code class="docutils literal notranslate"><span class="pre">Data</span></code> with a value of <code class="docutils literal notranslate"><span class="pre">17</span></code>.</p>
<p>Again, we submit, wait for confirmation, and then write a log message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="n">scrAddress</span>
   <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
      <span class="n">lookups</span>  <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>      <span class="o">&lt;&gt;</span>
                 <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">validator</span>
      <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
      <span class="n">tx</span>       <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">I</span> <span class="mi">17</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span>
   <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
   <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
   <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
</pre></div>
</div>
<p>Finally, we put it all together in the <code class="docutils literal notranslate"><span class="pre">endpoints</span></code> function. This is boilerplate code that is telling the wallet to give the option of certain endpoints to
the user and then, once one has been selected, to recurse and continue to offer the same options again and again. In the case of <code class="docutils literal notranslate"><span class="pre">give</span></code> the user will be
required to provide the <code class="docutils literal notranslate"><span class="pre">Integer</span></code> argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">GiftSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">give&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">grab&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">give&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">give</span>
    <span class="n">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;</span>  <span class="n">grab</span>
</pre></div>
</div>
<p>Then we have a little piece of boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSchemaDefinitions</span> <span class="kt">&#39;&#39;GiftSchema</span>
</pre></div>
</div>
<p>And then some code that is used only by the Plutus Playground which allows us to specify additional tokens that can be used for testing.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkKnownCurrencies</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>We will now test the <code class="docutils literal notranslate"><span class="pre">Gift</span></code> script in the playground.</p>
<p>Copy the <code class="docutils literal notranslate"><span class="pre">Gift</span></code> script into the playground, then compile the script in the playground and press the <code class="docutils literal notranslate"><span class="pre">Simulate</span></code> button.</p>
<div class="figure align-default">
<img alt="_images/playground_week2_1.png" src="_images/playground_week2_1.png" />
</div>
<p>And let’s add a third wallet and give all the wallets 10 Ada (10 million lovelace).</p>
<div class="figure align-default">
<img alt="_images/pic__00024.png" src="_images/pic__00024.png" />
</div>
<p>We will create a scenario where wallets 1 and 2 give lovelace, and wallet 3 grabs all of it.</p>
<p>You will see that the playground has rendered UI buttons for the two endpoints <code class="docutils literal notranslate"><span class="pre">give</span></code> and <code class="docutils literal notranslate"><span class="pre">grab</span></code>. Use the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint for to make wallet 1 give 4 Ada and
to make wallet 2 give 6 Ada. Then add a wait action to wait for 1 block, and then use to <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint to make wallet 3 grab the funds. Then add another wait action to wait
for 1 block.</p>
<div class="figure align-default">
<img alt="_images/pic__00025.png" src="_images/pic__00025.png" />
</div>
<p>And now click <code class="docutils literal notranslate"><span class="pre">Evaluate</span></code>. We see that there have been four transactions.</p>
<p>The first transaction is, as always, the genesis transaction that distributes the initial funds to the wallets.</p>
<div class="figure align-default">
<img alt="_images/pic__00026.png" src="_images/pic__00026.png" />
</div>
<p>And there are two transactions which occur at slot 1. They are the two <code class="docutils literal notranslate"><span class="pre">give</span></code> transactions.</p>
<p>The first one, Tx 0, is from wallet 2. The order here is not determined by the order that we created the transactions in the simulator. The important thing to note is that
both <code class="docutils literal notranslate"><span class="pre">give</span></code> transactions occurred at the same slot.</p>
<p>We see the three outputs. The first output is the 10 lovelace fee paid by wallet 2. The second output is the 6 Ada sent to the script address, and the third output is the returning of the change to wallet 2, which is 4 Ada minus the fees.</p>
<div class="figure align-default">
<img alt="_images/pic__00027.png" src="_images/pic__00027.png" />
</div>
<p>And the second, Tx 1, is from wallet 1. Again, with similar output UTxOs.</p>
<div class="figure align-default">
<img alt="_images/pic__00028.png" src="_images/pic__00028.png" />
</div>
<p>We now have two UTxOs sitting at the script address.</p>
<p>Then we have the <code class="docutils literal notranslate"><span class="pre">grab</span></code> at slot 2 triggered by wallet 3. We see the two UTxOs from the script as inputs, and then two outputs. One output is the fees and the other
is the output, paid to wallet 3, is of 10 Ada minus those fees. You’ll notice that the fees are now higher than we saw before, and this is because a script has now been
executed, which makes it more expensive. However, the fees here are not yet entirely calibrated with those that would be charged on the real blockchain.</p>
<div class="figure align-default">
<img alt="_images/pic__00029.png" src="_images/pic__00029.png" />
</div>
<p>And, by scrolling down, we see the final wallet balances.</p>
<div class="figure align-default">
<img alt="_images/pic__00030.png" src="_images/pic__00030.png" />
</div>
<p>If you were to scroll down further you would see some traces and log outputs that would give more detail about the execution.</p>
<p>As mentioned, this script uses the simplest validator possible, one that always succeeds. But this silly little validator may be useful in a
situation where someone wants to donate some lovelace to the community and leave it up for grabs!</p>
</div>
<div class="section" id="example-2-burn">
<h4><span class="section-number">1.2.4.2. </span>Example 2 - Burn<a class="headerlink" href="#example-2-burn" title="Permalink to this headline">¶</a></h4>
<p>Let’s look at the second example of validation.</p>
<p>We will start by copying the <code class="docutils literal notranslate"><span class="pre">Gift.hs</span></code> code and renaming it <code class="docutils literal notranslate"><span class="pre">Burn.hs</span></code>.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">Gift</span></code> example we had a validator that would always succeed. In this example, we want to do the opposite - a validator that always fails.</p>
<p>Recall that a validator indicates failure by throwing an error. So we can modify our validator accordingly.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="nb">()</span>
</pre></div>
</div>
<p>If we load the module in the REPL and look at <em>error</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="ne">error</span>
<span class="ne">error</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>We see the definition for the <code class="docutils literal notranslate"><span class="pre">error</span></code> function defined in the standard Haskell <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>. However, the one in scope in our code is in fact the following <code class="docutils literal notranslate"><span class="pre">error</span></code> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Prelude</span><span class="o">.</span><span class="ne">error</span>
<span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Prelude</span><span class="o">.</span><span class="ne">error</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>In regular Haskell, you have the <code class="docutils literal notranslate"><span class="pre">error</span></code> function which takes an error message string and triggers an error. In Plutus, the <code class="docutils literal notranslate"><span class="pre">error</span></code>
function does not take a string - it just takes <code class="docutils literal notranslate"><span class="pre">()</span></code> and returns an arbitrary type.</p>
<p>And that takes us to an important point.</p>
<p>We mentioned earlier that we use the <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma on the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function in order to allow it to be used by the Template Haskell code.
In Haskell there are many functions available via the <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> module, but these will not be usable in Plutus as they are not defined as inlinable.
So, the Plutus team have provided an alternative Prelude that can be used in validation.</p>
<p>The way that the Plutus Prelude is able to take precedence over the Haskell Prelude, which is normally in scope by default, is by using the following <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragma in the code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE NoImplicitPrelude   #-}</span>
</pre></div>
</div>
<p>Then, by importing <code class="docutils literal notranslate"><span class="pre">PlutusTx.Prelude</span></code>, its functions are used in place of the standard Prelude functions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">PlutusTx.Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">Semigroup</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="nf">unless</span><span class="p">)</span>
</pre></div>
</div>
<p>You may also notice that the standard Prelude is also imported. However, it is only in order to bring in some functions that have nothing to do with validation but is
for the off-chain code and the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">IO</span><span class="p">,</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="kt">String</span><span class="p">)</span>
</pre></div>
</div>
<p>It can be confusing. A lot of the functions in the Plutus Prelude do have the same signatures and same behaviour as their namesakes in the standard Prelude, but that
is not always the case, and <code class="docutils literal notranslate"><span class="pre">error</span></code> is an example.</p>
<p>Just remember that when you are using something in a Plutus script that looks like a function from the standard Prelude, what you are actually using is a
function from the Plutus Prelude. Often they will have the same signature, but they are not always identical - for example operator precedents may not be the same</p>
<p>Looking again at our new validator, we now have a validator that will always fail.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="ne">error</span> <span class="nb">()</span>
</pre></div>
</div>
<p>We will leave everything else as it was and check the effect of this change, using the playground. After clicking <code class="docutils literal notranslate"><span class="pre">Compile</span></code>, the previous scenario
should still be present in the simulator. And after clicking <code class="docutils literal notranslate"><span class="pre">Evaluate</span></code> and scrolling down a little, we can see that wallets 1 and 2 have made their gifts but
wallet 3 has been unable to grab.</p>
<div class="figure align-default">
<img alt="_images/pic__00031.png" src="_images/pic__00031.png" />
</div>
<p>If we scroll down further, we will find a log message showing that validation failed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">,</span> <span class="n">Slot</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
      <span class="n">Contract</span> <span class="n">instance</span> <span class="n">stopped</span> <span class="k">with</span> <span class="n">error</span><span class="p">:</span> <span class="s2">&quot;WalletError (ValidationError (ScriptFailure (EvaluationError [])))&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>So, in our first example we had a validator that would always succeed and would allow anyone to grab the UTxOs from it. In the second example,
we have a validator that always fails and any UTxOs sent to this script address can never be retrieved. This is basically a way to burn funds,
which may be useful under some circumstances.</p>
<p>When we look at the logs, we see that validation fails, but we have no clue why it fails. here’s a way to change that by using a variant of
error - <code class="docutils literal notranslate"><span class="pre">traceError</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Burn</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Prelude</span><span class="o">.</span><span class="n">traceError</span>
<span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Prelude</span><span class="o">.</span><span class="n">traceError</span> <span class="ow">::</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Builtins</span><span class="o">.</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>The function takes a string, but not a Haskell string. It is a Plutus
string. In order for this to compile, we need to use the <code class="docutils literal notranslate"><span class="pre">OverloadedStrings</span></code> GHC extension.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE OverloadedStrings   #-}</span>
</pre></div>
</div>
<p>Then, we can update our validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">traceError</span> <span class="s">&quot;BURNT!&quot;</span>
</pre></div>
</div>
<p>If we now run the same scenario in the playground with the new code, we will see the custom error message that we added.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">,</span> <span class="n">Slot</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
      <span class="n">Contract</span> <span class="n">instance</span> <span class="n">stopped</span> <span class="k">with</span> <span class="n">error</span><span class="p">:</span> <span class="s2">&quot;WalletError (ValidationError (ScriptFailure (EvaluationError [</span><span class="se">\&quot;</span><span class="s2">BURNT!</span><span class="se">\&quot;</span><span class="s2">])))&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="_images/pic__00032.png" src="_images/pic__00032.png" />
</div>
</div>
<div class="section" id="example-3-forty-two">
<h4><span class="section-number">1.2.4.3. </span>Example 3 - Forty Two<a class="headerlink" href="#example-3-forty-two" title="Permalink to this headline">¶</a></h4>
<p>For the next example, we will write a validator that does not completely ignore all its arguments. We’ll write one that expects a simple redeemer.</p>
<p>Now that we care about the redeemer, we need to be able to reference it. Let’s call it <code class="docutils literal notranslate"><span class="pre">r</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="n">r</span> <span class="kr">_</span>
</pre></div>
</div>
<p>Let’s say that we want validation to pass if the redeemer is <code class="docutils literal notranslate"><span class="pre">I</span> <span class="pre">42</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="n">r</span> <span class="kr">_</span>
   <span class="o">|</span> <span class="n">r</span> <span class="o">==</span> <span class="kt">I</span> <span class="mi">42</span> <span class="ow">=</span> <span class="nb">()</span>
   <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">traceError</span> <span class="s">&quot;wrong redeemer&quot;</span>
</pre></div>
</div>
<p>If we were to run this now in the playground, validation would always fail. We need to modify the off-chain code to add an input to the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint so that
wallet 3 can pass in an <code class="docutils literal notranslate"><span class="pre">Integer</span></code> which we can then pass to the validator as the redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">GiftSchema</span> <span class="ow">=</span>
          <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">Integer</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="kt">Integer</span>
</pre></div>
</div>
<p>We add the redeemer argument to the <code class="docutils literal notranslate"><span class="pre">grab</span></code> declaration. Note the addition of the <code class="docutils literal notranslate"><span class="pre">Integer</span></code> in the function signature, as well as the new
<code class="docutils literal notranslate"><span class="pre">n</span></code> parameter which is used to reference it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">do</span>
</pre></div>
</div>
<p>We can then pass it to the <code class="docutils literal notranslate"><span class="pre">mustSpendScriptOutput</span></code> function instead of the throw-away value we used earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">I</span> <span class="n">n</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span>
</pre></div>
</div>
<p>One more change, we need to change the <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> in the following code, now that <code class="docutils literal notranslate"><span class="pre">grab</span></code> has an argument. You can use the REPL to look at
the types <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> to see why the second one is now needed. Basically, they both sequence actions, but <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> ignores any wrapped values,
whereas <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> accesses the wrapped value and passes it to the next action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">grab</span>
</pre></div>
</div>
<p>Now we can try it out in the playground. After adding the new code and clicking <code class="docutils literal notranslate"><span class="pre">Simulate</span></code> you will notice that the old scenario has gone. That
is because the endpoints have changed and the old scenario is no longer valid.</p>
<p>Let’s set up a scenario that uses just two wallets. Wallet one is going to give 3 Ada oo the contract, and wallet 2 is going to try to grab them, but
this time, wallet 2 will need to pass in a value which will be used to construct the redeemer.</p>
<p>For our first attempt, we will add the wrong redeemer value, in this case 100.</p>
<div class="figure align-default">
<img alt="_images/pic__00033.png" src="_images/pic__00033.png" />
</div>
<p>If we click <code class="docutils literal notranslate"><span class="pre">Evaluate</span></code>, we see that we only have two transactions, and we see that the Ada remains in the script, which shows that wallet 2 failed to grab it.</p>
<div class="figure align-default">
<img alt="_images/pic__00034.png" src="_images/pic__00034.png" />
</div>
<p>The final balances also show this.</p>
<div class="figure align-default">
<img alt="_images/pic__00035.png" src="_images/pic__00035.png" />
</div>
<p>And, if we look at the trace, we find the error.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">,</span> <span class="n">Slot</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
      <span class="n">Contract</span> <span class="n">instance</span> <span class="n">stopped</span> <span class="k">with</span> <span class="n">error</span><span class="p">:</span> <span class="s2">&quot;WalletError (ValidationError (ScriptFailure (EvaluationError [</span><span class="se">\&quot;</span><span class="s2">wrong redeemer</span><span class="se">\&quot;</span><span class="s2">])))&quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>If we go back to scenario, change the value to <code class="docutils literal notranslate"><span class="pre">42</span></code> and click <code class="docutils literal notranslate"><span class="pre">Evaluate</span></code> again, we should see that validation succeeds.</p>
<div class="figure align-default">
<img alt="_images/pic__00036.png" src="_images/pic__00036.png" />
</div>
<p>Now we see the third transaction where wallet 2 manages to collect the funds, minus fees.</p>
<div class="figure align-default">
<img alt="_images/pic__00037.png" src="_images/pic__00037.png" />
</div>
<p>We see that the final balances are as we expect, and also the logs show that validation did not throw an error, which means that validation succeeded.</p>
<p>So that’s the first example of a validator that looks at at least one of its arguments.</p>
</div>
<div class="section" id="example-4-typed">
<h4><span class="section-number">1.2.4.4. </span>Example 4 - Typed<a class="headerlink" href="#example-4-typed" title="Permalink to this headline">¶</a></h4>
<p>It was mentioned at the beginning of the lecture, this is low-level Plutus and in reality, no-one will write validation functions like this.</p>
<p>Now we will see how it is actually done using a typed version.</p>
<p>Even though the <code class="docutils literal notranslate"><span class="pre">Data</span></code> type is powerful and you can encode all sorts of data into it, it doesn’t really feel like Haskell. It is almost like you
are writing in an untyped language like Javascript or Python. It is just a like a blob of data, it can contain anything so you don’t really have
any type safety. You will always need to check, for example, if you are expecting an integer that you are indeed given an integer.</p>
<p>It is especially bad with the third argument, the context. Even though it’s easy to imagine that you can somehow encode a transaction with its inputs and outputs into
the <code class="docutils literal notranslate"><span class="pre">Data</span></code> type, it is not at all clear how that is done.</p>
<p>We would rather use more specific data types that are tailored to the business logic.</p>
<p>This is indeed possible with so-called Typed Validators. What this means is that we can replace the occurrences of <code class="docutils literal notranslate"><span class="pre">Data</span></code> in the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> signature
with more suitable types.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>In our silly little example, we completely ignore the Datum, so a more
suitable type would be just the Unit type - ().</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>For the redeemer, in this example, we are only dealing with integers, so
it would probably make more sense to use Integer instead.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>For the context, there is a much nicer type called <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code> that’s made exactly for this purpose.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Finally, we have already mentioned that it is a bit unusual to use <code class="docutils literal notranslate"><span class="pre">()</span></code> as a return type. Much more natural would be to use <code class="docutils literal notranslate"><span class="pre">Bool</span></code> to indicate
successful or failed validation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>So, this is a better way to write validation code. The last two types <code class="docutils literal notranslate"><span class="pre">SciprtContext</span></code> and <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, but the first two types can be different depending on the situation.</p>
<p>In this case, let’s now rewrite the function accordingly using these new types. The parameter <code class="docutils literal notranslate"><span class="pre">r</span></code> is now no longer of type <code class="docutils literal notranslate"><span class="pre">Data</span></code> - it is an <code class="docutils literal notranslate"><span class="pre">Integer</span></code>, so
we can simply check that it is equal to 42 rather than checking it against a constructed <code class="docutils literal notranslate"><span class="pre">Data</span></code> type.</p>
<p>And, as we are now returning a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, we can we just make the function a boolean expression.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="n">r</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>This will have the same problem that we had before in that, in the case of an error, we won’t get a nice error message. There is a nice Plutus function
called <code class="docutils literal notranslate"><span class="pre">traceIfFalse</span></code> which takes a <code class="docutils literal notranslate"><span class="pre">String</span></code> and a <code class="docutils literal notranslate"><span class="pre">Bool</span></code> and returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. If the first <code class="docutils literal notranslate"><span class="pre">Bool</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result will be <code class="docutils literal notranslate"><span class="pre">True</span></code> and the <code class="docutils literal notranslate"><span class="pre">String</span></code> is
ignored. However, if the first <code class="docutils literal notranslate"><span class="pre">Bool</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, then the result will be <code class="docutils literal notranslate"><span class="pre">False</span></code> and the <code class="docutils literal notranslate"><span class="pre">String</span></code> will be logged.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Prelude</span><span class="o">.</span><span class="n">traceIfFalse</span>
      <span class="ow">::</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">Builtins</span><span class="o">.</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>This is exactly what we need.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="n">r</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;wrong redeemer&quot;</span> <span class="o">$</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>This will not yet compile as other parts of the code are not yet type correct. We need to adapt our boilerplate.</p>
<p>First, we introduce a new dummy data type, which here we call <code class="docutils literal notranslate"><span class="pre">Typed</span></code>, simply based on the name of the script. For this type we must provide an instance
of <code class="docutils literal notranslate"><span class="pre">Scripts.ValidatorTypes</span></code>.</p>
<p>The purpose of this instance is to declare the types for the datum and the redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Typed</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ValidatorTypes</span> <span class="kt">Typed</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Typed</span> <span class="ow">=</span> <span class="nb">()</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Typed</span> <span class="ow">=</span> <span class="kt">Integer</span>
</pre></div>
</div>
<p>This is quite advanced Haskell, so-called type-level programming, but just like the Template Haskell we have already encountered, you don’t
really need a deep understanding of it as all scripts will follow the same pattern.</p>
<p>Now we need to compile the validator. Where previously we used <code class="docutils literal notranslate"><span class="pre">mkValidatorScript</span></code>, now we use something called <code class="docutils literal notranslate"><span class="pre">mkTypedValidator</span></code>, which takes our
new data type as parameter and produces something of type <code class="docutils literal notranslate"><span class="pre">TypedValidator</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Typed</span>
<span class="nf">typedValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Typed</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="kt">Integer</span>
</pre></div>
</div>
<p>This is similar to the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> code, but this type we also compile a <code class="docutils literal notranslate"><span class="pre">wrapValidator</span></code> function that takes the datum and redeemer types.</p>
<p>In order for this to work we first need one more import.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Ledger.Typed.Scripts</span> <span class="k">as</span> <span class="n">Scripts</span>
</pre></div>
</div>
<p>In this example, it is being imported qualified and using the <code class="docutils literal notranslate"><span class="pre">Scripts</span></code> prefix, but this is arbitrary and you could pick some other way of referencing the module.</p>
<p>We these changes, the Haskell code will compile, and we now need to change the Template Haskell boilerplate that creates the <code class="docutils literal notranslate"><span class="pre">validator</span></code> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">validator</span> <span class="ow">::</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="n">typedValidator</span>
</pre></div>
</div>
<p>Here we have used the <code class="docutils literal notranslate"><span class="pre">validatorScript</span></code> function to create an untyped validator from our typed version.</p>
<p>To get the hash we could, of course, use the validator we now have and turn it into a <code class="docutils literal notranslate"><span class="pre">ValidatorHash</span></code> as we did before, but there is a more direct way, which looks
identical, but in this case <code class="docutils literal notranslate"><span class="pre">Scripts</span></code> is coming from the module <code class="docutils literal notranslate"><span class="pre">Ledger.Typed.Scripts</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Ledger.Scripts</span></code>. This version takes the typed validator directly.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">valHash</span> <span class="ow">::</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">ValidatorHash</span>
<span class="nf">valHash</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorHash</span> <span class="n">typedValidator</span>
</pre></div>
</div>
<p>The script address is calculated as before.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="n">validator</span>
</pre></div>
</div>
<p>In this extremely simply example, it probably doesn’t seem worth the effort, but for realistic contracts, it is much nicer to do it like this.</p>
<p>The off-chain code is almost identical.</p>
<p>There is a small change change to the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint. Although we have not yet gone over this part of the code in detail, the following changes can be made.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="nb">()</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">amount</span>
<span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="n">inst</span> <span class="n">tx</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">mustPayToOtherScript</span></code> function has been replaced with <code class="docutils literal notranslate"><span class="pre">mustPayToTheScript</span></code>. This is a convenience script which allows us to pass
in just () as we longer need to construct a value of type <code class="docutils literal notranslate"><span class="pre">Data</span></code>. We also no longer need to pass in the script hash.</p>
<p>The behaviour of this code will be identical to the behaviour in the previous example, so we won’t go over it in the playground.</p>
<p>Now we will explain how that actually works. How does Plutus convert these custom data types to the actual low-level implementation - the <code class="docutils literal notranslate"><span class="pre">Data</span></code> type.</p>
<p>We can look at the code in the <code class="docutils literal notranslate"><span class="pre">PlutusTx.IsData.Class</span></code> module.</p>
<p>Here we see that there is a quite simple type class defined called <code class="docutils literal notranslate"><span class="pre">IsData</span></code>.</p>
<div class="figure align-default">
<img alt="_images/pic__00037.png" src="_images/pic__00037.png" />
</div>
<p>This class provides two functions</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">toData</span></code> takes a value and converts it to <code class="docutils literal notranslate"><span class="pre">Data</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fromData</span></code> takes a value of type <code class="docutils literal notranslate"><span class="pre">Data</span></code> and attempts to convert it to an instance of type <code class="docutils literal notranslate"><span class="pre">IsData</span></code>. This can fail because not all values of
type <code class="docutils literal notranslate"><span class="pre">Data</span></code> will be convertible to the target type.</p></li>
</ul>
<p>Let’s try this out in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">PlutusTx</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">PlutusTx.IsData.Class</span>
<span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="o">.</span><span class="kt">Class</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">IsData</span>
</pre></div>
</div>
<p>We know that <code class="docutils literal notranslate"><span class="pre">()</span></code> and <code class="docutils literal notranslate"><span class="pre">Integer</span></code> are both instances of <code class="docutils literal notranslate"><span class="pre">IsData</span></code> because they worked in our example.</p>
<p>Let’s convert an <code class="docutils literal notranslate"><span class="pre">Integer</span></code> to <code class="docutils literal notranslate"><span class="pre">Data</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="o">.</span><span class="kt">Class</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="n">toData</span> <span class="p">(</span><span class="mi">42</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">I</span> <span class="mi">42</span>
</pre></div>
</div>
<p>We see that this has been converted to an instance of type <code class="docutils literal notranslate"><span class="pre">Data</span></code> using the <code class="docutils literal notranslate"><span class="pre">I</span></code> constructor, which we did manually before we used typed
validation.</p>
<p>Now let’s do it the other way around</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="o">.</span><span class="kt">Class</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="n">fromData</span> <span class="p">(</span><span class="kt">I</span> <span class="mi">42</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="kt">Just</span> <span class="mi">42</span>
</pre></div>
</div>
<p>We get a <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">42</span></code> back - <code class="docutils literal notranslate"><span class="pre">Just</span></code> being the <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> constructor when <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> is not <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>And when it fails, when it can’t convert to the target type, we will get back <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="o">.</span><span class="kt">Class</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="n">fromData</span> <span class="p">(</span><span class="kt">List</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>If we examine <code class="docutils literal notranslate"><span class="pre">IsData</span></code> we can see all the types that this pattern will work for all the types that have an <code class="docutils literal notranslate"><span class="pre">IsData</span></code> instance defined.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">PlutusTx</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="o">.</span><span class="kt">Class</span> <span class="kt">Week02</span><span class="o">.</span><span class="kt">Typed</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">IsData</span>
<span class="kr">type</span> <span class="kt">IsData</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">IsData</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">toData</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Data</span>
  <span class="n">fromData</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
  <span class="cm">{-# MINIMAL toData, fromData #-}</span>
        <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
  <span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
  <span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="kt">Bool</span>
  <span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">c</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=&gt;</span>
         <span class="kt">IsData</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
  <span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">IsData</span> <span class="n">a</span><span class="p">,</span> <span class="kt">IsData</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="nb">()</span>
  <span class="c1">-- Defined in ‘plutus-tx-0.1.0.0:PlutusTx.IsData.Instances’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="kt">Integer</span> <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">TypeError</span> <span class="o">...</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">IsData</span> <span class="kt">Int</span>
  <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
<span class="kr">instance</span> <span class="kt">IsData</span> <span class="kt">Data</span> <span class="c1">-- Defined in ‘PlutusTx.IsData.Class’</span>
</pre></div>
</div>
<p>This is still quite a short list of possible types. We would like to use many more types than this for our datum and redeemer.</p>
<p>In order to do this, we would normally need to define an <code class="docutils literal notranslate"><span class="pre">IsData</span></code> instance for any type that we wish to use. This will allow us to tell the
compiler how to do the back and forth conversions. However, this again would be tedious as it is such a mechanical process. So, there
is a mechanism in Plutus that does this for us.</p>
</div>
<div class="section" id="example-5-custom-isdata-types">
<h4><span class="section-number">1.2.4.5. </span>Example 5 - Custom IsData types<a class="headerlink" href="#example-5-custom-isdata-types" title="Permalink to this headline">¶</a></h4>
<p>Now let’s talk about custom data types. Let’s define a silly one and use it in our validator function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">MySillyRedeemer</span> <span class="ow">=</span> <span class="kt">MySillyRedeemer</span> <span class="kt">Integer</span>

<span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;MySillyRedeemer</span>

<span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">MySillyRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="nb">()</span> <span class="p">(</span><span class="kt">MySillyRedeemer</span> <span class="n">r</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;wrong redeemer&quot;</span> <span class="o">$</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is also a stable version of the <code class="docutils literal notranslate"><span class="pre">PlutusTx.unstableMakeIsData</span></code> function, and the stable version should always be used in production code. The difference between the two is
that, in the case where more than one <code class="docutils literal notranslate"><span class="pre">Data</span></code> constructor is required, the unstable version makes no guarantee, between Plutus versions, that the
order of constructors will be preserved.</p>
</div>
<p>And we need to change some of the boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Typed</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ValidatorTypes</span> <span class="kt">Typed</span> <span class="kr">where</span>
<span class="o">...</span>
   <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Typed</span> <span class="ow">=</span> <span class="kt">MySillyRedeemer</span>

<span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Typed</span>
<span class="o">...</span>
<span class="kr">where</span>
   <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="kt">MySillyRedeemer</span>
</pre></div>
</div>
<p>We also need to change some off-chain code in the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint.</p>
<p>Instead of using <code class="docutils literal notranslate"><span class="pre">I</span> <span class="pre">r</span></code>, we will use <code class="docutils literal notranslate"><span class="pre">toData</span> <span class="pre">(MySillyRedeemer</span> <span class="pre">r)</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="n">scrAddress</span>
    <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>      <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">validator</span>
        <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
        <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="p">(</span><span class="kt">MySillyRedeemer</span> <span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
</pre></div>
</div>
<p>If we try to compile the code now, either on the command line or in the playground, we will get an error because Plutus doesn’t know how to
convert back and forth between <code class="docutils literal notranslate"><span class="pre">IsData</span></code> and <code class="docutils literal notranslate"><span class="pre">MySillyRedeemer</span></code>.</p>
<p>We could write an instance of <code class="docutils literal notranslate"><span class="pre">IsData</span></code> for <code class="docutils literal notranslate"><span class="pre">MySillyRedeemer</span></code> by hand. But, we don’t need to.</p>
<p>Instead we can use another bit of Template Haskell magic.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;MySillyRedeemer</span>
</pre></div>
</div>
<p>At compile time, the compiler will use the Template Haskell to write an <code class="docutils literal notranslate"><span class="pre">IsData</span></code> instance for us. And now, it will compile.</p>
<p>Let’s check it in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude PlutusTx PlutusTx.IsData.Class&gt; :l src/Week02/IsData.hs
Ok, one module loaded.
Prelude PlutusTx PlutusTx.IsData.Class Week02.IsData&gt; toData (MySillyRedeemer 42)
Constr 0 [I 42]
</pre></div>
</div>
<p>If you try this code, which is in <code class="docutils literal notranslate"><span class="pre">IsData.hs</span></code>, in the playground, you should see that it behaves in the same way as before.</p>
</div>
</div>
<div class="section" id="summary">
<h3><span class="section-number">1.2.5. </span>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>We have seen a couple of examples of simple validators.</p>
<p>We started with a validator that will always succeed, completely ignoring its arguments. Then we looked at a validator that always fails, again completely ignoring
its arguments. Then we looked at one that examines its redeemer to check for a certain predefined value.</p>
<p>We then turned this validator into a typed version which is the one which would be used in practice. First we used built-in data types and then we saw how we can use
custom data types.</p>
<p>We have not yet looked at examples where the datum or the context are inspected, which would be required for more realistic examples.</p>
<p>We will look at that in the next lecture.</p>
</div>
</div>
<div class="section" id="week-03-script-context">
<h2><span class="section-number">1.3. </span>Week 03 - Script Context<a class="headerlink" href="#week-03-script-context" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=6_rfCCY9_gY">Lecture
#3, Iteration #2</a>.</p>
<p>In this lecture we learn about the script context (the third validation
argument), handling time, and parameterized contracts.</p>
<p>The code in this lecture uses Plutus commit <code class="docutils literal notranslate"><span class="pre">81ba78edb1d634a13371397d8c8b19829345ce0d</span></code>.</p>
</div>
<div class="section" id="id1">
<h3><span class="section-number">1.3.1. </span>Before We Start<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Since the last lecture there has been an update to the playground, which is present in the Plutus commit we are using for this lecture (see note above).</p>
<p>There was an issue whereby the timeout, which was hardcoded into the playground was too short. This would cause simulations to fail if they took longer than the
hardcoded timeout.</p>
<p>There is now an option when you start the Plutus Playground Server which allows you to specify the timeout. The following example sets the timeout to 120 seconds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plutus</span><span class="o">-</span><span class="n">playground</span><span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="n">i</span> <span class="mi">120</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="section" id="recap">
<h3><span class="section-number">1.3.2. </span>Recap<a class="headerlink" href="#recap" title="Permalink to this headline">¶</a></h3>
<p>When we explained the (E)UTxO model in the first lecture, we mentioned that in
order to unlock a script address, the script attached to the address is
run, and that script gets three pieces of information - the <em>datum</em>, the
<em>redeemer</em> and the <em>context</em>.</p>
<p>In the second lecture, we saw examples of that, and we saw how it
actually works in Haskell.</p>
<p>We saw the low-level implementation, where all three arguments are
represented by the <code class="docutils literal notranslate"><span class="pre">Data</span></code> type. We also saw that in practice this is not
used.</p>
<p>Instead, we use the typed version, where the datum and redeemer can be
custom types (as long as they implement the <code class="docutils literal notranslate"><span class="pre">IsData</span></code> type class), and
where the third argument is of type <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code>.</p>
<p>In the examples we have seen so far we have looked at the datum and
the redeemer, but we have always ignored the context. But the
context is, of course, very important. So, in this lecture we will
start looking at the context.</p>
</div>
<div class="section" id="scriptcontext">
<h3><span class="section-number">1.3.3. </span>ScriptContext<a class="headerlink" href="#scriptcontext" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ScriptContext</span></code> type is defined in package <code class="docutils literal notranslate"><span class="pre">plutus-ledger-api</span></code>,
which is a package that, until now, we haven’t needed. But now we do
need it, and it is included in this week’s <code class="docutils literal notranslate"><span class="pre">.cabal</span></code> file. It is
defined in module <code class="docutils literal notranslate"><span class="pre">Plutus.V1.Ledger.Contexts</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span> <span class="p">{</span>
            <span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span>
            <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span>
      <span class="p">}</span>
</pre></div>
</div>
<p>It is a record type with two fields.</p>
<p>The second field is of type <code class="docutils literal notranslate"><span class="pre">ScriptPurpose</span></code>, which is defined in the same module. It defines for which purpose a script is being run.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptPurpose</span>
   <span class="ow">=</span> <span class="kt">Minting</span> <span class="kt">CurrencySymbol</span>
   <span class="o">|</span> <span class="kt">Spending</span> <span class="kt">TxOutRef</span>
   <span class="o">|</span> <span class="kt">Rewarding</span> <span class="kt">StakingCredential</span>
   <span class="o">|</span> <span class="kt">Certifying</span> <span class="kt">DCert</span>
</pre></div>
</div>
<p>For us, the most important is <code class="docutils literal notranslate"><span class="pre">Spending</span></code>. This is what we have talked
about so far in the context of the (E)UTxO model. This is when a script
is run in order to validate a spending input for a transaction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Minting</span></code> purpose comes into play when you want to define a native
token. Its purpose us to describe under which circumstances the native
token can be minted or burned.</p>
<p>There are also two new brand new purposes - <code class="docutils literal notranslate"><span class="pre">Rewarding</span></code> - related to
staking and <code class="docutils literal notranslate"><span class="pre">Certifying</span></code> - related to stake delegation.</p>
<p>The most interesting field, the one that contains the actual context, is <code class="docutils literal notranslate"><span class="pre">scriptContextTxInfo</span></code>, which is of type
<code class="docutils literal notranslate"><span class="pre">TxInfo</span></code>, also defined in the same module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TxInfo</span> <span class="ow">=</span> <span class="kt">TxInfo</span>
   <span class="p">{</span> <span class="n">txInfoInputs</span>      <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span> <span class="c1">-- ^ Transaction inputs</span>
   <span class="p">,</span> <span class="n">txInfoOutputs</span>     <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">]</span> <span class="c1">-- ^ Transaction outputs</span>
   <span class="p">,</span> <span class="n">txInfoFee</span>         <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The fee paid by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoForge</span>       <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The &#39;Value&#39; forged by this transaction.</span>
   <span class="p">,</span> <span class="n">txInfoDCert</span>       <span class="ow">::</span> <span class="p">[</span><span class="kt">DCert</span><span class="p">]</span> <span class="c1">-- ^ Digests of certificates included in this transaction</span>
   <span class="p">,</span> <span class="n">txInfoWdrl</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">StakingCredential</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span> <span class="c1">-- ^ Withdrawals</span>
   <span class="p">,</span> <span class="n">txInfoValidRange</span>  <span class="ow">::</span> <span class="kt">SlotRange</span> <span class="c1">-- ^ The valid range for the transaction.</span>
   <span class="p">,</span> <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">]</span> <span class="c1">-- ^ Signatures provided with the transaction, attested that they all signed the tx</span>
   <span class="p">,</span> <span class="n">txInfoData</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)]</span>
   <span class="p">,</span> <span class="n">txInfoId</span>          <span class="ow">::</span> <span class="kt">TxId</span>
   <span class="c1">-- ^ Hash of the pending transaction (excluding witnesses)</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
</pre></div>
</div>
<p>It describes the spending transaction. In the (E)UTxO model, the context of validation is the spending transaction and its
inputs and outputs. This context is expressed in the <code class="docutils literal notranslate"><span class="pre">TxInfo</span></code> type.</p>
<p>There are a couple of fields that are global to the whole transaction and in particular we have the list of all the inputs <code class="docutils literal notranslate"><span class="pre">txInfoInputs</span></code>
and the list of all the outputs <code class="docutils literal notranslate"><span class="pre">txInfoOutputs</span></code>. Each of those has a variety of fields to drill into each individual input or output.</p>
<p>We also see fields for fees <code class="docutils literal notranslate"><span class="pre">txFee</span></code>, the forge value <code class="docutils literal notranslate"><span class="pre">txInfoForge</span></code>, used when minting or burning native tokens.</p>
<p>Then we have a list of delegation certificates in <code class="docutils literal notranslate"><span class="pre">txInfoDCert</span></code> and a field <code class="docutils literal notranslate"><span class="pre">txInfoWdrl</span></code> to hold information about staking withdrawals.</p>
<p>The field <code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code>, which we will look at in much more detail in a moment, defines the slot range for which this transaction is valid.</p>
<p><code class="docutils literal notranslate"><span class="pre">txInfoSignatories</span></code> is the list of public keys that have signed this transaction.</p>
<p>Transactions that spend a script output need to include the datum of the script output.
The <code class="docutils literal notranslate"><span class="pre">txInfoData</span></code> field is a list associating datums with their respective hashes. If there is a transaction output to a script address
that carries some datum, you don’t need to include the datum, you can just include the datum hash. However, scripts that spend an output do need to include the datum, in which case it will be included in the <code class="docutils literal notranslate"><span class="pre">txInfoData</span></code> list.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">txInfoId</span></code> field is the ID of this transaction.</p>
<div class="section" id="txinfovalidrange">
<h4><span class="section-number">1.3.3.1. </span>txInfoValidRange<a class="headerlink" href="#txinfovalidrange" title="Permalink to this headline">¶</a></h4>
<p>While there is a lot of information contained in this <code class="docutils literal notranslate"><span class="pre">txInfo</span></code> type, for
our first example of how to use the third argument to validation, we
will concentrate on the <code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code> field.</p>
<p>This brings us to an interesting dilemma. We have stressed several times
that the big advantage that Cardano has over something like Ethereum is
that validation can happen in the wallet. But we have also noted that a
transaction can still fail on-chain following validation if, when the
transaction arrives on the blockchain, it has been consumed already by
someone else. In this case, the transaction fails without having to pay
fees.</p>
<p>What should never happen under normal circumstances is that a validation
script runs and then fails. This is because you can always run the
validation under exactly the same conditions in the wallet, so it would
fail before you ever submit it.</p>
<p>So that is a very nice feature, but it is not obvious how to manage time
in that context. Time is important, because we want to be able to
express that a certain transaction is only valid before or only valid
after a certain time has been reached.</p>
<p>We saw an example of this in lecture one - the auction example, where
bids are only allowed until the deadline has been reached, and the
<code class="docutils literal notranslate"><span class="pre">close</span></code> endpoint can only be called after the deadline has passed.</p>
<p>That seems to be a contradiction, because time is obviously flowing. So,
when you try to validate a transaction that you are constructing in your
wallet, the time that you are doing that can, of course, be different
than the time that the transaction arrives at a node for validation. So,
it’s not clear how to bring these two together so that validation is
deterministic, and to guarantee that if, and only if, validation
succeeds in the wallet, it will also succeed in the node.</p>
<p>The way Cardano solves that, is by adding the slot range field
<code class="docutils literal notranslate"><span class="pre">txInfoValidRange</span></code> to a transaction, which essentially says “This
transaction is valid between <em>this</em> and <em>that</em> slot”.</p>
<p>When a transaction gets submitted to the blockchain and validated by a
node, then before any scripts are run, some general checks are made, for
example that all inputs are present and that the balances add up, that
the fees are included and so on.</p>
<p>One of those checks that happens before validation is to check that the slot range is valid. The
node will look at the current time and check that it falls into the valid slot range of the transaction. If it does not, then validation fails immediately without
ever running the validator scripts.</p>
<p>So, if the pre-checks succeed, then this means that the current time does fall into the valid slot range.
This, in turn, means that we are completely deterministic again. The validation script can simply assume that it is being run at a valid slot.</p>
<p>By default, a script will use the infinite slot range, one that covers all slots starting from the genesis block and running until the end of time.</p>
<p>There is one slight complication with this, and that is that Ouroboros, the consensus protocol powering Cardano doesn’t use POSIX time, it uses slots. But Plutus
uses real time, so we need to be able to convert back and forth between real time and slots. This is no problem so long as the slot time is fixed. Right now it is
one second, so right now it is easy.</p>
<p>However, this could change in the future. There could be a hard fork with some parameter change that would change the slot time. We can’t know that in advance.
We don’t know what the slot length will be in ten years, for example.</p>
<p>That means that slot intervals that are defined for transactions mustn’t have a definite upper bound that is too far in the future. It must only be as far in the
future as it is possible to know what the slot length will be. This happens to be something like 36 hours. We know that if there is going to be a hard fork, we would
know about it at least 36 hours in advance.</p>
</div>
<div class="section" id="posixtimerange">
<h4><span class="section-number">1.3.3.2. </span>POSIXTimeRange<a class="headerlink" href="#posixtimerange" title="Permalink to this headline">¶</a></h4>
<p>Let’s look at this <code class="docutils literal notranslate"><span class="pre">POSIXTimeRange</span></code> type, which is defined in <code class="docutils literal notranslate"><span class="pre">Plutus.V1.Ledger.Time</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">POSIXTimeRange</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="kt">POSIXTime</span><span class="o">.</span>
</pre></div>
</div>
<p>It is a type synonym for <code class="docutils literal notranslate"><span class="pre">Interval</span> <span class="pre">POSIXTime</span></code> and we see that <code class="docutils literal notranslate"><span class="pre">Interval</span></code> is defined by a <code class="docutils literal notranslate"><span class="pre">LowerBound</span></code> and an <code class="docutils literal notranslate"><span class="pre">UpperBound</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Interval</span>
      <span class="n">ivFrom</span> <span class="ow">::</span> <span class="kt">LowerBound</span> <span class="n">a</span>
      <span class="n">inTo</span>   <span class="ow">::</span> <span class="kt">UpperBound</span> <span class="n">a</span>
</pre></div>
</div>
<p>If we drill into <code class="docutils literal notranslate"><span class="pre">LowerBound</span></code> we see the constructor</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">LowerBound</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Extended</span> <span class="n">a</span><span class="p">)</span> <span class="kt">Closure</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Closure</span></code> is a synonym for <code class="docutils literal notranslate"><span class="pre">Bool</span></code> and specifies whether a bound is included in the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> or not.</p>
<p><code class="docutils literal notranslate"><span class="pre">Extended</span></code> can be <code class="docutils literal notranslate"><span class="pre">NegInf</span></code> for negative infinity, <code class="docutils literal notranslate"><span class="pre">PosInf</span></code> for positive infinity, or <code class="docutils literal notranslate"><span class="pre">Finite</span> <span class="pre">a</span></code>.</p>
<p>We also find some helper functions including the <code class="docutils literal notranslate"><span class="pre">member</span></code> function which checks if a given <code class="docutils literal notranslate"><span class="pre">a</span></code> is part of a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code>, so long as the type of <code class="docutils literal notranslate"><span class="pre">a</span></code> is a subtype
of <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, which is the case for <code class="docutils literal notranslate"><span class="pre">POSIXTime</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">member</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">member</span> <span class="n">a</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">i</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">singleton</span> <span class="n">a</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">interval</span></code> is a smart constructor for the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> type which creates an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> with an inclusive upper and lower bound.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">interval</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">interval</span> <span class="n">s</span> <span class="n">s&#39;</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we have <code class="docutils literal notranslate"><span class="pre">from</span></code> which constructs an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which starts at <code class="docutils literal notranslate"><span class="pre">a</span></code> and lasts until eternity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">from</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">from</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">lowerBound</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have <code class="docutils literal notranslate"><span class="pre">to</span></code>, which is the opposite. It constructs an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> starting from the genesis block up to, and including <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">to</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">to</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="n">upperBound</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">always</span></code> is the default <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which includes all times.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">always</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">always</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And we have the opposite, <code class="docutils literal notranslate"><span class="pre">never</span></code>, which contains no slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">never</span> <span class="ow">::</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">never</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="kt">LowerBound</span> <span class="kt">PosInf</span> <span class="kt">True</span><span class="p">)</span> <span class="p">(</span><span class="kt">UpperBound</span> <span class="kt">NegInf</span> <span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>There is also the <code class="docutils literal notranslate"><span class="pre">singleton</span></code> helper, which constructs an interval which consists of just one slot.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">singleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">singleton</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">interval</span> <span class="n">s</span> <span class="n">s</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">hull</span></code> gives the smallest interval containing both the given intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hull</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">hull</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">min</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">max</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">intersection</span></code> function determines the largest interval that is contained in both the given intervals. This is an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that starts
from the largest lower bound of the two intervals and extends until the smallest upper bound.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">intersection</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span>
<span class="nf">intersection</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Interval</span> <span class="p">(</span><span class="n">max</span> <span class="n">l1</span> <span class="n">l2</span><span class="p">)</span> <span class="p">(</span><span class="n">min</span> <span class="n">h1</span> <span class="n">h2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">overlaps</span></code> function checks whether two intervals overlap, that is, whether there is a value that is a member of both intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">overlaps</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">overlaps</span> <span class="n">l</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">isEmpty</span> <span class="p">(</span><span class="n">l</span> <span class="p">`</span><span class="n">intersection</span><span class="p">`</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">contains</span></code> takes two intervals and determines if the second interval is completely contained within the first one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">contains</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">contains</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l1</span> <span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">l2</span> <span class="n">h2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">l1</span> <span class="o">&lt;=</span> <span class="n">l2</span> <span class="o">&amp;&amp;</span> <span class="n">h2</span> <span class="o">&lt;=</span> <span class="n">h1</span>
</pre></div>
</div>
<p>And we have the <code class="docutils literal notranslate"><span class="pre">before</span></code> and <code class="docutils literal notranslate"><span class="pre">after</span></code> functions to determine, if a given time is, respectively, before or after everything in a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">before</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">before</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="n">f</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lowerBound</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">f</span>

<span class="nf">after</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Interval</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">after</span> <span class="n">h</span> <span class="p">(</span><span class="kt">Interval</span> <span class="kr">_</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">upperBound</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">t</span>
</pre></div>
</div>
<p>Let’s have a play in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Interval</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Let’s construct the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> between 10 and 20, inclusive.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">10</span><span class="p">)</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">20</span><span class="p">)</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>We can check whether a value is a member of an interval:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">9</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">12</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">20</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">21</span> <span class="o">$</span> <span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>We can use the <code class="docutils literal notranslate"><span class="pre">from</span></code> constructor. Here the lower bound is again a finite slot, but the upper bound is positive infinity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">21</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">30</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">300000</span> <span class="o">$</span> <span class="n">from</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>And the <code class="docutils literal notranslate"><span class="pre">to</span></code> constructor. Here the lower bound is negative infinity, while the upper bound is a finite slot number.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">300000</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">31</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">False</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">30</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">member</span> <span class="mi">7</span> <span class="o">$</span> <span class="n">to</span> <span class="p">(</span><span class="mi">30</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>Now, let’s try the <code class="docutils literal notranslate"><span class="pre">intersection</span></code> function on the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> from 10 to 20 and the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> from 18 to 30.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">intersection</span> <span class="p">(</span><span class="n">interval</span> <span class="p">(</span><span class="mi">10</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">)</span> <span class="mi">20</span><span class="p">)</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">18</span> <span class="mi">30</span>
<span class="kt">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="ow">=</span> <span class="kt">LowerBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">18</span><span class="p">)</span> <span class="kt">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="ow">=</span> <span class="kt">UpperBound</span> <span class="p">(</span><span class="kt">Finite</span> <span class="mi">20</span><span class="p">)</span> <span class="kt">True</span><span class="p">}</span>
</pre></div>
</div>
<p>As expected, we get the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that runs from 18 to 20, inclusive.</p>
<p>We can check whether one <code class="docutils literal notranslate"><span class="pre">Interval</span></code> contains another.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">80</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">100</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">contains</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">101</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>We see that as soon as the second <code class="docutils literal notranslate"><span class="pre">Interval</span></code> extends to 101, it is no longer fully contained within the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that runs to 100.</p>
<p>However, if we check with <code class="docutils literal notranslate"><span class="pre">overlaps</span></code>, then it will be true because there are elements, such as 40, that are contained in both intervals.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">30</span> <span class="mi">101</span>
<span class="kt">True</span>

<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Interval</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Homework1</span><span class="o">&gt;</span> <span class="n">overlaps</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="mi">100</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">))</span> <span class="o">$</span> <span class="n">interval</span> <span class="mi">101</span> <span class="mi">110</span>
<span class="kt">False</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-vesting">
<h3><span class="section-number">1.3.4. </span>Example - Vesting<a class="headerlink" href="#example-vesting" title="Permalink to this headline">¶</a></h3>
<p>Imagine you want to give a gift of Ada to a child. You want the child to own the Ada, but you only want the child to have access to it he or she
turns eighteen.</p>
<p>Using Plutus, it is very easy to implement. As our first contract that will look at the context argument, we will
implement a contract that implements a vesting scheme. Money will be put into a script and then it can be retrieved by a certain person, but only once
a certain deadline has been reached.</p>
<p>We start by copying the <code class="docutils literal notranslate"><span class="pre">IsData</span></code> contract from lecture two into a new module called <code class="docutils literal notranslate"><span class="pre">Vesting</span></code>.</p>
<p>The first step is to think about the types for the datum and redeemer.</p>
<p>For datum, it makes sense to have two pieces of information, the beneficiary and the deadline. So, let’s define this type:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingDatum</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
   <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">POSIXTime</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;VestingDatum</span>
</pre></div>
</div>
<p>In order to know if someone can spend this script output, two pieces information are required, i.e. the beneficiary’s signature and the time of the transaction. In
this case, both those pieces of information are contained in the transaction itself. This means that we don’t need any information in the redeemer, so we can just
use <code class="docutils literal notranslate"><span class="pre">()</span></code> for the redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingDatum</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>We need to check two conditions.</p>
<ol class="arabic simple">
<li><p>That only the correct beneficiary can unlock a UTxO sitting at this
address. This we can validate by checking that the beneficiary’s
signature is included in the transaction.</p></li>
<li><p>That this transaction is only executed after the deadline is reached.</p></li>
</ol>
<p>We could probably just write this in one go, but we will write it in a
more top-down fashion and delegate to some helper functions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
      <span class="n">mkValidator</span> <span class="n">dat</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">signedByBeneficiary</span> <span class="o">&amp;&amp;</span>
                               <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span> <span class="n">deadlineReached</span>
<span class="kr">where</span>
      <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
      <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>
</pre></div>
</div>
<p>To check that the transaction is signed by the beneficiary, we can get the public key of the beneficiary from the datum and pass it, along with the transaction
information to the <code class="docutils literal notranslate"><span class="pre">txSignedBy</span></code> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">signedByBeneficiary</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">signedByBeneficiary</span> <span class="ow">=</span> <span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">beneficiary</span> <span class="n">dat</span>
</pre></div>
</div>
<p>How do we check that the deadline has passed?</p>
<div class="figure align-default">
<img alt="_images/pic__00046.png" src="_images/pic__00046.png" />
</div>
<p>Let’s consider a transaction with a validity that crosses the deadline, which is shown as the uppermost range in the above diagram.</p>
<p>Recall that before the validator script is run, other checks are made, including the time check. The node checks that the current time falls into the valid range of
the transaction and only then is the validator run. So we know that, if we are in the validator, the current time lies somewhere within the validity interval.</p>
<p>In the case of the range that crosses the deadline, the validator code cannot know whether the current time is before or after the deadline. In this case, the
validator must declare that the transaction is invalid.</p>
<p>The second example in the diagram, however, is fine. We still don’t know what the current time is exactly, but we know that whatever the time is, it will be after the
deadline.</p>
<p>So, what we are checking for is that the whole validity interval is to the right of the deadline. One way to do this is to use the <code class="docutils literal notranslate"><span class="pre">contains</span></code> function to check
whether the validity interval is fully contained within the interval that starts from the deadline and extends until the end of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">deadlineReached</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">deadlineReached</span> <span class="ow">=</span> <span class="n">contains</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="n">deadline</span> <span class="n">dat</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>That completes the validation logic. Let’s take care of some boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ValidatorTypes</span> <span class="kt">Vesting</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Vesting</span>
<span class="nf">typedValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Vesting</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">VestingDatum</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>We will focus more on the wallet part of the script later, but here are the changes.</p>
<p>In addition to some new <code class="docutils literal notranslate"><span class="pre">LANGUAGE</span></code> pragmas and some extra imports, we have created a <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code> type, and modified the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint to
require no parameters.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">VestingSchema</span></code> type defines the endpoints that we want to expose to the user. As in our last example, <code class="docutils literal notranslate"><span class="pre">give</span></code> will be used by the user who puts funds into the
contract, then <code class="docutils literal notranslate"><span class="pre">grab</span></code> will be used by the user wanting to claim the funds.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">VestingSchema</span> <span class="ow">=</span>
   <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">GiveParams</span>
   <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="nb">()</span>
</pre></div>
</div>
<p>So what parameters do we need for <code class="docutils literal notranslate"><span class="pre">give</span></code>? The endpoint will create a UTxO at the vesting script address with an amount and a datum. If you recall, our datum
contains the beneficiary and the deadline. So, there are three pieces of information that we must pass to the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GiveParams</span> <span class="ow">=</span> <span class="kt">GiveParams</span>
   <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
   <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">POSIXTime</span>
   <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
   <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint doesn’t require any parameters because the beneficiary will just look for UTxOs sitting at the script address and can then check whether they
are the beneficiary and whether the deadline has passed. If so, they can consume them.</p>
<p>Let’s quickly look at the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">GiveParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">gp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">dat</span> <span class="ow">=</span> <span class="kt">VestingDatum</span>
                <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span>
                <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">gpDeadline</span> <span class="n">gp</span>
                <span class="p">}</span>
        <span class="n">tx</span>  <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="n">dat</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="n">gpAmount</span> <span class="n">gp</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="n">typedValidator</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace to %s with deadline %s&quot;</span>
        <span class="p">(</span><span class="n">gpAmount</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpDeadline</span> <span class="n">gp</span><span class="p">)</span>
</pre></div>
</div>
<p>First we compute the datum we want to use, and we can get both pieces of information from the <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code> which is passed into the function.</p>
<p>Then, for the transaction, we add a constraint that there must be an output at this script address with the datum that we just defined and a certain number of
lovelace, which we also get from the <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code>.</p>
<p>The rest of the function is as before, just with a different log message.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint is a bit more involved.</p>
<p>There can be many UTxOs at this script address and some of them might not be suitable for us, either because we are not the beneficiary, or because the deadline has
not yet passed. If we try to submit a transaction when there are no suitable UTxOs, we will pay fees, but get nothing in return.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="o">.</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">grab</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">now</span>   <span class="ow">&lt;-</span> <span class="n">currentTime</span>
    <span class="n">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="p">(</span><span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="n">scrAddress</span>
    <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="n">utxos</span>
        <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;no gifts available&quot;</span>
        <span class="kr">else</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
                <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>  <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="n">validator</span>
                <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span> <span class="o">&lt;&gt;</span>
                          <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
  <span class="kr">where</span>
    <span class="n">isSuitable</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">POSIXTime</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isSuitable</span> <span class="n">pkh</span> <span class="n">now</span> <span class="n">o</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">txOutDatumHash</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
        <span class="kt">Just</span> <span class="n">h</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">h</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span> <span class="kr">of</span>
            <span class="kt">Nothing</span>        <span class="ow">-&gt;</span> <span class="kt">False</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="kt">Datum</span> <span class="n">e</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">e</span> <span class="kr">of</span>
                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
                <span class="kt">Just</span> <span class="n">d</span>  <span class="ow">-&gt;</span> <span class="n">beneficiary</span> <span class="n">d</span> <span class="o">==</span> <span class="n">pkh</span> <span class="o">&amp;&amp;</span> <span class="n">deadline</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">now</span>
</pre></div>
</div>
<p>First, we get the current time and calculate our public key hash. We then look up all the UTxOs at this address and filter them using the <code class="docutils literal notranslate"><span class="pre">isSuitable</span></code> helper function,
which is defined in the <code class="docutils literal notranslate"><span class="pre">where</span></code> clause.</p>
<p>It first checks the datum hash, and, if it finds it, it attempts to look up the corresponding datum. Recall that the producing transaction, in this case <code class="docutils literal notranslate"><span class="pre">give</span></code> doesn’t
have to supply the datum, it need only supply the datum hash. However, in our case we need to have the datum available to the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint, so the <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint
does provide the datum.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint finds the datum, it must deserialise it to the <code class="docutils literal notranslate"><span class="pre">Vesting</span></code> type.</p>
<p>If all of this succeeds we can check whether we are the beneficiary and whether the deadline has passed.</p>
<p>At this point, <code class="docutils literal notranslate"><span class="pre">utxos</span></code> contains all the UTxOs that we can consume. If we find none, then we just log a message to that effect. If there is at least one, then we
construct one transaction that consumes all of them as inputs and pays the funds to our wallet.</p>
<p>As <code class="docutils literal notranslate"><span class="pre">lookups</span></code>, we provide the list of UTxOs as well as the validator script. Recall that, in order to consume UTxOs at this address, the spending transaction must
provide the validation script.</p>
<p>We then create a transaction that spends all the suitable UTxOs along with a constraint that it must validate in the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> which stretches from now until the end of time.
If we don’t provide the interval here, then validation will fail, because the default interval is from genesis until the end of time. The on-chain validation
would reject this as it needs an interval that is fully contained in the interval stretching from the deadline until the end of time.</p>
<p>We could use the singleton <code class="docutils literal notranslate"><span class="pre">Interval</span></code> <code class="docutils literal notranslate"><span class="pre">now</span></code>, but, if there were any issues, for example network delays, and the transaction arrived at a node a slot or
two later, then validation would no longer work.</p>
<p>The, we just bundle up the endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">VestingSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">give&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">grab&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">give&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">give</span>
    <span class="n">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;</span>  <span class="n">grab</span>
</pre></div>
</div>
<p>Then there is some boilerplate which is just used in the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSchemaDefinitions</span> <span class="kt">&#39;&#39;VestingSchema</span>

<span class="nf">mkKnownCurrencies</span> <span class="kt">[]</span>
</pre></div>
</div>
<div class="section" id="in-the-playground">
<h4><span class="section-number">1.3.4.1. </span>In the playground<a class="headerlink" href="#in-the-playground" title="Permalink to this headline">¶</a></h4>
<p>First, let’s add a third wallet. We are going to create a scenario where Wallet 1 makes two gifts to Wallet 2 with different deadlines and also makes one gift to Wallet 3.</p>
<div class="figure align-default">
<img alt="_images/pic__00043.png" src="_images/pic__00043.png" />
</div>
<p>Normally it would be possible to submit both <code class="docutils literal notranslate"><span class="pre">give</span></code> transactions in the same slot, but the way our code is implemented, we wait for confirmation, which means
we need to add a wait action. This is maybe not the best way to do it, but that’s how it is for the time being.</p>
<div class="figure align-default">
<img alt="_images/pic__00044.png" src="_images/pic__00044.png" />
</div>
<p>Here we run into our first problem. We need to supply the beneficiary address, but there is no way in the playground to get the public key
hash of a wallet.</p>
<p>But we can get it from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude Week03.Homework1&gt; :l src/Week03/Vesting.hs
Ok, one module loaded.
Prelude Week03.Vesting&gt; import Ledger
Prelude Ledger Week03.Vesting&gt; import Wallet.Emulator
Prelude Ledger Wallet.Emulator Week03.Vesting&gt; pubKeyHash $ walletPubKey $ Wallet 2
39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f
Prelude Ledger Wallet.Emulator Week03.Vesting&gt; pubKeyHash $ walletPubKey $ Wallet 3
dac073e0123bdea59dd9b3bda9cf6037f63aca82627d7abcd5c4ac29dd74003e
</pre></div>
</div>
<div class="figure align-default">
<img alt="_images/pic__00047.png" src="_images/pic__00047.png" />
</div>
<p>The next problem is the deadline. In the last lecture we saw how to convert between slots and POSIX times. This has changed. Previously you just needed a slot and out came
a POSIX time. Now there is a second argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger.TimeSlot</span>
<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">slotToBeginPOSIXTime</span>
<span class="nf">slotToBeginPOSIXTime</span> <span class="ow">::</span> <span class="kt">SlotConfig</span> <span class="ow">-&gt;</span> <span class="kt">Slot</span> <span class="ow">-&gt;</span> <span class="kt">POSIXTime</span>
</pre></div>
</div>
<p>There are also versions of <code class="docutils literal notranslate"><span class="pre">slotToBeginPOSIXTime</span></code> that have a begin and an end time. This is because a slot is not just a point in time, it’s a duration in time.</p>
<p>So what is this <code class="docutils literal notranslate"><span class="pre">SlotConfig</span></code>?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">SlotConfig</span>
<span class="kr">type</span> <span class="kt">SlotConfig</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">SlotConfig</span>
  <span class="ow">=</span> <span class="kt">SlotConfig</span> <span class="p">{</span><span class="n">scSlotLength</span> <span class="ow">::</span> <span class="kt">Integer</span><span class="p">,</span> <span class="n">scZeroSlotTime</span> <span class="ow">::</span> <span class="kt">POSIXTime</span><span class="p">}</span>
        <span class="c1">-- Defined in ‘Ledger.TimeSlot’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">SlotConfig</span> <span class="c1">-- Defined in ‘Ledger.TimeSlot’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">SlotConfig</span> <span class="c1">-- Defined in ‘Ledger.TimeSlot’</span>
</pre></div>
</div>
<p>It takes the slot length and the time at which slot zero starts.</p>
<p>So now we have to find out what <code class="docutils literal notranslate"><span class="pre">SlotConfig</span></code> to use for the playground. Luckily, it’s the default. For that we need to use the <code class="docutils literal notranslate"><span class="pre">Data.Default</span></code> module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Default</span>
<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Default</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="n">def</span> <span class="ow">::</span> <span class="kt">SlotConfig</span>
<span class="kt">SlotConfig</span> <span class="p">{</span><span class="n">scSlotLength</span> <span class="ow">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">scZeroSlotTime</span> <span class="ow">=</span> <span class="kt">POSIXTime</span> <span class="p">{</span><span class="n">getPOSIXTime</span> <span class="ow">=</span> <span class="mi">1596059091000</span><span class="p">}}</span>
</pre></div>
</div>
<p>Now we can use <code class="docutils literal notranslate"><span class="pre">slotToBeginPOSIXTime</span></code> with the default config to get the POSIX time for slot 10 and slot 20.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Default</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="n">slotToBeginPOSIXTime</span> <span class="n">def</span> <span class="mi">10</span>
<span class="kt">POSIXTime</span> <span class="p">{</span><span class="n">getPOSIXTime</span> <span class="ow">=</span> <span class="mi">1596059101000</span><span class="p">}</span>

<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">TimeSlot</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Default</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Vesting</span><span class="o">&gt;</span> <span class="n">slotToBeginPOSIXTime</span> <span class="n">def</span> <span class="mi">20</span>
<span class="kt">POSIXTime</span> <span class="p">{</span><span class="n">getPOSIXTime</span> <span class="ow">=</span> <span class="mi">1596059111000</span><span class="p">}</span>
</pre></div>
</div>
<p>And we can use these in the playground. We’ll use slot 10 as the deadline for the first and third <code class="docutils literal notranslate"><span class="pre">give``s</span> <span class="pre">and</span> <span class="pre">slot</span> <span class="pre">20</span> <span class="pre">for</span> <span class="pre">the</span> <span class="pre">second</span> <span class="pre">``give</span></code>. We’ll also give 10 Ada
in each case.</p>
<div class="figure align-default">
<img alt="_images/pic__00048.png" src="_images/pic__00048.png" />
</div>
<p>Let’s create a scenario where everything works. Wallet 3 grabs at slot 10 when the deadline for Wallet 3 has passed, and Wallet 2 grabs at slot 20, when both
the Wallet 2 deadlines have passed. We will use the <code class="docutils literal notranslate"><span class="pre">Wait</span> <span class="pre">Until..</span></code> option for this.</p>
<div class="figure align-default">
<img alt="_images/pic__00049.png" src="_images/pic__00049.png" />
</div>
<p>After evaluation, we first see the Genesis transaction.</p>
<div class="figure align-default">
<img alt="_images/pic__00050.png" src="_images/pic__00050.png" />
</div>
<p>If we look at the next transaction, we see the gift from Wallet 1 to Wallet 2 with the deadline of 10. Here, ten Ada get locked in the script address.</p>
<div class="figure align-default">
<img alt="_images/pic__00051.png" src="_images/pic__00051.png" />
</div>
<p>The next transaction is the gift from Wallet 1 to Wallet 2 with the deadline of 20. A new UTxO is now created at the script address with ten Ada.</p>
<div class="figure align-default">
<img alt="_images/pic__00052.png" src="_images/pic__00052.png" />
</div>
<p>And the third gift, this time to Wallet 3, with a deadline of 10. Wallet 1 now has about 70 Ada, and another UTxO is created with 10 Ada locked at the script address.</p>
<div class="figure align-default">
<img alt="_images/pic__00053.png" src="_images/pic__00053.png" />
</div>
<p>At slot 10, Wallet 3 grabs successfully. The third UTxO is the input, some fees are paid, and then the remainder of the lovelace is sent to Wallet 3.</p>
<div class="figure align-default">
<img alt="_images/pic__00054.png" src="_images/pic__00054.png" />
</div>
<p>Then at slot 20, Wallet 2 successfully grabs both the UTxOs for which they are the beneficiary. This time the fee is higher because two validators have to run.</p>
<div class="figure align-default">
<img alt="_images/pic__00055.png" src="_images/pic__00055.png" />
</div>
<p>The final balances reflect the changes.</p>
<div class="figure align-default">
<img alt="_images/pic__00056.png" src="_images/pic__00056.png" />
</div>
<p>Now let’s look at the case where the grab happens too early. We’ll make Wallet 2 grab at slot 15 instead of slot 20.</p>
<div class="figure align-default">
<img alt="" src="_images/pic__00010.png" />
</div>
<p>Now we see that the first transactions are the same, but that the final transaction at slot 15 has only one input, because the second UTxO is not yet available.</p>
<div class="figure align-default">
<img alt="_images/pic__00057.png" src="_images/pic__00057.png" />
</div>
<p>And we can see that there are 10 Ada still locked at the script address.</p>
<div class="figure align-default">
<img alt="_images/pic__00057.png" src="_images/pic__00057.png" />
</div>
<p>Our off-chain code was written in such a way that it will only submit a transaction if there is a suitable UTxO that can be grabbed. This means that we don’t really
exercise the validator because we are only sending transactions to the blockchain that will pass validation.</p>
<p>If you want to test the validator, you could modify the wallet code so that the grab endpoint attempts to grab everything and then validation will fail if you are not
the beneficiary or the deadline has not been reached.</p>
<p>You need to keep in mind that anybody can write off-chain code. So, even though it works now as long as you use the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint that we wrote ourselves, somebody
could write a different piece of off-chain code that doesn’t filter the UTxOs as we did. In this case, if the validator is not correct something could be horribly wrong.</p>
</div>
</div>
<div class="section" id="example-2-parameterized-contract">
<h3><span class="section-number">1.3.5. </span>Example 2 - Parameterized Contract<a class="headerlink" href="#example-2-parameterized-contract" title="Permalink to this headline">¶</a></h3>
<p>We’ll start the next example by copying the code from the vesting example into a new module called <code class="docutils literal notranslate"><span class="pre">Week03.Parameterized</span></code>.</p>
<div class="section" id="id2">
<h4><span class="section-number">1.3.5.1. </span>On-Chain<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Note that in the vesting example we used the <code class="docutils literal notranslate"><span class="pre">Vesting</span></code> type as the datum, but it was just fixed, it didn’t change. Alternatively, we could have baked it into the contract, so to speak,
so that we have a contract where the script itself already contains the beneficiary and deadline information.</p>
<p>All the examples of contracts we have seen so far were fixed. We used a <code class="docutils literal notranslate"><span class="pre">TypedValidator</span></code> as a compile-time constant. The idea of parameterized scripts is that you can
have a parameter and, depending on the value of the parameter, you get different values of <code class="docutils literal notranslate"><span class="pre">TypedValidator</span></code>.</p>
<p>So, instead of defining one script, with a single script address, with all UTxOs sitting at the same address, you can define a family of
scripts that are parameterized by a given parameter. In our case, this will mean that UTxOs for different beneficiaries and/or deadlines will be a different script addresses, as
they will have parameterized validators specific to their parameters rather than specific to the datum of the UTxO.</p>
<p>We are going to demonstrate how to do this by, instead of using datum for the beneficiary and deadline values, using a parameter.</p>
<p>Let’s start by renaming <code class="docutils literal notranslate"><span class="pre">VestingDatum</span></code> to something more suitable.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">VestingParam</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
      <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span>
      <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">::</span> <span class="kt">POSIXTime</span>
      <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>We will also remove the <code class="docutils literal notranslate"><span class="pre">unstableMakeIsData</span></code> call as we don’t need this anymore.</p>
<p>The reason we don’t need it, is because we are just going to use <code class="docutils literal notranslate"><span class="pre">()</span></code> for the datum in the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function. All the information we require will be in a new argument
to <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code>, of type <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>, which we add at the beginning of the list of arguments.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkValidator</span> <span class="n">p</span> <span class="nb">()</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;beneficiary&#39;s signature missing&quot;</span> <span class="n">signedByBeneficiary</span> <span class="o">&amp;&amp;</span>
                          <span class="n">traceIfFalse</span> <span class="s">&quot;deadline not reached&quot;</span> <span class="n">deadlineReached</span>
  <span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">signedByBeneficiary</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">signedByBeneficiary</span> <span class="ow">=</span> <span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">beneficiary</span> <span class="n">p</span>

    <span class="n">deadlineReached</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">deadlineReached</span> <span class="ow">=</span> <span class="n">contains</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="n">deadline</span> <span class="n">p</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoValidRange</span> <span class="n">info</span>
</pre></div>
</div>
<p>We also change the <code class="docutils literal notranslate"><span class="pre">Vesting</span></code> type to reflect the change to the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vesting</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ValidatorTypes</span> <span class="kt">Vesting</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Vesting</span> <span class="ow">=</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Now, the <code class="docutils literal notranslate"><span class="pre">TypedValidator</span></code> will no longer be a constant value. Instead it will take a parameter.</p>
<p>Recall that the function <code class="docutils literal notranslate"><span class="pre">mkTypedValidator</span></code> requires as its first argument the compiled code of a function that takes three arguments and returns a <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. But now, it has four arguments,
so we need to account for that.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Vesting</span>
<span class="nf">typedValidator</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Vesting</span>
</pre></div>
</div>
<p>Now, what we would like to do is something like this, passing in the new parameter <code class="docutils literal notranslate"><span class="pre">p</span></code> to <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> so that the compiled code within the Oxford brackets would have the correct type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>  <span class="c1">-- this won&#39;t work</span>
  <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="n">p</span> <span class="o">||</span><span class="p">])</span>
  <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
  <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>This code will not work, but before we investigate, let’s leave the code as it is for now and make some more changes to the rest of the code.</p>
<p><code class="docutils literal notranslate"><span class="pre">validator</span></code> now will take a <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code> and will return a composed function. The returned function has the effect that any paramater passed to <code class="docutils literal notranslate"><span class="pre">validator</span></code> would now effectively
get passed to the <code class="docutils literal notranslate"><span class="pre">typedValidator</span></code> function, whose return value would in turned get passed to the <code class="docutils literal notranslate"><span class="pre">validatorScript</span></code> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">validator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">validator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">typedValidator</span>
</pre></div>
</div>
<p>And the same for <code class="docutils literal notranslate"><span class="pre">valHash</span></code> and <code class="docutils literal notranslate"><span class="pre">scrAddress</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">valHash</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">ValidatorHash</span>
<span class="nf">valHash</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorHash</span> <span class="o">.</span> <span class="n">typedValidator</span>

<span class="nf">scrAddress</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">scrAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">validator</span>
</pre></div>
</div>
<p>Now, let’s find out what’s wrong with out <code class="docutils literal notranslate"><span class="pre">typedValidator</span></code> function.</p>
<p>If we try to launch the REPL, we get a compile error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GHC</span> <span class="kt">Core</span> <span class="n">to</span> <span class="kt">PLC</span> <span class="n">plugin</span><span class="kt">:</span> <span class="kt">E043:Error:</span> <span class="kt">Reference</span> <span class="n">to</span> <span class="n">a</span> <span class="n">name</span> <span class="n">which</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">local</span><span class="p">,</span> <span class="n">a</span> <span class="n">builtin</span><span class="p">,</span> <span class="n">or</span> <span class="n">an</span> <span class="n">external</span> <span class="kt">INLINABLE</span> <span class="n">function</span><span class="kt">:</span> <span class="kt">Variable</span> <span class="n">p</span>
<span class="kt">No</span> <span class="n">unfolding</span>
<span class="kt">Context:</span> <span class="kt">Compiling</span> <span class="n">expr</span><span class="kt">:</span> <span class="n">p</span>
<span class="kt">Context:</span> <span class="kt">Compiling</span> <span class="n">expr</span><span class="kt">:</span> <span class="kt">Week03</span><span class="o">.</span><span class="kt">Parameterized</span><span class="o">.</span><span class="n">mkValidator</span> <span class="n">p</span>
<span class="kt">Context:</span> <span class="kt">Compiling</span> <span class="n">expr</span> <span class="n">at</span> <span class="s">&quot;plutus-pioneer-program-week03-0.1.0.0-inplace:Week03.Parameterized:(67,10)-(67,48)&quot;</span>
</pre></div>
</div>
<p>The problem is this line.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- this won&#39;t work</span>
<span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="n">p</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>Recall that everything inside the Oxford brackets must be explicitly known at compile time. Normally it would even need all the code to be written explicitly, but
by using the <code class="docutils literal notranslate"><span class="pre">INLINABLE</span></code> pragma on the <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function we can reference the function instead. However, it must still be known at compile time, because that’s
how Template Haskell works - it is executed before the main compiler.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">p</span></code> is not known at compile time, because we intend to supply it at runtime. Luckily there is a way around this.</p>
<p>On the Haskell side, we have our <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> function and we have <code class="docutils literal notranslate"><span class="pre">p</span></code> of type <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>. We can compile <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code> to Plutus, but we can’t compile <code class="docutils literal notranslate"><span class="pre">p</span></code> to Plutus
because we don’t know what it is. But, if we could get our hands on the compiled version of <code class="docutils literal notranslate"><span class="pre">p</span></code>, we could apply this compiled version to the compiled <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code>, and this
would give us what we want.</p>
<p>This seems to solve nothing, because we still need a compiled version of <code class="docutils literal notranslate"><span class="pre">p</span></code> and we have the same problem that <code class="docutils literal notranslate"><span class="pre">p</span></code> is not known at compile time.</p>
<p>However, <code class="docutils literal notranslate"><span class="pre">p</span></code> is not some arbitrary Haskell code, it’s data, so it doesn’t contain any function types. If we make the type of <code class="docutils literal notranslate"><span class="pre">p</span></code> an instance of a type class called <code class="docutils literal notranslate"><span class="pre">Lift</span></code>.
We can use <code class="docutils literal notranslate"><span class="pre">liftCode</span></code> to compile <code class="docutils literal notranslate"><span class="pre">p</span></code> at runtime to Plutus Core and then, using <code class="docutils literal notranslate"><span class="pre">applyCode</span></code> we can apply the Plutus Core <code class="docutils literal notranslate"><span class="pre">p</span></code> to the Plutus Core <code class="docutils literal notranslate"><span class="pre">mkValidator</span></code>.</p>
<p>Let’s briefly look at the <code class="docutils literal notranslate"><span class="pre">Lift</span></code> class. It is defined in package <code class="docutils literal notranslate"><span class="pre">plutus-tx</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift.Class</span>
</pre></div>
</div>
<p>It only has one function, <code class="docutils literal notranslate"><span class="pre">Lift</span></code>. However, we won’t use this function directly.</p>
<p>The importance of the class is that it allows us to, at runtime, lift Haskell values into corresponding Plutus script values. And this is
exactly what we need to convert our parameter <code class="docutils literal notranslate"><span class="pre">p</span></code> into code.</p>
<p>We will use a different function, defined in the same package but in a different module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">PlutusTx.Lift</span>
</pre></div>
</div>
<p>The function we will use is called <code class="docutils literal notranslate"><span class="pre">liftCode</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Get a Plutus Core program corresponding to the given value as a &#39;CompiledCodeIn&#39;, throwing any errors that occur as exceptions and ignoring fresh names.</span>
<span class="nf">liftCode</span>
   <span class="ow">::</span> <span class="p">(</span><span class="kt">Lift</span><span class="o">.</span><span class="kt">Lift</span> <span class="n">uni</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Throwable</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">PLC</span><span class="o">.</span><span class="kt">ToBuiltinMeaning</span> <span class="n">uni</span> <span class="n">fun</span><span class="p">)</span>
   <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">CompiledCodeIn</span> <span class="n">uni</span> <span class="n">fun</span> <span class="n">a</span>
<span class="nf">liftCode</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">unsafely</span> <span class="o">$</span> <span class="n">safeLiftCode</span> <span class="n">x</span>
</pre></div>
</div>
<p>It takes a Haskell value of type <code class="docutils literal notranslate"><span class="pre">a</span></code>, provided <code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">Lift</span></code> class, and turns it into a piece of Plutus script code corresponding to the same type.</p>
<p>Now we can fix our validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">typedValidator</span> <span class="ow">::</span> <span class="kt">VestingParam</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">TypedValidator</span> <span class="kt">Vesting</span>
<span class="nf">typedValidator</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">mkTypedValidator</span> <span class="o">@</span><span class="kt">Vesting</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">p</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="nb">()</span> <span class="o">@</span><span class="nb">()</span>
</pre></div>
</div>
<p>This code is fine, but it won’t yet compile, because <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code> is not an instance of <code class="docutils literal notranslate"><span class="pre">Lift</span></code>. To fix this, we can use <code class="docutils literal notranslate"><span class="pre">makeLift</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">makeLift</span> <span class="kt">&#39;&#39;VestingParam</span>
</pre></div>
</div>
<p>And, we need to enable a GHC extension.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE MultiParamTypeClasses #-}</span>
</pre></div>
</div>
<p>Now it will compile.</p>
</div>
<div class="section" id="id3">
<h4><span class="section-number">1.3.5.2. </span>Off-Chain<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>The off-chain code hasn’t changed much.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">GiveParams</span></code> are still the same.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GiveParams</span> <span class="ow">=</span> <span class="kt">GiveParams</span>
      <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
      <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">POSIXTime</span>
      <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
      <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">VestingSchema</span></code> has slightly changed because the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint now relies on knowing the beneficiary and deadline in order to know
determine the script address. We know the beneficiary because it will be the public key hash of the wallet that calls <code class="docutils literal notranslate"><span class="pre">grab</span></code>, but we don’t know the deadline, so we must
pass it to <code class="docutils literal notranslate"><span class="pre">grab</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">VestingSchema</span> <span class="ow">=</span>
          <span class="kt">Endpoint</span> <span class="s">&quot;give&quot;</span> <span class="kt">GiveParams</span>
      <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;grab&quot;</span> <span class="kt">POSIXTime</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">give</span></code> endpoint is similar to the vesting example, but there are some differences.</p>
<p>Instead of computing the datum, we will construct something of type <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>. We also change the reference to the datum in <code class="docutils literal notranslate"><span class="pre">mustPayToTheScript</span></code> to become <code class="docutils literal notranslate"><span class="pre">()</span></code>, and
we provide the type <code class="docutils literal notranslate"><span class="pre">p</span></code> to <code class="docutils literal notranslate"><span class="pre">typedValidator</span></code> as it is no longer a constant.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">give</span> <span class="ow">::</span> <span class="kt">AsContractError</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">GiveParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="nb">()</span>
<span class="nf">give</span> <span class="n">gp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">p</span>  <span class="ow">=</span> <span class="kt">VestingParam</span>
                <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span>
                <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">gpDeadline</span> <span class="n">gp</span>
                <span class="p">}</span>
        <span class="n">tx</span> <span class="ow">=</span> <span class="n">mustPayToTheScript</span> <span class="nb">()</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="n">gpAmount</span> <span class="n">gp</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">typedValidator</span> <span class="n">p</span><span class="p">)</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;made a gift of %d lovelace to %s with deadline %s&quot;</span>
        <span class="p">(</span><span class="n">gpAmount</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpBeneficiary</span> <span class="n">gp</span><span class="p">)</span>
        <span class="p">(</span><span class="n">show</span> <span class="o">$</span> <span class="n">gpDeadline</span> <span class="n">gp</span><span class="p">)</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">grab</span></code> endpoint, there are also some changes.</p>
<p>Recall that earlier we got all the UTxOs sitting at this one script address and that they could be for arbitrary beneficiaries and for arbitrary deadlines. For this reason, we
had to filter those UTxOs which were for us and where the deadline had been reached.</p>
<p>We now have the additional parameter, which we’ll call <code class="docutils literal notranslate"><span class="pre">d</span></code>, which represents the deadline. So we can immediately see if the deadline has been reached or not.</p>
<p>If it has not been reached, we write a log message and stop, otherwise we continue and construct the <code class="docutils literal notranslate"><span class="pre">VestingParam</span></code>.</p>
<p>Then, we look up the UTxOs that are sitting at this address. Address is not a constant anymore, it takes a parameter. So, now, we will only get UTxOs which are for us and that
have a deadline that has been reached. We don’t need to filter anything.</p>
<p>If there are none, we log a message to that effect and stop, otherwise we do more or less what we did before.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">grab</span> <span class="n">d</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">now</span>   <span class="ow">&lt;-</span> <span class="n">currentTime</span>
<span class="nf">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
<span class="kr">if</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">d</span>
    <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;too early&quot;</span>
    <span class="kr">else</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">VestingParam</span>
                    <span class="p">{</span> <span class="n">beneficiary</span> <span class="ow">=</span> <span class="n">pkh</span>
                    <span class="p">,</span> <span class="n">deadline</span>    <span class="ow">=</span> <span class="n">d</span>
                    <span class="p">}</span>
                    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">scrAddress</span> <span class="n">p</span>
                    <span class="kr">if</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="n">utxos</span>
                        <span class="kr">then</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;no gifts available&quot;</span>
                        <span class="kr">else</span> <span class="kr">do</span>
                            <span class="kr">let</span> <span class="n">orefs</span>   <span class="ow">=</span> <span class="n">fst</span> <span class="o">&lt;$&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
                                <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>      <span class="o">&lt;&gt;</span>
                                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">validator</span> <span class="n">p</span><span class="p">)</span>
                                <span class="n">tx</span> <span class="ow">::</span> <span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span>
                                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="n">oref</span> <span class="ow">&lt;-</span> <span class="n">orefs</span><span class="p">]</span> <span class="o">&lt;&gt;</span>
                                          <span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="n">now</span><span class="p">)</span>
                            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
                            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
                            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;collected gifts&quot;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">endpoints</span></code> function is slightly different due to the new parameter for <code class="docutils literal notranslate"><span class="pre">grab</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">VestingSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">give&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">grab&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">give&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">give</span>
    <span class="n">grab&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">grab</span>
</pre></div>
</div>
</div>
<div class="section" id="back-to-the-playground">
<h4><span class="section-number">1.3.5.3. </span>Back to the playground<a class="headerlink" href="#back-to-the-playground" title="Permalink to this headline">¶</a></h4>
<p>We will now copy and paste this new contract into the playground and setup a new scenario.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">give</span></code> transactions are the same.</p>
<div class="figure align-default">
<img alt="_images/pic__00059.png" src="_images/pic__00059.png" />
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">grab</span></code> is slightly different. In our earlier implementation, one wallet could grab UTxOs with different deadlines provided that the deadlines had passed. Now the deadline
is part of the script parameter, so we need to specify it in order to get the script address. This means that Wallet 2 cannot grab the gifts for slots 10 and 20 at the same time,
at least not in the way that we have implemented it.</p>
<p>First we can wait until slot 10 and then Wallet 2 should be able to grab its first gift and Wallet 3 should be able to claim its single gift.</p>
<p>We’ll add a <code class="docutils literal notranslate"><span class="pre">grab</span></code> for Wallets 2 and 3. Here, we don’t need to wain in between each transaction because it is two different wallets.</p>
<p>We then wait until slot 20 and perform Wallet 2’s second <code class="docutils literal notranslate"><span class="pre">grab</span></code> and then wait for 1 block, as usual.</p>
<div class="figure align-default">
<img alt="_images/pic__00060.png" src="_images/pic__00060.png" />
</div>
<p>So let’s see if it works by clicking <code class="docutils literal notranslate"><span class="pre">Evaluate</span></code>.</p>
<div class="figure align-default">
<img alt="_images/pic__00061.png" src="_images/pic__00061.png" />
</div>
<p>Take note of the script address for that transaction out at slot 1.</p>
<div class="figure align-default">
<img alt="_images/pic__00062.png" src="_images/pic__00062.png" />
</div>
<p>And compare this with the script address for the transaction output at slot 2.</p>
<div class="figure align-default">
<img alt="_images/pic__00063.png" src="_images/pic__00063.png" />
</div>
<p>Notice that the script address for the UTxOs is different. In our first version of the vesting contract, the script address was a constant. This meant that all our gifts ended up
at the same script address and only the datum in each UTxO was different.</p>
<p>Now, the datum is just <code class="docutils literal notranslate"><span class="pre">()</span></code> and the beneficiary and the deadline are included as part of the script itself, so the addresses are now different depending on the beneficiary and
deadline parameters.</p>
<p>For the gift to Wallet 3 we see yet another address.</p>
<div class="figure align-default">
<img alt="_images/pic__00064.png" src="_images/pic__00064.png" />
</div>
<p>We see two grabs in slot 10, one by Wallets 2 and one by Wallet 3. The order in which they are processed is not deterministic.</p>
<p>Then, finally in slot 20, Wallet 2 grabs its remaining gift.</p>
<p>And the final balances reflect the transactions that have occurred.</p>
<div class="figure align-default">
<img alt="_images/pic__00065.png" src="_images/pic__00065.png" />
</div>
</div>
</div>
</div>
<div class="section" id="week-04-monads">
<h2><span class="section-number">1.4. </span>Week 04 - Monads<a class="headerlink" href="#week-04-monads" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://youtu.be/6Reuh0xZDjY">Lecture
#4</a>.</p>
<p>In this lecture we learn about Monads. In particular the EmulatorTrace
and Contract monads.</p>
</div>
<div class="section" id="id4">
<h3><span class="section-number">1.4.1. </span>Overview<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>We have spent the last two lectures talking about the on-chain part of
Plutus - the validation logic that is compiled to Plutus script and
actually lives on the blockchain and is executed by nodes that validate
a transaction.</p>
<p>There is a lot more to say about that on-chain part.</p>
<p>We haven’t looked at more complex examples of validation yet that make
more sophisticated use of the context, and we haven’t see how native
tokens work, yet (Plutus script is also used to validate the minting and
burning of native tokens).</p>
<p>We will definitely have to talk about those topics, and come back to
that.</p>
<p>However, before we go into too many sophisticated topics of on-chain
validation, we mustn’t neglect the off-chain part, because it is equally
important.</p>
<p>The on-chain part takes care of validation but, in order for there to be
something to be validated, we must build a transaction and submit it to
the blockchain. And, that is what the off-chain part does.</p>
<p>So, we will start talking about how to write off-chain Plutus code.</p>
<p>Unfortunately there is a slight problem concerning the Haskell features
needed.</p>
<p>The on-chain part that we have seen so far is somewhat alien and takes a
little getting used to, due to the fact that we have the additional
complication of the compilation to Plutus script. But, we don’t really
have to worry about that if we use the Template Haskell magic. In that
case the validator function is just a plain function.</p>
<p>And it is actually a very simple Haskell function from the technical
point of view. We don’t use any fancy Haskell features to write this
function.</p>
<p>One of the reasons for that is the way Plutus compilation works. We have
seen how, in order for the compilation to Plutus to succeed, all the
code used by the validation function must be available within the Oxford
Brackets. This means that all the functions relied on by the
<em>mkValidator</em> function must use the INLINABLE pragma.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkValidator #-}</span>
<span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="kt">Data</span> <span class="ow">-&gt;</span> <span class="nb">()</span>
<span class="nf">mkValidator</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkValidator</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>And recall, that because the standard Haskell functions don’t have this
INLINABLE pragma, there is a new Plutus Prelude module that is similar
to the standard Haskell Prelude, but with the functions defined with the
INLINABLE pragma.</p>
<p>But, of course, there are hundreds of Haskell libraries out there and
most of them weren’t written with Plutus in mind, so we can’t use them
inside validation. And, that has the effect that the Haskell inside
validation will be relatively simple and won’t have many dependencies.</p>
</div>
<div class="section" id="monads">
<h3><span class="section-number">1.4.2. </span>Monads<a class="headerlink" href="#monads" title="Permalink to this headline">¶</a></h3>
<p>In the off-chain part of Plutus, the situation is reversed. We don’t
have to worry about compilation to Plutus script - it is just plain
Haskell. But, the flip side is that, the way this is implemented, it
uses much more sophisticated Haskell features - e.g. so-called effect
systems, streaming and, in particular, monads.</p>
<p>All the off-chain code (the wallet code), is written in a special monad
- the Contract Monad.</p>
<p>Monads are infamous in the Haskell world. It is normally the first
stumbling block for beginning Haskell coders.</p>
<p>There are a lot of tutorials out there that try to explain Monads.
Monads get compared to burritos, and all sorts of metaphors are employed
to try to explain the concept. But here, let’s at least try to give a
crash course in monads for those who are new to Haskell.</p>
<p>Before we get to general monads, we will start with <em>IO</em>, which is how
IO side-effects are handled in Haskell. But, before we get to Haskell,
let’s look at a mainstream language like Java.</p>
<p>Let’s look at the following Java method.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
   <span class="o">...</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This function takes no arguments, and it returns an <code class="docutils literal notranslate"><span class="pre">int</span></code>. Let’s imagine it gets called twice in the code.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="o">();</span>
<span class="o">...</span>
<span class="kd">final</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">foo</span><span class="o">();</span>
</pre></div>
</div>
<p>Now, we note that, so long as we don’t know what is going on inside the
foo() function, the return value of the following expression is unknown.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// true or false? at compile time, we don&#39;t know</span>
</pre></div>
</div>
<p>We do not know if <code class="docutils literal notranslate"><span class="pre">a</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">b</span></code> because, in Java, it is
perfectly possible that some IO happens inside <code class="docutils literal notranslate"><span class="pre">foo</span></code>. For example,
there code be code that asks the user to enter input on the console and
uses this to compute the return value.</p>
<p>This means that, in order to reason about the code, we need to look
inside <code class="docutils literal notranslate"><span class="pre">foo</span></code>, which makes testing, for example, more difficult. And it
means that, it the first call to <code class="docutils literal notranslate"><span class="pre">foo</span></code> returns, for example, <code class="docutils literal notranslate"><span class="pre">13</span></code> - we
cannot just replace all other calls to <code class="docutils literal notranslate"><span class="pre">foo</span></code> with the known return
value of <code class="docutils literal notranslate"><span class="pre">13</span></code>.</p>
<p>In Haskell the situation is very different because Haskell is a pure
functional language. The equivalent signature in Haskell would be
something like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Now, if we have a situation where we call <code class="docutils literal notranslate"><span class="pre">foo</span></code> twice, even though we
don’t know what the value of <code class="docutils literal notranslate"><span class="pre">foo</span></code> is, we know for sure that the two
return values will be the same.</p>
<p>This is a very important feature that is called <em>referential
transparency</em>. There are, in fact, some escape hatches to get around
this, but we can ignore this.</p>
<p>This makes tasks such as refactoring and testing much easier.</p>
<p>This is all very well, but you need side-effects in order to have an
effect on the world. Otherwise, all your program does is heat up the
processor.</p>
<p>You need input and output. You must be able to write output to the
screen, or read input from the keyboard, or a network connection, or a
file, for example.</p>
<p>There is a famous <a class="reference external" href="https://www.youtube.com/watch?v=iSmkqocn0oQ">video by Simon Peyton-Jones called Haskell Is
Useless</a> which explains
that it is beautiful mathematically to have a pure, side effect-free
language, but in the end you do need side effects to make anything
happen.</p>
<p>And Haskell does have a way to handle side effects and that is the IO
Monad. But, don’t worry about the monad part just yet.</p>
<p>Here is how we do it in Haskell.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p><em>IO</em> is a type constructor that takes one argument, like some other
examples of type constructors such as <em>Maybe</em> and <em>List</em>. However,
unlike those examples, <em>IO</em> is special, in the sense that you can’t
implement it in the language itself. It is a built-in primitive.</p>
<p>The return value <em>IO Int</em> tells us that this is a recipe to compute an
<em>Int</em>, and this recipe can cause side effects. A list of instructions
telling the computer what to do in order to end up with an <em>Int</em>.</p>
<p>It is important to notice that referential transparency is not broken
here. The result of the evaluation of <em>foo</em> is the recipe itself, not
the <em>Int</em> value. And as the recipe is always the same, referential
transparency is maintained.</p>
<p>The only way to actually execute such a recipe in a Haskell program is
from the main entry point of the program - the <em>main</em> function. You can
also execute <em>IO</em> actions in the REPL.</p>
<div class="section" id="hello-world">
<h4><span class="section-number">1.4.2.1. </span>Hello World<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h4>
<p>Hello World in Haskell looks like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
</pre></div>
</div>
<p>Here, <em>main</em> is a recipe that performs some side effects and returns
Unit - nothing of interest.</p>
<p>Let’s look at <em>putStrLn</em> in the REPL. We see that it is an IO action
that takes a <em>String</em> and returns no interesting result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">putStrLn</span>
<span class="nf">putStrLn</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>

<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="nf">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>We can also run this. Open up the app/Main.sh file and edit the <em>main</em>
function so it reads:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
</pre></div>
</div>
<p>Then run</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cabal run hello
</pre></div>
</div>
<p>We will take a quick look at the cabal file now.</p>
<p>In previous lectures we only needed the <em>library</em> section in the
<em>plutus-pioneer-program-week04.cabal</em> file as we were dealing only with
library functions. Now, we need to add an <em>executable</em> stanza.</p>
<div class="highlight-cabal notranslate"><div class="highlight"><pre><span></span>executable hello
hs-source-dirs:      app
main-is:             hello.hs
build-depends:       base ^&gt;=4.14.1.0
default-language:    Haskell2010
ghc-options:         -Wall -O2
</pre></div>
</div>
<p>This specifies the source directory and which file holds the main
function. Normally the file name must match the module name, but the
<em>main</em> is an exception.</p>
<p>Rather than just asking for the type of <em>putStrLn</em>, we can run it in the
REPL. As mentioned, the REPL allows us to execute IO actions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="kt">Hello</span><span class="p">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div>
</div>
</div>
<div class="section" id="getline">
<h4><span class="section-number">1.4.2.2. </span>getLine<a class="headerlink" href="#getline" title="Permalink to this headline">¶</a></h4>
<p>Let’s look at <em>getLine</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">getLine</span>
<span class="nf">getLine</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
</pre></div>
</div>
<p>This shows that it is a recipe, possibly producing side-effects, that,
when executed will produce a <em>String</em>. In the case of <em>getLine</em>, the
side-effect in question is that it will wait for user input from the
keyboard.</p>
<p>If we execute <em>getLine</em> in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">getLine</span>
</pre></div>
</div>
<p>It waits for keyboard input. Then, if we enter something, it returns the
result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Haskell</span>
<span class="s">&quot;Haskell&quot;</span>
</pre></div>
</div>
<p>There are a variety of IO actions defined in Haskell to do all sorts of
things like reading files, writing files, reading from and writing to
sockets.</p>
<p>But no matter how many predefined actions you have, that will never be
enough to achieve something complex, so there must be a way to combine
these primitive, provided IO actions into bigger, more complex recipes.</p>
<p>One thing we can do is make use of the <em>Functor</em> type instance of IO.
Let’s look at the type instances of <em>IO</em> in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">IO</span>
<span class="kr">type</span> <span class="kt">IO</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">newtype</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="ow">=</span> <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Types</span><span class="o">.</span><span class="kt">IO</span> <span class="p">(</span><span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">State</span><span class="o">#</span>
                                 <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">RealWorld</span>
                                 <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">#</span> <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">State</span><span class="o">#</span>
                                       <span class="n">ghc</span><span class="o">-</span><span class="n">prim</span><span class="o">-</span><span class="mf">0.6</span><span class="o">.</span><span class="mi">1</span><span class="kt">:GHC</span><span class="o">.</span><span class="kt">Prim</span><span class="o">.</span><span class="kt">RealWorld</span><span class="p">,</span>
                                       <span class="n">a</span> <span class="o">#</span><span class="p">))</span>
   <span class="c1">-- Defined in ‘ghc-prim-0.6.1:GHC.Types’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">MonadFail</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘Control.Monad.Fail’</span>
</pre></div>
</div>
<p>We see the dreaded <em>Monad</em> instance, but we also see a <em>Functor</em>
instance. <em>Functor</em> is a very important type class in Haskell. If we
look at it in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Functor</span>
<span class="kr">type</span> <span class="kt">Functor</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
<span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL fmap #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>The important method here is <em>fmap</em>. The second function <em>(&lt;$)</em> is a
convenience function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>This function, <em>fmap</em>, that all <em>Functor</em>s have tells us that, if we
give it has access to a function that can turn an <em>a</em> into a <em>b</em>, then
it can turn an <em>f a</em> into an <em>f b</em> for us. Here, we are interested in
the case where <em>f</em> is <em>IO</em>.</p>
<p>If we specialized the function for <em>IO</em>, we would have a function like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fmap&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span>
</pre></div>
</div>
<p>How does that work. Well, <em>IO a</em> is a recipe that has side effects and
produces an <em>a</em>. So, how do we get a <em>b</em> out of that? We perform the
recipe, but, before return the <em>a</em>, we apply the <em>(a -&gt; b)</em> function to
to <em>a</em> and return the result, which is the <em>b</em>.</p>
<p>In the REPL, let’s look at the <em>toUpper</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Char</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">toUpper</span>
<span class="nf">toUpper</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Char</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">toUpper</span> <span class="sc">&#39;q&#39;</span>
<span class="sc">&#39;Q&#39;</span>
</pre></div>
</div>
<p>If we want to apply that to a <em>String</em> rather than a <em>Char</em> we can use
the <em>map</em> function. <em>String</em>s in Haskell are just lists of <em>Char</em>s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="s">&quot;Haskell&quot;</span>
<span class="s">&quot;HASKELL&quot;</span>
</pre></div>
</div>
<p>The <em>map toUpper</em> function is a function from <em>String</em> to <em>String</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">map</span> <span class="n">toUpper</span>
<span class="nf">map</span> <span class="n">toUpper</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>And we can use this in combination with <em>fmap</em>. If we use <em>map toUpper</em>
as our function to convert an <em>a</em> to a <em>b</em>, we can see what the type of
output of <em>fmap</em> would be when applied to an <em>IO a</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s see it in action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span>
<span class="nf">haskell</span>
<span class="s">&quot;HASKELL&quot;</span>
</pre></div>
</div>
<p>We can also use the <em>&gt;&gt;</em> operator. This chains two <em>IO</em> actions
together, ignoring the result of the first. In the following example,
both actions will be performed in sequence.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello&quot;</span> <span class="o">&gt;&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;World&quot;</span>
<span class="kt">Hello</span>
<span class="kt">World</span>
</pre></div>
</div>
<p>Here, there is no result from <em>putStrLn</em>, but if there were, it would
have been ignored. Its side effects would have been performed, its
result ignored, then the second <em>putStrLn</em> side effects would been
performed before returning the result of the second call.</p>
<p>Then, there is an important operator that does not ignore the result of
the first <em>IO</em> action, and that is called <em>bind</em>. It is written as the
<em>&gt;&gt;=</em> symbol.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>We see the <em>Monad</em> constraint, but we can ignore that for now and just
think of <em>IO</em>.</p>
<p>What this says is that if I have a recipe that performs side effects
then gives me a result <em>a</em>, and given that I have a function that takes
an <em>a</em> and gives me back a recipe that returns a <em>b</em>, then I can combine
the recipe <em>m a</em> with the recipe <em>m b</em> by taking the value <em>a</em> and using
it in the recipe that results in the value <em>b</em>.</p>
<p>An example will make this clear.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">getLine</span> <span class="o">&gt;&gt;=</span> <span class="n">putStrLn</span>
<span class="kt">Haskell</span>
<span class="kt">Haskell</span>
</pre></div>
</div>
<p>Here, the function <em>getLine</em> is of type <em>IO String</em>. The return value
<em>a</em> is passed to the function <em>(a -&gt; m b)</em> which then generates a recipe
<em>putStrLn</em> with an input value of <em>a</em> and an output of type <em>IO ()</em>.
Then, <em>putStrLn</em> performs its side effects and returns <em>Unit</em>.</p>
<p>There is another, very important, way to create <em>IO</em> actions, and that
is to create recipes that immediately return results without performing
any side effects.</p>
<p>That is done with a function called <em>return</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">return</span>
<span class="nf">return</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>Again, it is general for any Monad, we only need to think about <em>IO</em>
right now.</p>
<p>It takes a value <em>a</em> and returns a recipe that produces the value <em>a</em>.
In the case of <em>return</em>, the recipe does not actually create any side
effects.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="s">&quot;Haskell&quot;</span>
</pre></div>
</div>
<p>We needed to specify the return type so that the REPL knows which Monad
we are using:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>

<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">return</span> <span class="s">&quot;Haskell&quot;</span>
<span class="nf">return</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>If we now go back to our <em>main</em> program, we can now write relatively
complex <em>IO</em> actions. For example, we can define an <em>IO</em> action that
will ask for two strings and print result of concatenating those two
strings to the console.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">bar</span>

<span class="nf">bar</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">bar</span> <span class="ow">=</span> <span class="n">getLine</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span>
      <span class="n">getLine</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">t</span> <span class="ow">-&gt;</span>
      <span class="n">putStrLn</span> <span class="p">(</span><span class="n">s</span> <span class="o">++</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>And then, when we run it, the program will wait for two inputs and then
output the concatenated result.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cabal run hello
one
two
onetwo
</pre></div>
</div>
<p>This is enough now for our purposes, although we won’t need the <em>IO</em>
Monad until perhaps later in the course when we talk about actually
deploying Plutus contracts. However, the <em>IO</em> Monad is an important
example, and a good one to start with.</p>
<p>So, for now, let’s completely forget about <em>IO</em> and just write pure,
functional Haskell, using the <em>Maybe</em> type.</p>
</div>
<div class="section" id="maybe">
<h4><span class="section-number">1.4.2.3. </span>Maybe<a class="headerlink" href="#maybe" title="Permalink to this headline">¶</a></h4>
<p>The <em>Maybe</em> type is one of the most useful types in Haskell.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Maybe</span>
<span class="kr">type</span> <span class="kt">Maybe</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
   <span class="c1">-- Defined in ‘GHC.Maybe’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Maybe’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Ord</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Maybe’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Show’</span>
<span class="kr">instance</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Read</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Read’</span>
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘Data.Foldable’</span>
<span class="kr">instance</span> <span class="kt">Traversable</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘Data.Traversable’</span>
<span class="kr">instance</span> <span class="kt">MonadFail</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘Control.Monad.Fail’</span>
</pre></div>
</div>
<p>It is often called something like <em>Optional</em> in other programming
languages.</p>
<p>It has two constructors - <em>Nothing</em>, which takes no arguments, and
<em>Just</em>, which takes one argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div>
</div>
<p>Let’s look at an example.</p>
<p>In Haskell, if you want to pass a <em>String</em> to a value that has a <em>read</em>
instance, you will normally do this with the <em>read</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">42</span>
</pre></div>
</div>
<p>But, <em>read</em> is a bit unpleasant, because if we have something that can’t
be parsed as an <em>Int</em>, then we get an error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;42+u&quot;</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">read</span><span class="kt">:</span> <span class="n">no</span> <span class="n">parse</span>
</pre></div>
</div>
<p>Let’s import <em>readMaybe</em> to do it in a better way.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Text.Read</span> <span class="p">(</span><span class="nf">readMaybe</span><span class="p">)</span>
<span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The function <em>readMaybe</em> does the same as <em>read</em>, but it returns a
<em>Maybe</em>, and in the case where it cannot parse, it will return a <em>Maybe</em>
created with the <em>Nothing</em> constructor.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">readMaybe</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="kt">Just</span> <span class="mi">42</span>

<span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">readMaybe</span> <span class="s">&quot;42+u&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>Let’s say we want to create a new function that returns a <em>Maybe</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="p">::</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">Int</span>
</pre></div>
</div>
<p>The idea is that the function should try to parse all three <em>String</em>s
as <em>Int</em>s. If all the <em>String</em>s can be successfully parsed as
<em>Int</em>s, then we want to add those three <em>Int</em>s to get a sum. If one
of the parses fails, we want to return <em>Nothing</em>.</p>
<p>One way to do that would be:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
   <span class="kt">Just</span> <span class="n">k</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">y</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
      <span class="kt">Just</span> <span class="n">l</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">z</span> <span class="kr">of</span>
            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
            <span class="kt">Just</span> <span class="n">m</span>  <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s see if it works. First, the case where is succeeds:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span>
<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;1&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Just</span> <span class="mi">6</span>
</pre></div>
</div>
<p>But, if one of the values can’t be parsed, we get <em>Nothing</em>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>The code is not ideal because we repeat the same pattern three times.
Each time we have to consider the two cases - whether the result of the
read is a <em>Just</em> or a <em>Nothing</em>.</p>
<p>Ask Haskellers, we hate repetition like this.</p>
<p>The thing we want to do is very simple. We want to pass the three
<em>String</em>s and add the result, but with all those cases it is very
noisy and very ugly. We want to abstract away this pattern.</p>
<p>One way to do that would be to define something like:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindMaybe</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="nf">bindMaybe</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">bindMaybe</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>Let’s write the same function again using <em>bindMaybe</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">foo&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">readMaybe</span> <span class="n">x</span> <span class="p">`</span><span class="n">bindMaybe</span><span class="p">`</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
            <span class="n">readMaybe</span> <span class="n">y</span> <span class="p">`</span><span class="n">bindMaybe</span><span class="p">`</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
            <span class="n">readMaybe</span> <span class="n">z</span> <span class="p">`</span><span class="n">bindMaybe</span><span class="p">`</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>And then, in the REPL, we get the same results for <em>foo’</em> as we got for
<em>foo</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;1&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Just</span> <span class="mi">6</span>

<span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>This does exactly the same as <em>foo</em>, but it is much more compact, there
is far less noise, and the business logic is much clearer.</p>
<p>It may, or may not, help to view the function with it not being used
with infix notation:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">bindMaybe</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">42</span>
</pre></div>
</div>
<p>Here you can see the function clearly taking the <em>Maybe</em> and then the
function that takes the <em>a</em> from the <em>Maybe</em> and uses it as the input to
a function that returns a new <em>Maybe</em>.</p>
<p>This produces nothing useful, until we add the second <em>readMaybe</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Text</span><span class="o">.</span><span class="kt">Read</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">&gt;</span> <span class="n">bindMaybe</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">bindMaybe</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="p">)))</span>
<span class="kt">Just</span> <span class="mi">47</span>
</pre></div>
</div>
<p>In some ways <em>Nothing</em> is a bit like an exception in other languages. If
any of the computations returns <em>Nothing</em>, the remainder of the
computations in the block are not performed and <em>Nothing</em> is returned.</p>
</div>
<div class="section" id="either">
<h4><span class="section-number">1.4.2.4. </span>Either<a class="headerlink" href="#either" title="Permalink to this headline">¶</a></h4>
<p>Another very useful type in Haskell is the <em>Either</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Either</span>
<span class="kr">type</span> <span class="kt">Either</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
   <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Ord</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Read</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Read</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Foldable’</span>
<span class="kr">instance</span> <span class="kt">Traversable</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Traversable’</span>
</pre></div>
</div>
<p><em>Either</em> takes two parameters, <em>a</em> and <em>b</em>. Like <em>Maybe</em> it has two
constructors, but unlike <em>Maybe</em> both take a value. It can <em>Either</em> be
an <em>a</em> or a <em>b</em>. The two constructors are <em>Left</em> and <em>Right</em>.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">Left</span> <span class="s">&quot;Haskell&quot;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Left</span> <span class="s">&quot;Haskell&quot;</span>
</pre></div>
</div>
<p>Or</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">Right</span> <span class="mi">7</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Right</span> <span class="mi">7</span>
</pre></div>
</div>
<p>If we take the exception analogy a little further, then one issue with
<em>Maybe</em> is that if we return <em>Nothing</em>, there is no error message. But,
if we want something that gives a message, we can replace <em>Maybe</em> with
an <em>Either</em> type.</p>
<p>In that case, <em>Right</em> can correspond to <em>Just</em> and <em>Left</em> can correspond
to an error, as <em>Nothing</em> did. But, depending on what type we choose for
<em>a</em>, we can give appropriate error messages.</p>
<p>Let’s define something called <em>readEither</em> and see what it does when it
can and when it cannot parse its input.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readEither</span> <span class="ow">::</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span>
<span class="nf">readEither</span> <span class="n">s</span> <span class="kr">case</span> <span class="n">readMaybe</span> <span class="n">s</span> <span class="kr">of</span>
   <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;can&#39;t parse: &quot;</span> <span class="o">++</span> <span class="n">s</span>
   <span class="kt">Just</span> <span class="n">a</span>  <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="n">a</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">readEither</span> <span class="s">&quot;42&quot;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Right</span> <span class="mi">42</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">readEither</span> <span class="s">&quot;42+u&quot;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Left</span> <span class="s">&quot;can&#39;t parse: 42+u&quot;</span>
</pre></div>
</div>
<p>Using this, we can now rewrite <em>foo</em> in terms of <em>Either</em>. First, using
the long-winded method:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">readEither</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
   <span class="kt">Right</span> <span class="n">k</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readEither</span> <span class="n">y</span> <span class="kr">of</span>
      <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
      <span class="kt">Right</span> <span class="n">l</span>  <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">readEither</span> <span class="n">z</span> <span class="kr">of</span>
            <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
            <span class="kt">Right</span> <span class="n">m</span>  <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s try it. First, the happy path:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;1&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Right</span> <span class="mi">6</span>
</pre></div>
</div>
<p>Then, when we have a problem:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Either</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="s">&quot;ays&quot;</span> <span class="s">&quot;2&quot;</span> <span class="s">&quot;3&quot;</span>
<span class="kt">Left</span> <span class="s">&quot;can&#39;t parse: ays&quot;</span>
</pre></div>
</div>
<p>But, we have the same problem that we had with <em>Maybe</em>; we have a lot of
repetition.</p>
<p>The solution is similar.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindEither</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span>
<span class="nf">bindEither</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">err</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">err</span>
<span class="nf">bindEither</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span>  <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="nf">foo&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">readEither</span> <span class="n">x</span> <span class="p">`</span><span class="n">bindEither</span><span class="p">`</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
            <span class="n">readEither</span> <span class="n">y</span> <span class="p">`</span><span class="n">bindEither</span><span class="p">`</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
            <span class="n">readEither</span> <span class="n">z</span> <span class="p">`</span><span class="n">bindEither</span><span class="p">`</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
            <span class="kt">Right</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>You can run this again in the REPL and it will behave in the same way as
its long-winded version.</p>
</div>
<div class="section" id="writer">
<h4><span class="section-number">1.4.2.5. </span>Writer<a class="headerlink" href="#writer" title="Permalink to this headline">¶</a></h4>
<p>So far we have looked at three examples: <em>IO a</em>, <em>Maybe a</em> and <em>Either
String a</em>. <em>IO a</em> represents plans that can involve side effects and,
when executed, produce an <em>a</em>. <em>Maybe a</em> and <em>Either String a</em> represent
computations that can produce an <em>a</em> but can also fail. The difference
between <em>Maybe</em> and <em>Either</em> is just that <em>Maybe</em> does not produce any
error message, but <em>Either</em> does.</p>
<p>Now let’s look at a completely different example that captures the idea
of computations that can also produce log output.</p>
<p>We can represent that with a type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
   <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>As an example, let’s write a function that returns a <em>Writer</em> for an
<em>Int</em> and writes a log message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">number</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">number</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="n">n</span> <span class="o">$</span> <span class="p">[</span><span class="s">&quot;number: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">number</span> <span class="mi">42</span>
<span class="kt">Writer</span> <span class="mi">42</span> <span class="p">[</span><span class="s">&quot;number: 42&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, let’s do something similar to that which we have done with <em>Maybe</em>
and <em>Either</em>.</p>
<p>Let’s write a function that takes three logging computations that each
produce an <em>Int</em> and we want to return a single computation that
produces the sum of those <em>Int</em>s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">k</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">l</span> <span class="n">ys</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">m</span> <span class="n">zs</span><span class="p">)</span> <span class="ow">=</span>
<span class="kt">Writer</span> <span class="p">(</span><span class="kt">K</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span>
</pre></div>
</div>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="p">(</span><span class="n">number</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Writer</span> <span class="mi">6</span> <span class="p">[</span><span class="s">&quot;number: 1&quot;</span><span class="p">,</span><span class="s">&quot;number: 2&quot;</span><span class="p">,</span><span class="s">&quot;number: 3&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, let’s write another useful function that takes a list of message
and producers a <em>Writer</em> with no useful result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tell</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="nb">()</span>
<span class="nf">tell</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Now, we can update <em>foo</em> to add an extra log message showing the sum of
the numbers.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">k</span> <span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">l</span> <span class="n">ys</span><span class="p">)</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">m</span> <span class="n">zs</span><span class="p">)</span> <span class="ow">=</span>
<span class="kr">let</span>
   <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span>
   <span class="kt">Writer</span> <span class="kr">_</span> <span class="n">us</span> <span class="ow">=</span> <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;sum: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span><span class="p">]</span>
<span class="kr">in</span>
   <span class="kt">Writer</span> <span class="n">s</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span> <span class="o">++</span> <span class="n">zs</span> <span class="o">++</span> <span class="n">us</span>
</pre></div>
</div>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="p">(</span><span class="n">number</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Writer</span> <span class="mi">6</span> <span class="p">[</span><span class="s">&quot;number: 1&quot;</span><span class="p">,</span><span class="s">&quot;number: 2&quot;</span><span class="p">,</span><span class="s">&quot;number: 3&quot;</span><span class="p">,</span><span class="s">&quot;sum: 6&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>As before, we can write a bind function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindWriter</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span>
<span class="nf">bindWriter</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">a</span> <span class="n">xs</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span>
<span class="kr">let</span>
   <span class="kt">Writer</span> <span class="n">b</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
<span class="kr">in</span>
   <span class="kt">Writer</span> <span class="n">b</span> <span class="o">$</span> <span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span>
</pre></div>
</div>
<p>Here, the <em>bindWriter</em> function is returning the <em>Writer b</em> and
producing log messages which are a concatenation of the <em>xs</em> that we
pattern matched on input, and the <em>ys</em> that we pattern matched when
calling <em>f a</em> in order to produce the <em>Writer b</em>.</p>
<p>Now, we can rewrite <em>foo</em> using <em>bindWriter</em> and make it much nicer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
            <span class="n">y</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
            <span class="n">z</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
            <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span>
            <span class="kr">in</span> <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;sum: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span><span class="p">]</span> <span class="p">`</span><span class="n">bindWriter</span><span class="p">`</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span>
               <span class="kt">Writer</span> <span class="n">s</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>What we did with <em>foo</em> before, we can now do with <em>foo’</em>, and we get the
same result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Writer</span><span class="o">&gt;</span> <span class="n">foo&#39;</span> <span class="p">(</span><span class="n">number</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">number</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Writer</span> <span class="mi">6</span> <span class="p">[</span><span class="s">&quot;number: 1&quot;</span><span class="p">,</span><span class="s">&quot;number: 2&quot;</span><span class="p">,</span><span class="s">&quot;number: 3&quot;</span><span class="p">,</span><span class="s">&quot;sum: 6&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Admittedly, it is longer than it was before, but it is much nicer. We no
longer need to do the pattern matching to extract the messages. We don’t
have to explicitly combine the log messages, where we could make a
mistake and forget one, or get the order wrong. Instead, we abstract all
that away and can just concentrate on the business logic.</p>
<p>Although the pattern is the same as with <em>Maybe</em> and <em>Either</em>, note that
the special aspect of these computations is completely different. With
<em>Maybe</em> and <em>Either</em> we dealt with the notion of failure, whereas here,
with the <em>Writer</em>, there is no failure, but we instead have additional
output.</p>
</div>
<div class="section" id="what-is-a-monad">
<h4><span class="section-number">1.4.2.6. </span>What is a Monad?<a class="headerlink" href="#what-is-a-monad" title="Permalink to this headline">¶</a></h4>
<p>Now, we are in a position to explain what a Monad is.</p>
<p>Looking back at the four examples, what did they have in common? In all
four cases, We had a type constructor with one type parameter - <em>IO</em>,
<em>Maybe</em>, <em>Either String</em> and <em>Writer</em> all take a type parameter.</p>
<p>And, for all four of these examples, we had a bind function. For <em>IO</em>,
we had the <em>&gt;&gt;=</em> function and for the others we had the bind functions
that we wrote ourselves.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bindWriter</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">b</span>
<span class="nf">bindEither</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">b</span>
<span class="nf">bindMaybe</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</pre></div>
</div>
<p>How the bind works depends on the case. In the case of <em>IO</em> it is
built-in magic, but you can think of it as just combining the two plans
describing the actions to take during computation. For <em>bindMaybe</em> and
<em>bindEither</em> the logic is for the whole plan to fail if any part of it
fails, and for <em>bindWriter</em>, the logic was to combine the list of log
messages.</p>
<p>And that is the main idea of Monads. It’s a concept of computation with
some additional side effects, and the ability to bind two such
computations together.</p>
<p>There is another aspect that we briefly mentioned in the case of <em>IO</em>
but not for the other examples - another thing that we can always do.</p>
<p>Whenever we have such a concept of computation with side effects, we
also also always have the ability to produce a computation of this kind
that <em>doesn’t</em> have any side effects.</p>
<p>In the example of <em>IO</em>, this was done with <em>return</em>. Given an <em>a</em>, you
can create an <em>IO a</em> which is the recipe that always simply returns the
<em>a</em> with no side effects. Each of the other example has this ability as
well, as shown below.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span>              <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="kt">Just</span>                <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="kt">Right</span>               <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="n">a</span>
<span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="n">a</span>
</pre></div>
</div>
<p>And it is the combination of these two features that defines a Monad.</p>
<ul class="simple">
<li><p>the ability to bind two computations together</p></li>
<li><p>the possibility to construct a computation from a pure value without
making use of any of the potential side effects</p></li>
</ul>
<p>If we look in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Monad</span>
<span class="kr">type</span> <span class="kt">Monad</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL (&gt;&gt;=) #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>We see the bind function</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>And the <em>return</em> function that takes a pure value and turns it into a
computation that has potential for side effects, but does not use them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>The other function <em>&gt;&gt;</em> can easily be defined in terms of <em>&gt;&gt;=</em>, but is
provided for convenience.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>What this function does is to throw away the result of the first
computation, so you could define it in terms of <em>&gt;&gt;=</em> by just ignoring
the argument to the function parameter.</p>
<p>There’s another technical computation. We see that <em>Monad</em> has the super
class <em>Applicative</em>, so every Monad is <em>Applicative</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Applicative</span>
<span class="kr">type</span> <span class="kt">Applicative</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
<span class="nf">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.</span><span class="n">liftA2</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span>
         <span class="kt">Applicative</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>We see it has a bunch of functions, but we only need the first two.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>The function <em>pure</em> has the same type signature as <em>return</em>. Then there
is &lt;*&gt; (pronounced ‘ap’) which looks a bit more complicated. But, the
truth is that, once you have <em>return</em> and <em>&gt;&gt;=</em> in a Monad, we can
easily define both <em>pure</em> and &lt;*&gt;.</p>
<p>We see that <em>Applicative</em> also has a superclass <em>Functor</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Functor</span>
<span class="kr">type</span> <span class="kt">Functor</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
<span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL fmap #-}</span>
   <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Either’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,,)</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,,)</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>As we mentioned in the context of <em>IO</em>, <em>Functor</em> has the <em>fmap</em>
function which, given a function from <em>a</em> to <em>b</em> will turn an <em>f a</em> into
an <em>f b</em>.</p>
<p>The prototypical example for <em>fmap</em> is lists where <em>fmap</em> is just <em>map</em>.
Given a function from <em>a</em> to <em>b</em>, you can create a list of type <em>b</em> from
a list of type <em>a</em> by applying the <em>map</em> function to each of the
elements of the list.</p>
<p>Again, once you have <em>return</em> and <em>&gt;&gt;=</em>, it is easy to define <em>fmap</em>.</p>
<p>So, whenever you want to define a Monad, you just define <em>return</em> and
<em>&gt;&gt;=</em>, and to make the compiler happy and to give instances for
<em>Functor</em> and <em>Applicative</em>, there’s always a standard way of doing it.</p>
<p>We can do this in the example of <em>Writer</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Writer</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="ow">=</span> <span class="n">liftM</span>

<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Writer</span> <span class="kr">where</span>
   <span class="n">pure</span> <span class="ow">=</span> <span class="n">return</span>
   <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Writer</span> <span class="kr">where</span>
   <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="n">a</span> <span class="kt">[]</span>
   <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bindWriter</span>
</pre></div>
</div>
<p>We don’t have to do the same for <em>Maybe</em>, <em>Either</em> or <em>IO</em> because they
are already Monads defined by the Prelude.</p>
</div>
<div class="section" id="why-is-this-useful">
<h4><span class="section-number">1.4.2.7. </span>Why Is This useful?<a class="headerlink" href="#why-is-this-useful" title="Permalink to this headline">¶</a></h4>
<p>It is always useful, in general, to identify a common pattern and give
it a name.</p>
<p>But, maybe the most important advantage is that there are lots of
functions that don’t care which Monad we are dealing with - they will
work with all Monads.</p>
<p>Let’s generalize the example where we compute the sum of three integers.
We use a <em>let</em> in the example below for reasons that will become clear
in moment.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">threeInts</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="nf">threeInts</span> <span class="n">mx</span> <span class="n">my</span> <span class="n">mz</span> <span class="ow">=</span>
   <span class="n">mx</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">k</span> <span class="ow">-&gt;</span>
   <span class="n">my</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">l</span> <span class="ow">-&gt;</span>
   <span class="n">mz</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span>
   <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span> <span class="kr">in</span> <span class="n">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>Now we have this function, we can return to the <em>Maybe</em> example and
rewrite it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">threeInts</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>We can do the same for the <em>Either</em> example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">threeInts</span> <span class="p">(</span><span class="n">readEither</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">readEither</span> <span class="n">y</span><span class="p">)</span> <span class="p">(</span><span class="n">readEither</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>Writer</em> example is not exactly the same.</p>
<p>If we are happy not to have the log message for the sum, it is very
simple as it is already an instance of <em>threeInts</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">threeInts</span>
</pre></div>
</div>
<p>However, if we want the final log message, it becomes a little more
complicated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foo&#39;&#39;</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="kt">Int</span>
<span class="nf">foo&#39;&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">threeInts</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
   <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;sum: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span><span class="p">]</span>
   <span class="n">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>If you look into the Control.Monad module in the standard Haskell
Prelude, you will see that there are many useful functions that you can
use for all Monads.</p>
<p>One way to think about a Monad is as a computation with a super power.</p>
<p>In the case of <em>IO</em>, the super power would be having real-world
side-effects. In the case of <em>Maybe</em>, the super power is being able to
fail. The super power of <em>Either</em> is to fail with an error message. And
in the case of <em>Writer</em>, the super power is to log messages.</p>
<p>There is a saying in the Haskell community that Haskell has an
overloaded semi-colon. The explanation for this is that in many
imperative programming languages, you have semi-colons that end with a
semi-colon - each statement is executed one after the other, each
separated by a semi-colon. But, what exactly the semi-colon means
depends on the language. For example, there could be an exception, in
which case computation would stop and wouldn’t continue with the next
lines.</p>
<p>In a sense, <em>bind</em> is like a semi-colon. And the cool thing about
Haskell is that it is a programmable semi-colon. We get to say what the
logic is for combining two computations together.</p>
<p>Each Monad comes with its own “semi-colon”.</p>
</div>
<div class="section" id="do-notation">
<h4><span class="section-number">1.4.2.8. </span>‘do’ notation<a class="headerlink" href="#do-notation" title="Permalink to this headline">¶</a></h4>
<p>Because this pattern is so common and monadic computations are all over
the place, there is a special notation for this in Haskell, called <em>do</em>
notation.</p>
<p>It is syntactic sugar. Let’s rewrite <em>threeInts</em> using <em>do</em> notation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">threeInts&#39;</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="nf">threeInts&#39;</span> <span class="n">mx</span> <span class="n">my</span> <span class="n">mz</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">k</span> <span class="ow">&lt;-</span> <span class="n">mx</span>
   <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">my</span>
   <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">mz</span>
   <span class="kr">let</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">k</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">m</span>
   <span class="n">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>This does exactly the same thing as the non-<em>do</em> version, but it has
less noise.</p>
<p>Note that the <em>let</em> statement does not use an <em>in</em> part. It does not
need to inside a <em>do</em> block.</p>
<p>And that’s Monads. There is a lot more to say about them but hopefully
you now have an idea of what Monads are and how they work.</p>
<p>Often you are in a situation where you want several effects at once -
for example you may want optional failure <em>and</em> log messages. There are
ways to do that in Haskell. For example there are Monad Transformers
where one can basically build custom Monads with the features that you
want.</p>
<p>There are other approaches. One is called Effect Systems, which has a
similar objective. And this is incidentally what Plutus uses for
important Monads. In particular the Contact Monad in the wallet, and the
Trace Monad which is used to test Plutus code.</p>
<p>The good news is that you don’t need to understand Effect Systems to
work with these Monads. You just need to know that you are working with
a Monad, and what super powers it has.</p>
</div>
</div>
<div class="section" id="plutus-monads">
<h3><span class="section-number">1.4.3. </span>Plutus Monads<a class="headerlink" href="#plutus-monads" title="Permalink to this headline">¶</a></h3>
<p>Now that we have seen how to write monadic code, either by using bind and return or by using do notation, we can look a very important Monad, namely the Contract Monad, which you may have
already noticed in previous code examples.</p>
<p>The Contract Monad defines code that will run in the wallet, which is the off-chain part of Plutus.</p>
<p>But, before we go into details, we will talk about a second Monad, the EmulatorTrace monad.</p>
<div class="section" id="the-emulatortrace-monad">
<h4><span class="section-number">1.4.3.1. </span>The EmulatorTrace Monad<a class="headerlink" href="#the-emulatortrace-monad" title="Permalink to this headline">¶</a></h4>
<p>You may have wondered if there is a way to execute Plutus code for testing purposes without using the Plutus Playground. There is indeed, and this is done using the <em>EmulatorTrace</em> Monad.</p>
<p>You can think of a program in this monad as what we do manually in the <em>simulator</em> tab of the playground. That is, we define the initial conditions, we define the actions such as which wallets
invoke which endpoints with which parameters and we define the waiting periods between actions.</p>
<p>The relevant definitions are in the package <em>plutus-contract</em> in module <em>Plutus.Trace.Emulator</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.Trace.Emulator</span>
</pre></div>
</div>
<p>The most basic function is called <em>runEmulatorTrace</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Run an emulator trace to completion, returning a tuple of the final state</span>
<span class="c1">-- of the emulator, the events, and any error, if any.</span>
<span class="nf">runEmulatorTrace</span>
    <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
    <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
    <span class="ow">-&gt;</span> <span class="p">([</span><span class="kt">EmulatorEvent</span><span class="p">],</span> <span class="kt">Maybe</span> <span class="kt">EmulatorErr</span><span class="p">,</span> <span class="kt">EmulatorState</span><span class="p">)</span>
<span class="nf">runEmulatorTrace</span> <span class="n">cfg</span> <span class="n">trace</span> <span class="ow">=</span>
    <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">xs</span> <span class="kt">:&gt;</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
    <span class="o">$</span> <span class="n">run</span>
    <span class="o">$</span> <span class="n">runReader</span> <span class="p">((</span><span class="n">initialDist</span> <span class="o">.</span> <span class="n">_initialChainState</span><span class="p">)</span> <span class="n">cfg</span><span class="p">)</span>
    <span class="o">$</span> <span class="n">foldEmulatorStreamM</span> <span class="p">(</span><span class="n">generalize</span> <span class="n">list</span><span class="p">)</span>
    <span class="o">$</span> <span class="n">runEmulatorStream</span> <span class="n">cfg</span> <span class="n">trace</span>
</pre></div>
</div>
<p>It gets something called an <em>EmulatorConfig</em> and an <em>EmulatorTrace ()</em>, which is a pure computation where no real-world side effects are involved. It is a pure function that executes
the trace on an emulated blockchain, and then gives a result as a list of <em>EmulatorEvent*s, maybe an error, if there was one, and then finally the final *EmulatorState</em>.</p>
<p><em>EmulatorConfig</em> is defined in a different module in the same package:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Wallet.Emulator.Stream</span>

<span class="kr">data</span> <span class="kt">EmulatorConfig</span> <span class="ow">=</span>
<span class="kt">EmulatorConfig</span>
    <span class="p">{</span> <span class="n">_initialChainState</span>      <span class="ow">::</span> <span class="kt">InitialChainState</span> <span class="c1">-- ^ State of the blockchain at the beginning of the simulation. Can be given as a map of funds to wallets, or as a block of transactions.</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">InitialChainState</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="kt">InitialDistribution</span> <span class="kt">Block</span>
</pre></div>
</div>
<p>We see it only has one field, which is of type <em>InitialChainState</em> and it is either <em>InitialDistribution</em> or <em>Block</em>.</p>
<p><em>InitialDistribution</em> is defined in another module in the same package, and it is a type synonym for a map of key value pairs of <em>Wallet*s to *Value*s, as you would expect. *Value</em> can be
either lovelace or native tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.Contract.Trace</span>

<span class="kr">type</span> <span class="kt">InitialDistribution</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">Value</span>
</pre></div>
</div>
<p>In the same module, we see something called <em>defaultDist</em> which returns a default distribution for all wallets. It does this by passing the 10 wallets defined by <em>allWallets</em> to <em>defaultDistFor</em> which takes a list of
wallets.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | The wallets used in mockchain simulations by default. There are</span>
<span class="c1">--   ten wallets because the emulator comes with ten private keys.</span>
<span class="nf">allWallets</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">EM</span><span class="o">.</span><span class="kt">Wallet</span><span class="p">]</span>
<span class="nf">allWallets</span> <span class="ow">=</span> <span class="kt">EM</span><span class="o">.</span><span class="kt">Wallet</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">]</span>

<span class="nf">defaultDist</span> <span class="ow">::</span> <span class="kt">InitialDistribution</span>
<span class="nf">defaultDist</span> <span class="ow">=</span> <span class="n">defaultDistFor</span> <span class="n">allWallets</span>

<span class="nf">defaultDistFor</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">EM</span><span class="o">.</span><span class="kt">Wallet</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">InitialDistribution</span>
<span class="nf">defaultDistFor</span> <span class="n">wallets</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">(</span><span class="n">repeat</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="mi">100_000_000</span><span class="p">))</span>
</pre></div>
</div>
<p>We can try this out in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.Trace.Emulator</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.Contract.Trace</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">defaultDist</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">6</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">7</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">8</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">9</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">10</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])]))]</span>
</pre></div>
</div>
<p>We can see that each of the 10 wallets has been given an initial distribution of 100,000,000 lovelace.</p>
<p>We can also get the balances for a specific wallet or wallets:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">defaultDistFor</span> <span class="p">[</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])]))]</span>
</pre></div>
</div>
<p>If you want different initial values, of if you want native tokens, then you have to specify that manually.</p>
<p>Let’s see what we need to run our first trace:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">runEmulatorTrace</span>
<span class="nf">runEmulatorTrace</span>
<span class="ow">::</span> <span class="kt">EmulatorConfig</span>
<span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="ow">-&gt;</span> <span class="p">([</span><span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">MultiAgent</span><span class="o">.</span><span class="kt">EmulatorEvent</span><span class="p">],</span> <span class="kt">Maybe</span> <span class="kt">EmulatorErr</span><span class="p">,</span>
      <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">MultiAgent</span><span class="o">.</span><span class="kt">EmulatorState</span><span class="p">)</span>
</pre></div>
</div>
<p>So, we need an <em>EmulatorConfig</em> which we know takes an <em>InitialChainState</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Wallet.Emulator.Stream</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">InitialChainState</span>
<span class="kr">type</span> <span class="kt">InitialChainState</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">type</span> <span class="kt">InitialChainState</span> <span class="ow">=</span>
<span class="kt">Either</span> <span class="kt">InitialDistribution</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Blockchain</span><span class="o">.</span><span class="kt">Block</span>
      <span class="c1">-- Defined in ‘Wallet.Emulator.Stream’</span>
</pre></div>
</div>
<p>If we take the <em>Left</em> of the <em>defaultDist</em> will will get an <em>InitialDistribution</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Left</span> <span class="n">defaultDist</span>
<span class="kt">Left</span> <span class="n">defaultDist</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">InitialDistribution</span> <span class="n">b</span>
</pre></div>
</div>
<p>Which we can then use to construct an <em>EmulatorConfig</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="n">defaultDist</span>
<span class="kt">EmulatorConfig</span> <span class="p">{</span><span class="n">_initialChainState</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">6</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">7</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">8</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">9</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])])),(</span><span class="kt">Wallet</span> <span class="mi">10</span><span class="p">,</span><span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)])]))])}</span>
</pre></div>
</div>
<p>So, let’s try out <em>runEmulatorTrace</em>. Recall that, as well as and <em>EmulatorConfig</em>, we also need to pass in an <em>EmulatorTrace</em>, and the most simple one we can create is simply one that returns Unit - <em>return ()</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runEmulatorTrace</span> <span class="p">(</span><span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="n">defaultDist</span><span class="p">)</span> <span class="o">$</span> <span class="n">return</span> <span class="nb">()</span>
</pre></div>
</div>
<p>If you run this in the REPL you will get a crazy amount of data output to the console, even though we are not doing anything with the trace. If you want to make it useful, you must
somehow filter all this data down to something that sensible, and aggregate it in some way.</p>
<p>Luckily, there are other functions as well as <em>runEmulatorTrace</em>. One of them is <em>runEmulatorTraceIo</em> which runs the emulation then outputs the trace in a nice form on the screen.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runEmulatorTraceIO</span>
<span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runEmulatorTraceIO</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">def</span>
</pre></div>
</div>
<p>To use this function, we don’t need to specify an <em>EmulatorConfig</em> like we did before, because by default will will just use the default distribution.</p>
<p>In the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">...&gt;</span> <span class="n">runEmulatorTraceIO</span> <span class="o">$</span> <span class="n">return</span> <span class="nb">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>And we see a much more manageable, concise output. Nothing happens, but we see the Genesis transaction and then the final balances for each wallet.</p>
<p>If you want more control, there is also <em>runEmulatorTraceIO’</em>, which does take an <em>EmulatorConfig</em>, so we could specify a different distribution.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runEmulatorTraceIO&#39;</span>
<span class="ow">::</span> <span class="kt">TraceConfig</span>
<span class="ow">-&gt;</span> <span class="kt">EmulatorConfig</span>
<span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runEmulatorTraceIO&#39;</span> <span class="n">tcfg</span> <span class="n">cfg</span> <span class="n">trace</span>
<span class="ow">=</span> <span class="n">runPrintEffect</span> <span class="p">(</span><span class="n">outputHandle</span> <span class="n">tcfg</span><span class="p">)</span> <span class="o">$</span> <span class="n">runEmulatorTraceEff</span> <span class="n">tcfg</span> <span class="n">cfg</span> <span class="n">trace</span>
</pre></div>
</div>
<p>It also takes a <em>TraceConfig</em>, which has two fields.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TraceConfig</span> <span class="ow">=</span> <span class="kt">TraceConfig</span>
<span class="p">{</span> <span class="n">showEvent</span>    <span class="ow">::</span> <span class="kt">EmulatorEvent&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="c1">-- ^ Function to decide how to print the particular events.</span>
<span class="p">,</span> <span class="n">outputHandle</span> <span class="ow">::</span> <span class="kt">Handle</span>
<span class="c1">-- ^ Where to print the outputs to. Default: &#39;System.IO.stdout&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first field, <em>showEvent</em> is a function that specifies which <em>EmulatorEvent*s are displayed and how they are displayed. It takes
an *EmulatorEvent</em> as an argument and can return <em>Nothing</em> it the event should not be displayed, or a <em>Just</em> with a <em>String</em> showing how the event will be displayed.</p>
<p>Here is the default <em>TraceConfig</em> used by <em>runEmulatorTraceIO</em>. We can see that most events are ignored and that we only get output for some of the events.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Default</span> <span class="kt">TraceConfig</span> <span class="kr">where</span>
<span class="nf">def</span> <span class="ow">=</span> <span class="kt">TraceConfig</span>
            <span class="p">{</span> <span class="n">showEvent</span>     <span class="ow">=</span> <span class="n">defaultShowEvent</span>
            <span class="p">,</span> <span class="n">outputHandle</span>  <span class="ow">=</span> <span class="n">stdout</span>
            <span class="p">}</span>

<span class="nf">defaultShowEvent</span> <span class="ow">::</span> <span class="kt">EmulatorEvent&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="nf">defaultShowEvent</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
<span class="kt">UserThreadEvent</span> <span class="p">(</span><span class="kt">UserLog</span> <span class="n">msg</span><span class="p">)</span>                                        <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">$</span> <span class="s">&quot;*** USER LOG: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">msg</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">ContractLog</span> <span class="p">(</span><span class="kt">A</span><span class="o">.</span><span class="kt">String</span> <span class="n">msg</span><span class="p">))</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">$</span> <span class="s">&quot;*** CONTRACT LOG: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">msg</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">StoppedWithError</span> <span class="n">err</span><span class="p">)</span>       <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">$</span> <span class="s">&quot;*** CONTRACT STOPPED WITH ERROR: &quot;</span> <span class="o">&lt;&gt;</span> <span class="n">show</span> <span class="n">err</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="kt">NoRequestsHandled</span>            <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">HandledRequest</span> <span class="kr">_</span><span class="p">)</span>           <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">InstanceEvent</span> <span class="p">(</span><span class="kt">ContractInstanceLog</span> <span class="p">(</span><span class="kt">CurrentRequests</span> <span class="kr">_</span><span class="p">)</span>          <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">SchedulerEvent</span> <span class="kr">_</span>                                                     <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">ChainIndexEvent</span> <span class="kr">_</span> <span class="kr">_</span>                                                  <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="kt">WalletEvent</span> <span class="kr">_</span> <span class="kr">_</span>                                                      <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
<span class="nf">ev</span>                                                                   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="o">.</span> <span class="n">renderString</span> <span class="o">.</span> <span class="n">layoutPretty</span> <span class="n">defaultLayoutOptions</span> <span class="o">.</span> <span class="n">pretty</span> <span class="o">$</span> <span class="n">ev</span>
</pre></div>
</div>
<p>The second field is a handle which defaults to <em>stdout</em>, but we could also specify a file here.</p>
<p>Now let’s look at a more interesting trace, using the <em>Vesting</em> contract from the last lecture.</p>
<p>First, we define a <em>Trace</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
<span class="nf">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;give&quot;</span> <span class="n">h1</span> <span class="o">$</span> <span class="kt">GiveParams</span>
      <span class="p">{</span> <span class="n">gpBeneficiary</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">2</span>
      <span class="p">,</span> <span class="n">gpDeadline</span>    <span class="ow">=</span> <span class="kt">Slot</span> <span class="mi">20</span>
      <span class="p">,</span> <span class="n">gpAmount</span>      <span class="ow">=</span> <span class="mi">1000</span>
      <span class="p">}</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">waitUntilSlot</span> <span class="mi">20</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;grab&quot;</span> <span class="n">h2</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">waitNSlots</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The first thing we have to do is to activate the wallets using the monadic function <em>activateContractWallet</em>. We bind the result of this function to <em>h1</em>, and then bind the result of
a second call (for Wallet 2) to <em>h2</em>. Those two values - <em>h1</em> and <em>h2</em> are handles to their respective wallets.</p>
<p>Next, we use <em>callEndpoint</em> to simulate Wallet 1 calling the <em>give</em> endpoint, with the shown parameters. We then wait for 20 slots. The function <em>waitUntilSlot</em> actually returns
a value representing the slot that was reached, but, as we are not interested in that value here, we use <em>void</em> to ignore it. We then simulate the call to the <em>grab</em> endpoint
by Wallet 2.</p>
<p>Now, we can write a function to call <em>runEmulatorTraceIO</em> with out <em>Trace</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace</span>
</pre></div>
</div>
<p>And, we can then run this in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="n">test</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;give&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;gpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1000.0</span><span class="p">),(</span><span class="s2">&quot;gpBeneficiary&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s2">&quot;gpDeadline&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;getSlot&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">20.0</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">49</span><span class="n">f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">49</span><span class="n">f326a21c09ba52eddee46b65bdb5fb33b3444745e9af1510a68f9043696eba</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;made a gift of 1000 lovelace to 39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f with deadline Slot {getSlot = 20}&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">5</span>
<span class="n">Slot</span> <span class="mi">00005</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">6</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">7</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">8</span>
<span class="n">Slot</span> <span class="mi">00008</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">9</span>
<span class="n">Slot</span> <span class="mi">00009</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">10</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">11</span>
<span class="n">Slot</span> <span class="mi">00011</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">12</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">13</span>
<span class="n">Slot</span> <span class="mi">00013</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">14</span>
<span class="n">Slot</span> <span class="mi">00014</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">15</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">16</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">17</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">18</span>
<span class="n">Slot</span> <span class="mi">00018</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">19</span>
<span class="n">Slot</span> <span class="mi">00019</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">20</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;grab&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[])]))])</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">d9a2028384b4472242371f27cb51727f5c7c04327972e4278d1f69f606019a8b</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">21</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;collected gifts&quot;</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">22</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99998990</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000990</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>This output is very similar to the output we see in the playground. We can see the Genesis transaction as well as both the <em>give</em> and <em>grab</em> transactions from the <em>Trace</em>. We can also see
some log output from the contract itself, prefixed with <em>CONTRACT LOG</em>.</p>
<p>We can also log from inside the <em>Trace</em> monad. We could, for example, lof the result of the final <em>waitNSlots</em> call:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="o">...</span>
<span class="o">...</span>
<span class="nf">s</span> <span class="ow">&lt;-</span> <span class="n">waitNSlots</span> <span class="mi">1</span>
<span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;reached slot &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span>
</pre></div>
</div>
<p>We would then see this output when we run the emulation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">21</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="n">reached</span> <span class="n">slot</span> <span class="n">Slot</span> <span class="p">{</span><span class="n">getSlot</span> <span class="o">=</span> <span class="mi">21</span><span class="p">}</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;collected gifts&quot;</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">22</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Now let’s look at the Contract Monad.</p>
</div>
<div class="section" id="the-contract-monad">
<h4><span class="section-number">1.4.3.2. </span>The Contract Monad<a class="headerlink" href="#the-contract-monad" title="Permalink to this headline">¶</a></h4>
<p>The purpose of the Contract Monad is to define off-chain code that runs in the wallet. It has four type parameters:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Contract</span> <span class="p">{</span> <span class="n">unContract</span> <span class="ow">::</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">ContractEffs</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span><span class="p">)</span> <span class="n">a</span> <span class="p">}</span>
      <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Applicative</span><span class="p">,</span> <span class="kt">Monad</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>a</em> is the same as in every Monad - it denotes the result type of the computation.</p>
<p>We will go into the other three in more detail later but just briefly:</p>
<ul class="simple">
<li><p>w is like our Writer monad example, it allows us to write log messages of type <em>w</em>.</p></li>
<li><p>s describes the blockchain capabilities, e.g. waiting for a slot, submitting transactions, getting the wallet’s public key. It can also contain specific endpoints.</p></li>
<li><p>e describes the type of error messages that this monad can throw.</p></li>
</ul>
<p>Let’s write an example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract1</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract1</span> <span class="ow">=</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;Hello from the contract!&quot;</span>
</pre></div>
</div>
<p>Here, we pass a <em>Contract</em> constructed with <em>Unit</em> as the <em>w</em> type and <em>BlockchainActions</em> as the second argument, <em>s</em>. This gives us access to all the blockchain actions - the only thing we can’t do is to call specific endpoints.</p>
<p>For <em>e</em> - the error message type, we use <em>Text</em>. <em>Text</em> is a Haskell type which is like <em>String</em>, but it is much more efficient.</p>
<p>We don’t want a specific result, so we use <em>Unit</em> for the type <em>a</em>.</p>
<p>For the function body, we write a log message. We use <em>&#64;String</em> because, we have imported the type <em>Data.Text</em> and we have used the <em>OverloadedStrings</em> GHC compiler option,
so the compiler needs to know what type we are referencing - a <em>Text</em> or a <em>String</em>. We can use <em>&#64;String</em> if we also use the compiler option <em>TypeApplications</em>.</p>
<p>Let’s now define a <em>Trace</em> that starts the contract in the wallet, and a <em>test</em> function to run it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace1</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace1</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract1</span>

<span class="nf">test1</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test1</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace1</span>
</pre></div>
</div>
<p>If we run this in the REPL, we will see our log message from the contract.</p>
<p>Now, let’s throw an exception.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract1</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract1</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">throwError</span> <span class="s">&quot;BOOM!&quot;</span>
<span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;Hello from the contract!&quot;</span>
</pre></div>
</div>
<p>Recall that we chose the type <em>Text</em> as the error message.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test1</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">STOPPED</span> <span class="n">WITH</span> <span class="n">ERROR</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">BOOM!</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>Now, we don’t get the log message, but we do get told that the contract stopped with an error and we see our exception message.</p>
<p>Another thing you can do is to handle exceptions. We will use the <em>handleError</em> function from module <em>Plutus.Contract.Types</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handleError</span> <span class="ow">::</span>
      <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">e&#39;</span> <span class="n">a</span><span class="o">.</span>
      <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e&#39;</span> <span class="n">a</span><span class="p">)</span>
      <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span>
      <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e&#39;</span> <span class="n">a</span>
<span class="nf">handleError</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Contract</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Contract</span> <span class="n">c&#39;</span> <span class="kr">where</span>
      <span class="n">c&#39;</span> <span class="ow">=</span> <span class="kt">E</span><span class="o">.</span><span class="n">handleError</span> <span class="o">@</span><span class="n">e</span> <span class="p">(</span><span class="n">raiseUnderN</span> <span class="o">@</span><span class="kt">&#39;[E.Error e&#39;]</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">unContract</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>handleError</em> function takes an error handler and a <em>Contract</em> instance. The error handler takes an argument of type <em>e</em> from our contract,
and returns a new <em>Contract</em> with the same type parameters as the first, but we can change the type of the <em>e</em> argument - the error type, which is expressed in the
return <em>Contract</em> argument list as <em>e’</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract2</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Void</span> <span class="nb">()</span>
<span class="nf">myContract2</span> <span class="ow">=</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">handleError</span>
      <span class="p">(</span><span class="nf">\</span><span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logError</span> <span class="o">$</span> <span class="s">&quot;Caught error: &quot;</span> <span class="o">++</span> <span class="n">unpack</span> <span class="n">err</span><span class="p">)</span>
      <span class="n">myContract1</span>

<span class="nf">myTrace2</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace2</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract2</span>

<span class="nf">test2</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test2</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace2</span>
</pre></div>
</div>
<p>We use the type <em>Void</em> as the error type. <em>Void</em> is a type that can hold no value, so, by using this type we are saying that there cannot be any errors for this contract.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The function <em>unpack</em> is defined in the <em>Data.Text</em> module. It converts a value of type <em>Text</em> to a value of type <em>String</em>.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test2</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Caught error: BOOM!&quot;</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">stopped</span> <span class="p">(</span><span class="n">no</span> <span class="n">errors</span><span class="p">)</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="o">...</span>
</pre></div>
</div>
<p>We no longer get the error message, but, instead we get a message from the error handler showing the exception that was thrown by Contract1. Note that we still do not get the message
“Hello from the contract!”. Contract 1 still stopped processing after its error, but there was no overall contract error due to the exception being caught and handled.</p>
<p>Of course, exceptions can also happen even if they are not explicitly thrown by your contract code. There are operations, such as submitting a transaction where there are insufficient
inputs to make a payment for an output, where Plutus will throw an exception.</p>
<p>Next, let’s look at the <em>s</em> parameter, the second parameter to <em>Contract</em>, that determines the available blockchain actions.</p>
<p>In the first two examples we just used the <em>BlockChainActions</em> type which has all the standard functionality but without support for specific endpoints. If we want support for
specific endpoints, we must use a different type.</p>
<p>The way that is usually done is by using a type synonym. The following example will create a type synonym <em>MySchema</em> that has all the capabilities of <em>BlockChainActions</em> but
with the addition of being able to call endpoint <em>foo</em> with an argument of type <em>Int</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">MySchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;foo&quot;</span> <span class="kt">Int</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The operator <em>.\/</em> is a type operator - it operates on types, not values. In order to use this we need to use the <em>TypeOperators</em> and <em>DataKinds</em> compiler options.</p>
</div>
<p>Now, we can use the <em>MySchema</em> type to define our contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract3</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">MySchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract3</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;foo&quot;</span>
      <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="n">n</span>
</pre></div>
</div>
<p>This contract will block until the endpoint <em>foo</em> is called with, in our case, an <em>Int</em>. Then the value of the <em>Int</em> parameter will be bound to <em>n</em>.
Because of this, it is no longer enough for us to just activate the contract to test it. Now, we must invoke the endpoint as well.</p>
<p>In order to do this, we now need to handle from <em>activateContractWallet</em>, which we can then use to call the endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace3</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace3</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="n">h</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract3</span>
      <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;foo&quot;</span> <span class="n">h</span> <span class="mi">42</span>

<span class="nf">test3</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test3</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace3</span>
</pre></div>
</div>
<p>Running this in the REPL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test3</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="o">...</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;foo&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">42.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">log</span><span class="p">:</span> <span class="n">Number</span> <span class="mf">42.0</span>
<span class="o">...</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
<span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>Finally, let’s look at the first type parameter, the writer. The <em>w</em> cannot be an arbitrary type, it must be an instance of the type class <em>Monoid</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Trace</span> <span class="kt">Wallet</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">Stream</span> <span class="kt">Week04</span><span class="o">.</span><span class="kt">Contract</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Monoid</span>
<span class="kr">type</span> <span class="kt">Monoid</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="kr">where</span>
<span class="nf">mempty</span> <span class="ow">::</span> <span class="n">a</span>
<span class="nf">mappend</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">mconcat</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL mempty #-}</span>
      <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Ordering</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">d</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span>
      <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=&gt;</span>
      <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">-- Defined in ‘GHC.Base’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="nb">()</span> <span class="c1">-- Defined in ‘GHC.Base’</span>
</pre></div>
</div>
<p>This is a very important and very common type class in Haskell. It defines <em>mempty</em> and <em>mappend</em>.</p>
<p>The function <em>mempty</em> is like the neutral element, and <em>mappend</em> combines two elements of this type to create a new element of the same type.</p>
<p>The prime example of a <em>Monoid</em> is <em>List</em>, when <em>mempty</em> is the empty list <em>[]</em>, and <em>mappend</em> is concatenation <em>++</em>.</p>
<p>For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">mempty</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="kt">[]</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">mappend</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>The are many, many other examples of the <em>Monoid</em> type, and we will see other instances in this course.</p>
<p>But for now, let’s stick with lists and write our last example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myContract4</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">myContract4</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">tell</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">tell</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Rather than using <em>Unit</em> as our <em>w</em> type, we are using <em>[Int]</em>. This allows us to use the <em>tell</em> function as shown.</p>
<p>This now gives us access to those messages during the trace, using the <em>observableState</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace4</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace4</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">h</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">myContract4</span>

    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
    <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="n">show</span> <span class="n">xs</span>

    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">ys</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="n">show</span> <span class="n">ys</span>

    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
    <span class="n">zs</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="n">show</span> <span class="n">zs</span>

<span class="nf">test4</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test4</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="n">myTrace4</span>
</pre></div>
</div>
<p>If we run this in the REPL, we can see the <em>USER LOG</em> messages created using the <em>tell</em> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Trace</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Plutus</span><span class="o">.</span><span class="n">Contract</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Trace</span> <span class="n">Wallet</span><span class="o">.</span><span class="n">Emulator</span><span class="o">.</span><span class="n">Stream</span> <span class="n">Week04</span><span class="o">.</span><span class="n">Contract</span><span class="o">&gt;</span> <span class="n">test4</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00005</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">6</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">7</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="p">[]</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">8</span>
<span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">16</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">17</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">18</span>
<span class="o">...</span>
<span class="n">Slot</span> <span class="mi">00025</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">26</span>
<span class="n">Slot</span> <span class="mi">00026</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00026</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">27</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>Using this mechanism, it is possible to pass information from the contract running in the wallet to the outside world. Using endpoints we can pass information into a contract.
And using the <em>tell</em> mechanism we can get information out of the wallet.</p>
</div>
</div>
</div>
<div class="section" id="week-05-native-tokens">
<h2><span class="section-number">1.5. </span>Week 05 - Native Tokens<a class="headerlink" href="#week-05-native-tokens" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://youtu.be/6VbhY162GQA">Lecture
#5</a>.</p>
<p>In this lecture we learn about native tokens, minting policies and NFTs.</p>
<p>These notes use Plutus commit 0c3c310cab61dbff8cbc1998a3678b367be6815a</p>
</div>
<div class="section" id="id5">
<h3><span class="section-number">1.5.1. </span>Overview<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>We are going to talk about how Plutus supports native tokens and how to define under which conditions native tokens can be minted and burned. But before we get to that,
let’s explore what <em>value</em> means in Cardano.</p>
<p>When we talked about the (E)UTxO model, we learned that each UTxO (unspent transaction) has an address and a value. And, we saw that, as a result of being extended to the (E)UTxO model, each
UTxO also has a <em>Datum</em>. We have seen examples of such UTxOs in previous lectures.</p>
<p>In almost all the examples we have seen so far, the value was simply an Ada value, denominated in lovelace. The exception was the first example, from lecture 1, namely the <em>English Auction</em>
example. In that example we auctioned away an NFT. However, the NFT was just created out of thin air in the playground.</p>
<p>In the real Cardano blockchain, however, in the beginning there are only Ada, there are no other native tokens. So, you have to do something to create new native tokens, or to burn existing ones.
In this lecture we will see how to do that.</p>
<p>But let’s first talk above values.</p>
</div>
<div class="section" id="value">
<h3><span class="section-number">1.5.2. </span>Value<a class="headerlink" href="#value" title="Permalink to this headline">¶</a></h3>
<p>The relevant types are defined in package <em>plutus-ledger-api</em>. The modules of interest are</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.V1.Ledger.Value</span>
<span class="kr">module</span> <span class="nn">Plutus.V1.Ledger.Ada</span>
</pre></div>
</div>
<div class="section" id="the-value-type">
<h4><span class="section-number">1.5.2.1. </span>The Value Type<a class="headerlink" href="#the-value-type" title="Permalink to this headline">¶</a></h4>
<p><em>Value</em> is defined as a map from <em>CurrencySymbol*s to maps from *TokenName*s to *Integers</em>, which sounds a bit weird and complicated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Value</span> <span class="ow">=</span> <span class="kt">Value</span> <span class="p">{</span> <span class="n">getValue</span> <span class="ow">::</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">CurrencySymbol</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">TokenName</span> <span class="kt">Integer</span><span class="p">)</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">Hashable</span><span class="p">,</span> <span class="kt">NFData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Serialise</span><span class="p">,</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kt">Pretty</span> <span class="n">via</span> <span class="p">(</span><span class="kt">PrettyShow</span> <span class="kt">Value</span><span class="p">)</span>
</pre></div>
</div>
<p>The first thing to note is that each native token, including Ada, is identified by two pieces of data - the <em>CurrencySymbol</em> and the <em>TokenName</em>.</p>
<p>A <em>CurrencySymbol</em> is a <em>newtype</em> wrapper around a <em>ByteString</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CurrencySymbol</span> <span class="ow">=</span> <span class="kt">CurrencySymbol</span> <span class="p">{</span> <span class="n">unCurrencySymbol</span> <span class="ow">::</span> <span class="kt">Builtins</span><span class="o">.</span><span class="kt">ByteString</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">IsString</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Serialise</span><span class="p">,</span> <span class="kt">Pretty</span><span class="p">)</span> <span class="n">via</span> <span class="kt">LedgerBytes</span>
    <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Haskell</span><span class="o">.</span><span class="kt">Ord</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">Hashable</span><span class="p">,</span> <span class="kt">ToJSONKey</span><span class="p">,</span> <span class="kt">FromJSONKey</span><span class="p">,</span>  <span class="kt">NFData</span><span class="p">)</span>
</pre></div>
</div>
<p>And the same is true for <em>TokenName</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">TokenName</span> <span class="ow">=</span> <span class="kt">TokenName</span> <span class="p">{</span> <span class="n">unTokenName</span> <span class="ow">::</span> <span class="kt">Builtins</span><span class="o">.</span><span class="kt">ByteString</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Serialise</span><span class="p">)</span> <span class="n">via</span> <span class="kt">LedgerBytes</span>
    <span class="kr">deriving</span> <span class="n">stock</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kr">newtype</span> <span class="p">(</span><span class="kt">Haskell</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Haskell</span><span class="o">.</span><span class="kt">Ord</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="kt">IsData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="n">anyclass</span> <span class="p">(</span><span class="kt">Hashable</span><span class="p">,</span> <span class="kt">NFData</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kt">Pretty</span> <span class="n">via</span> <span class="p">(</span><span class="kt">PrettyShow</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>So we have these two <em>ByteStrings</em> that define a coin, or, as it is also called, an <em>asset class</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assetClass</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">AssetClass</span>
<span class="nf">assetClass</span> <span class="n">s</span> <span class="n">t</span> <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Ada is one asset class, and custom native tokens will be other asset classes.</p>
<p>A <em>Value</em> simply shows how many units exist for a given asset class.</p>
<p>Let’s start the REPL and import the two relevant modules.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cabal</span> <span class="n">repl</span>
<span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Ada</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Plutus.V1.Ledger.Value</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span>
<span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">set</span> <span class="o">-</span><span class="kt">XOverloadedStrings</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We have also activated the <em>OverloadedStrings</em> extension so that we can enter <a href="#id6"><span class="problematic" id="id7">*</span></a>ByteString*s as literal strings.</p>
</div>
<p>Now let’s look at some values. Let’s start with lovelace values. In the <em>Ledger.Ada</em> module there is a function called <em>adaSymbol</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">adaSymbol</span>
<span class="nf">adaSymbol</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
</pre></div>
</div>
<p>This gives us the currency symbol of the Ada asset class, which is just the empty <em>ByteString</em>. Similarly, there is a function <em>adaToken</em>, which will give us the token name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">adaToken</span>
<span class="nf">adaToken</span> <span class="ow">::</span> <span class="kt">TokenName</span>
</pre></div>
</div>
<p>Again, this is also the empty <em>ByteString</em>.</p>
<p>We have seen before in the examples how to construct a <em>Value</em> containing just lovelace. There is a function <em>lovelaceValueOf</em> that, given an <em>Integer</em>, gives us a <em>Value</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">lovelaceValueOf</span>
<span class="nf">lovelaceValueOf</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
</pre></div>
</div>
<p>So, for example to have 123 lovelace, we can do:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">123</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">123</span><span class="p">)])])</span>
</pre></div>
</div>
<p>You will always use a helper function such as <em>lovelaceValueOf</em> to construct the value maps - you would never need to construct one directly.</p>
<p>Here we see the map. The out map of currency symbols has one key, which is the empty symbol for Ada, and the inner map of token names has one key, the empty string for Ada,
and a value of 123.</p>
<p>One thing we can do with values is combine them. The <em>Value</em> class is an instance of <em>Monoid</em>, so we can use <em>mappend</em>, which we can write as <em>&lt;&gt;</em>, which comes from a super class of
<em>Monoid</em> called <em>Semigroup</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">123</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">10</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">133</span><span class="p">)])])</span>
</pre></div>
</div>
<p>So, how do we create <a href="#id8"><span class="problematic" id="id9">*</span></a>Value*s containing native tokens?</p>
<p>There is a very useful function called <em>singleton</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Ada</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">singleton</span>
<span class="nf">singleton</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
</pre></div>
</div>
<p>This will create a <em>Value</em> for a token specified by the <em>CurrencySymbol</em> and the <em>TokenName</em>, and for a given <em>Integer</em> amount.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span> <span class="mi">7</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(</span><span class="n">a8ff</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">)])])</span>
</pre></div>
</div>
<p>The first argument, “a8ff” for <em>CurrencySymbol” has to be a string representing a hexadecimal value, for reasons that will soon become clear. The second argument, “ABC”
for *TokenName</em> can be an arbitrary string.</p>
<p>And, we can combine, as before, with the <em>mappend</em> operator. We can now create a somewhat more interesting map.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span> <span class="mi">7</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">42</span> <span class="o">&lt;&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;XYZ&quot;</span> <span class="mi">100</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">42</span><span class="p">)]),(</span><span class="n">a8ff</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="s">&quot;XYZ&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Now, we see a map representing 42 lovelace as well as two tokens <em>ABC</em> and <em>XYZ</em> both belonging to the <em>CurrencySymbol</em> “af88”, and each with their respective integer amounts.</p>
<p>Let’s give this value a name:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span> <span class="mi">7</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="mi">42</span> <span class="o">&lt;&gt;</span> <span class="n">singleton</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;XYZ&quot;</span> <span class="mi">100</span>
<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">v</span>
<span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">42</span><span class="p">)]),(</span><span class="n">a8ff</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="s">&quot;XYZ&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Another useful function is <em>valueOf</em> which allows us to get the value of a given currency symbol and token name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">valueOf</span>
<span class="nf">valueOf</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">valueOf</span> <span class="n">v</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;XYZ&quot;</span>
<span class="mi">100</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">valueOf</span> <span class="n">v</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;ABC&quot;</span>
<span class="mi">7</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">valueOf</span> <span class="n">v</span> <span class="s">&quot;a8ff&quot;</span> <span class="s">&quot;abc&quot;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Another useful function is <em>flattenValue</em>. As the name suggests, it flattens the map of maps into a flat list of triples.</p>
<blockquote>
<div><div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">flattenValue</span>
<span class="nf">flattenValue</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span>

<span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">flattenValue</span> <span class="n">v</span>
<span class="p">[(</span><span class="n">a8ff</span><span class="p">,</span><span class="s">&quot;ABC&quot;</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="n">a8ff</span><span class="p">,</span><span class="s">&quot;XYZ&quot;</span><span class="p">,</span><span class="mi">100</span><span class="p">),(,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="mi">42</span><span class="p">)]</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="minting-policies">
<h3><span class="section-number">1.5.3. </span>Minting Policies<a class="headerlink" href="#minting-policies" title="Permalink to this headline">¶</a></h3>
<p>Now the question is why? Why do we need both a currency symbol and a token name? Why don’t we just use one identifier for an asset class? And why does the currency
symbol have to be in hexadecimal digits?</p>
<p>This is where so-called minting policies come in.</p>
<p>The rule is that, in general, a transaction can’t create or delete tokens. Everything that goes in also comes out, with the exception of the fees. There is always a lovelace feel
that has to be paid with each transaction. The fee depends on the size of the transaction and the number of steps that the validation script takes to execute, and the memory
consumption of the script.</p>
<p>But, if that was the whole story then we could never create native tokens. And this is where minting policies come in, and the relevance of the currency symbol comes in.</p>
<p>The reason that the currency symbol has to consist of hexadecimal digits is that it is actually the hash of a script. And this script is called the minting policy, and if
we have a transaction where we ant to create native or burn native tokens then, for each native token that we try to create or burn, the currency symbol is looked up. So, the
corresponding script must also be contained in the transaction. And that script is executed along with the other validation scripts.</p>
<p>And, similar to the validation scripts that we have seen so that validate input, the purpose of these minting scripts is to decide whether this transaction has the right to
mint or burn tokens. Ada also fits into this scheme. Remember the the currency symbol of Ada is just an empty string, which is not the hash of any scripts. So there is no
script that hashes to the empty string, so there is no script that would allow the minting or burning of Ada, which means that Ada can never be minted or burned.</p>
<p>All the Ada that exists comes from the Genesis transaction and the total amount of Ada in the system is fixed and can never change. Only custom native tokens can have custom minting policies.</p>
<p>So we’ll look at an example of a minting policy next and will see that it is very similar to a validation script, but not identical.</p>
<p>Before we write out first minting policy, let’s briefly recall how validation works.</p>
<p>When we don’t have a public key address, but a script address, and a UTxO that sits at that address, then for any transaction that tries to consume that UTxO, a validation script is run.</p>
<p>That validation script gets, as input, the datum, which comes from the UTxO, the redeemer, which comes from the input, and the context.</p>
<p>Recall that the <em>ScriptContext</em> has two fields.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptContext</span> <span class="ow">=</span> <span class="kt">ScriptContext</span><span class="p">{</span><span class="n">scriptContextTxInfo</span> <span class="ow">::</span> <span class="kt">TxInfo</span><span class="p">,</span> <span class="n">scriptContextPurpose</span> <span class="ow">::</span> <span class="kt">ScriptPurpose</span> <span class="p">}</span>
</pre></div>
</div>
<p>One of those fields is <em>ScriptPurpose</em>, and, for this field, everything we have seen until now has been of type <em>Spending</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ScriptPurpose</span>
    <span class="ow">=</span> <span class="kt">Minting</span> <span class="kt">CurrencySymbol</span>
    <span class="o">|</span> <span class="kt">Spending</span> <span class="kt">TxOutRef</span>
    <span class="o">|</span> <span class="kt">Rewarding</span> <span class="kt">StakingCredential</span>
    <span class="o">|</span> <span class="kt">Certifying</span> <span class="kt">DCert</span>
</pre></div>
</div>
<p>The other field is of type <em>TxInfo</em> which contains all the context information about the transaction.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | A pending transaction. This is the view as seen by validator scripts, so some details are stripped out.</span>
<span class="kr">data</span> <span class="kt">TxInfo</span> <span class="ow">=</span> <span class="kt">TxInfo</span>
    <span class="p">{</span> <span class="n">txInfoInputs</span>      <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span> <span class="c1">-- ^ Transaction inputs</span>
    <span class="p">,</span> <span class="n">txInfoInputsFees</span>  <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span>     <span class="c1">-- ^ Transaction inputs designated to pay fees</span>
    <span class="p">,</span> <span class="n">txInfoOutputs</span>     <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">]</span> <span class="c1">-- ^ Transaction outputs</span>
    <span class="p">,</span> <span class="n">txInfoFee</span>         <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The fee paid by this transaction.</span>
    <span class="p">,</span> <span class="n">txInfoForge</span>       <span class="ow">::</span> <span class="kt">Value</span> <span class="c1">-- ^ The &#39;Value&#39; forged by this transaction.</span>
    <span class="p">,</span> <span class="n">txInfoDCert</span>       <span class="ow">::</span> <span class="p">[</span><span class="kt">DCert</span><span class="p">]</span> <span class="c1">-- ^ Digests of certificates included in this transaction</span>
    <span class="p">,</span> <span class="n">txInfoWdrl</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">StakingCredential</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)]</span> <span class="c1">-- ^ Withdrawals</span>
    <span class="p">,</span> <span class="n">txInfoValidRange</span>  <span class="ow">::</span> <span class="kt">SlotRange</span> <span class="c1">-- ^ The valid range for the transaction.</span>
    <span class="p">,</span> <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">]</span> <span class="c1">-- ^ Signatures provided with the transaction, attested that they all signed the tx</span>
    <span class="p">,</span> <span class="n">txInfoData</span>        <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)]</span>
    <span class="p">,</span> <span class="n">txInfoId</span>          <span class="ow">::</span> <span class="kt">TxId</span>
    <span class="c1">-- ^ Hash of the pending transaction (excluding witnesses)</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
</pre></div>
</div>
<p>For minting policies, this is triggered if the <em>txInfoForge</em> field of the transaction contains a non-zero value. In all of the transactions we have seen so far, this field value
has been zero - we have never created or destroyed any tokens.</p>
<p>If it <em>is</em> non-zero, then for each currency symbol contained in the <em>Value</em>, the corresponding minting policy script is run.</p>
<p>Whereas the validation scripts had three inputs - the datum, the redeemer and the context, these minting policy scripts only have one input - the context.
And it is the same context as we had before - the <em>ScriptContext</em>. It would make no sense to have the datum, as it belongs to the UTxO, and it would make no sense to have
the redeemer as it belongs to the validation script. The minting policy belongs to the transaction itself, not to a specific input or output.</p>
<p>As for the <em>ScriptPurpose</em>, this will not be <em>Spending</em> as it has been until now, but will be <em>Minting</em>.</p>
</div>
<div class="section" id="example-1-free">
<h3><span class="section-number">1.5.4. </span>Example 1 - Free<a class="headerlink" href="#example-1-free" title="Permalink to this headline">¶</a></h3>
<p>Let’s write a simple minting policy.</p>
<div class="section" id="id10">
<h4><span class="section-number">1.5.4.1. </span>On chain<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>When we wrote a validator we had a function such as the following:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkValidator</span> <span class="ow">::</span> <span class="kt">Datum</span> <span class="ow">-&gt;</span> <span class="kt">Redeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>We also saw the low-level version where we had three <em>Data</em> arguments and returned <em>Unit</em>. And we saw that there can be additional arguments before the datum, if we
write a parameterized script.</p>
<p>We can also have parameterized minting policy scripts and we will see that in a later example. But first we will look at one that is not parameterized.</p>
<p>First, let’s rename the function to <em>mkPolicy</em>, remove the datum and redeemer, and write the simplest minting policy that we can.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>This policy ignores the context and always returns <em>True</em>. This will allow arbitrary minting and burning of tokens for and token name that belongs to the currency symbol
associated with this policy.</p>
<p>Remember that, when we were writing a validator, we needed to use Template Haskell to compile this function to Plutus code. We need to do something similar for our minting policy.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">policy</span> <span class="ow">::</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">MonetaryPolicy</span>
<span class="nf">policy</span> <span class="ow">=</span> <span class="n">mkMonetaryPolicyScript</span> <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapMonetaryPolicy</span> <span class="n">mkPolicy</span> <span class="o">||</span><span class="p">])</span>
</pre></div>
</div>
<p>And, as before, we need to make the <em>mkPolicy</em> function <em>INLINABLE</em>, as everything within the Oxford brackets needs to be available at compile time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkPolicy #-}</span>
<span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Now that we have a policy, we can get a currency symbol from the policy.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">curSymbol</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
<span class="nf">curSymbol</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="n">policy</span>
</pre></div>
</div>
<p>And, we can look at this in the REPL:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="n">curSymbol</span>
<span class="nf">e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf</span>
</pre></div>
</div>
<p>And this completes the on-chain part, for this simple minting policy. But in order to try it out and interact with it, we need an off-chain part.</p>
</div>
<div class="section" id="id11">
<h4><span class="section-number">1.5.4.2. </span>Off chain<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>What should the off-chain part do? Well, it should allow arbitrary wallets to mint and burn tokens of this currency symbol.</p>
<p>We have the currency symbol, so what is missing is the token name and the amount we want to mint or burn. And for this, we will define a data type <em>MintParams</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">MintParams</span> <span class="ow">=</span> <span class="kt">MintParams</span>
    <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>We see two fields - <em>mpTokenName</em> and <em>mpAmount</em>. The idea is that if the <em>mpAmount</em> is positive, we should create tokens, and if it is negative, we should burn tokens.</p>
<p>The next step is to define the schema. Recall that one of the parameters of the <em>Contact</em> monad was the schema that defined the available actions that we can take.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">FreeSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;mint&quot;</span> <span class="kt">MintParams</span>
</pre></div>
</div>
<p>As always, we have <em>BlockchainActions</em> that give us access generic things like getting your own public key. And here, we have added an endpoint <em>mint</em> using the type-level operator
we have seen previously.</p>
<p>So, now we can look at the contract itself.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">MintParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">FreeSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
</pre></div>
</div>
<p>In the past, we have not gone into detail with the off-chain part of the contract. But, as we now know about the <em>Contract</em> monad from the last lecture, we are ready to go into it
in much more detail.</p>
<p>Recall that the <em>Contract</em> monad takes four type parameters.</p>
<p>The first is the writer monad which allows us to use a <em>tell</em> function. By leaving this parametric with a small
<em>w</em>, we indicate that we will not be making use of this parameter - we won’t <em>tell</em> any state.</p>
<p>The next parameter is the schema that we just discussed. As noted above, by using <em>FreeSchema</em> we have access to the regular block chain actions, as well as the <em>mint</em> endpoint.</p>
<p>The third parameter is the type of error message, and as we have seen, <em>Text</em> is usually a good choice.</p>
<p>Finally the last parameter is the return type, and our contract will just have the Unit return type.</p>
<p>Now the function body. As <em>Contact</em> is a monad, we can use <em>do</em> notation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="n">mp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">curSymbol</span> <span class="p">(</span><span class="n">mpTokenName</span> <span class="n">mp</span><span class="p">)</span> <span class="p">(</span><span class="n">mpAmount</span> <span class="n">mp</span><span class="p">)</span>
        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="n">policy</span>
        <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;forged %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>The first thing that we define is the value that we want to forge. For this we are using the <em>singleton</em> function that we tried out in the REPL earlier.</p>
<p>The arguments to the <em>singleton</em> function are the currency symbol that represents the hash of the minting policy, plus the token name and amount extracted from the <em>MintParams</em>.</p>
<p>We’ll skip the <em>lookups</em> assignment for the moment, and move onto the <em>tx</em> assignment.</p>
<p>One of the main purposes of the <em>Contract</em> monad is to construct and submit transactions. The path that the Plutus team has taken to do that is provide a way to specify
the constraints of the transaction you are defining. The Plutus libraries then take care of constructing the correct transaction (if possible). This is as opposed to being require to specify
all the inputs and outputs manually, which would be tedious as many requirements, such as sending change back to the sending wallet, are often the same.</p>
<p>These conditions all have names that start with <em>must</em>. There are things like <em>mustSpendScriptOutput</em>, <em>mustPayToPublicKey</em> and all sorts of conditions that can be put
on a condition.</p>
<p>In our example, we are using <em>mustForgeValue</em> and we pass it the previously-defined <em>val</em>. The result of forging the tokens specified by <em>val</em> is that they will end up
in our own wallet.</p>
<p>Once the conditions are defined, you then need to call a function to submit the transaction. There are a variety of such functions, but in this case, the appropriate one
is <em>submitTxConstraintsWith</em>.</p>
<p>These <em>submitTx</em> functions all take these declarative conditions that the transaction must satisfy, and then they try to construct a transaction that
fulfils those conditions. In our case, the only condition is that we want to forge the value.</p>
<p>So what must the <em>submitTxConstraintsWith</em> do in order to create a valid transaction? It must, for example balance the inputs and outputs. In this case, because we always
have transaction fees, we need an input that covers the transactions fees. So, to create the transaction, the function will look at our own UTxOs and find one, or more, that can
cover the transaction fees, and use them as an input to the transaction.</p>
<p>Furthermore, if we are forging value (if <em>mpAmount</em> is positive), that must go somewhere. In this case, <em>submitTxConstraintsWith</em>, will create an output that sends the
newly-minted value to our own wallet.</p>
<p>If, on the other hand, we were burning tokens (if <em>mpAmount</em> is negative), then those tokens must come from somewhere. In that case, the <em>submitTxConstraintsWith</em> function
would find an input in our own wallet from which to take the tokens.</p>
<p>The submit function can also fail. For example, if we want to pay someone, but we do not have enough funds in our wallet, it would fail. Or, if we are asking to burn tokens
that we don’t have, it will also fail. On failure, an exception would be thrown, with an error message of type <em>Text</em>.</p>
<p>Now, back to the <em>lookups</em>. In order to fulfil the conditions in the <em>mustForgeValue</em> function, and to construct the transaction, sometimes the library needs additional information.
In this case, in order to validate a transaction that forges value, the nodes that validate the transaction have to run the policy script.</p>
<p>But, the currency symbol is only the hash of the policy script. In order to run the script itself, it must be included in the transaction. Which means that, in the
construction step of the transaction, when the algorithm see the <em>mustForgeValue</em> constraint, it knows it has to attach the corresponding policy script to the transaction.</p>
<p>In order to tell the algorithm where the policy script is, we can give it hints, and these are the lookups. The are a variety of lookups that can be used - you can give
UTxOs, validator scripts, and, as we do here, you can give monetary policy scripts.</p>
<p>In our case, the only thing we need to supply as a lookup is the policy that we defined earlier in the script.</p>
<p>There are variants of <em>submitTxConstraintsWith</em> without the <em>with</em> that do not take lookups, as we have seen in previous lectures.</p>
<p>Finally, the <em>&#64;Void</em> on the line:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
</pre></div>
</div>
<p>Most of the constraint functions are geared towards using a specific validator script. Normally you have the situation that you are working on one specific smart contract.
And that specific smart contract has a datum and a redeemer type, and most of the constraints functions are parametric in the datum and redeemer type. In that case you
can directly use the datum type without first having to convert it to the Plutus <em>Datum</em> type.</p>
<p>But in this case, we are not making use of that. We don’t have any validator script. Which means that <em>submitTxConstraintsWith</em> wouldn’t know which type to use for datum and
redeemer because we don’t have them in this example. So, in that case we must tell the compiler which type to use. We don’t care, as there is no datum and redeemer, so we
use the <em>Void</em> type.</p>
<p>Also, in the same line, we see a monadic bind, so we know that this is a monadic action happening within the <em>Contract</em> monad. The reason for this is that, in order to lookup,
for example, our UTxOs, the <em>submitTxConstraintsWith</em> function must make use of the super power of the <em>Contract</em> monad, which is to access the <em>BlockchainActions</em>.</p>
<p>Now, <em>ledgerTx</em> is basically a handle to the transaction to we just submitted.</p>
<p>Then we wait for the transaction to be confirmed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
</pre></div>
</div>
<p>Currently, if the transaction validation fails, the await for confirmation line will block forever. However, this will soon change in an upcoming Plutus release to allow
us to listen for status changes, so you could detect if validation failed.</p>
<p>Once confirmed, we simply write a log message.</p>
<p>Finally, we need some more boilerplate to define our endpoint, to be able to actually execute the <em>mint</em> function, for example, in the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">FreeSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="n">mint&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">mint&#39;</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">mint</span>
</pre></div>
</div>
<p>We define another contract, <em>endpoints</em>, and that is always the name of the contract that the playground will run. So, if you want to test something in the playground, you
always need something called <em>endpoints</em>.</p>
<p>Here we just define a function called <em>mint’</em> and then recursively call <em>endpoints</em>, so once it has executed, it will be available to be executed again.</p>
<p>For <em>mint’</em> we must somehow get the <em>MintParams</em> and for that we use the <em>endpoint</em> function. The <em>endpoint</em> function blocks until someone provides a parameter. Once the
parameter of <em>MintParams</em> is provided, we use the monadic bind to call the <em>mint</em> function with those arguments.</p>
<p>The final two lines, as we have seen before, are just needed for the playground UI.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSchemaDefinitions</span> <span class="kt">&#39;&#39;FreeSchema</span>
<span class="nf">mkKnownCurrencies</span> <span class="kt">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h4><span class="section-number">1.5.4.3. </span>In The Playground<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>We have set up a scenario where Wallet 1 mints 555 ABC tokens, and Wallet 2 mints 444 ABC tokens. Then, after waiting for 1 slot, Wallet 1 burns 222 ABC tokens. Finally, we
wait for 1 slot at the end.</p>
<div class="figure align-default">
<img alt="_images/week05__00007.png" src="_images/week05__00007.png" />
</div>
<p>Now, if we evaluate this, first we see the genesis transaction where the wallets are given 1000 lovelace each.</p>
<div class="figure align-default">
<img alt="_images/week05__00008.png" src="_images/week05__00008.png" />
</div>
<p>Next, we see two transactions at Slot 1. The first is the transaction from Wallet 2, where 444 ABC tokens are minted, and a 10 lovelace fee is paid. The UTxO to pay the fees
was automatically found by the function that created the transaction <em>submitTxConstraintsWith</em>, as discussed previously.</p>
<p>We see something here that we have not seen before - the <em>Forge</em> part of a transaction, where the native tokens are actually created. The box contains the currency symbol (the
policy hash) and the token name.</p>
<p>We also see the two outputs - once with the 990 lovelace change, and another with the newly-minted tokens. These outputs could, in fact, be combined, but here they are shown
as two separate UTxOs.</p>
<div class="figure align-default">
<img alt="_images/week05__00009.png" src="_images/week05__00009.png" />
</div>
<p>Then, we see the transaction from Wallet 1, where 555 ABC tokens are minted, and a 10 lovelace fee is paid.</p>
<div class="figure align-default">
<img alt="_images/week05__00010.png" src="_images/week05__00010.png" />
</div>
<p>Finally, we see the burning of 222 tokens by Wallet 1. Here we see that the algorithm did something slightly different. When it notices that a burn is taking place, it has
found the ABC tokens UTxO in Wallet 1 and used them as an input. We also note here that the output UTxO is combined, which, as we mentioned above, can be done instead of
using two output UTxOs.</p>
<div class="figure align-default">
<img alt="_images/week05__00011.png" src="_images/week05__00011.png" />
</div>
<p>And we can also view the final balances to double check that all went according to plan.</p>
<div class="figure align-default">
<img alt="_images/week05__00012.png" src="_images/week05__00012.png" />
</div>
<p>With our monetary policy, we can create arbitrary forging and burning transactions by any wallet. So, this is probably not a very good monetary policy. The purpose of a
token is to represent value, but if anybody at any time can mint new tokens, this token will not make much sense. There might be some exotic use case for it, but realistically
this policy is rather useless.</p>
</div>
<div class="section" id="testing-with-emulatortrace">
<h4><span class="section-number">1.5.4.4. </span>Testing with EmulatorTrace<a class="headerlink" href="#testing-with-emulatortrace" title="Permalink to this headline">¶</a></h4>
<p>Let’s also test this from the command line, rather than in the playground.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">tn</span> <span class="ow">=</span> <span class="s">&quot;ABC&quot;</span>
    <span class="n">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h1</span> <span class="o">$</span> <span class="kt">MintParams</span>
        <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">=</span> <span class="n">tn</span>
        <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">=</span> <span class="mi">555</span>
        <span class="p">}</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h2</span> <span class="o">$</span> <span class="kt">MintParams</span>
        <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">=</span> <span class="n">tn</span>
        <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">=</span> <span class="mi">444</span>
        <span class="p">}</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h1</span> <span class="o">$</span> <span class="kt">MintParams</span>
        <span class="p">{</span> <span class="n">mpTokenName</span> <span class="ow">=</span> <span class="n">tn</span>
        <span class="p">,</span> <span class="n">mpAmount</span>    <span class="ow">=</span> <span class="o">-</span><span class="mi">222</span>
        <span class="p">}</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
</pre></div>
</div>
<p>If we run this in the REPL, we see what we saw in the playground, but instead on the console. It’s not as pretty, but it is quicker.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week05</span><span class="o">.</span><span class="n">Free</span><span class="o">&gt;</span> <span class="n">test</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">555.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">7</span><span class="n">c01d39fc031815eaf05d97709e4973a24dfa38e9dd68a4fd1ec92bb80cf76e4</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">444.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">6</span><span class="n">ba7eb4441992284e687d184080d4a8693e7b188fc45150d6e7ccd1243968f53</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">6</span><span class="n">ba7eb4441992284e687d184080d4a8693e7b188fc45150d6e7ccd1243968f53</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">7</span><span class="n">c01d39fc031815eaf05d97709e4973a24dfa38e9dd68a4fd1ec92bb80cf76e4</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,555)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,444)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="o">-</span><span class="mf">222.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">95</span><span class="n">d42e93ee41ab5bed7857b176be5a4e16602323eaacaa90f3bb807a9fd235c0</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">95</span><span class="n">d42e93ee41ab5bed7857b176be5a4e16602323eaacaa90f3bb807a9fd235c0</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,-222)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999980</span>
    <span class="p">{</span><span class="n">e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">333</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span><span class="n">e01824b4319351c40b5ec727fff328a82076b1474a6bad6c8e8a2cd835cc6aaf</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">444</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999990</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-2-signed">
<h3><span class="section-number">1.5.5. </span>Example 2 - Signed<a class="headerlink" href="#example-2-signed" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id13">
<h4><span class="section-number">1.5.5.1. </span>On-chain<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>Let’s look at a more realistic example.</p>
<p>We’ll take a copy of the Free module, and call it Signed.</p>
<p>Probably the easiest example of a realistic minting policy is one where the minting and burning of tokens is restricted to transactions that are signed by a specific
public key hash. That is similar to a central bank, in fiat currencies.</p>
<p>This means that our policies is no longer without parameters. We need the public key hash.  In addition, we are going to need to look at the context, so we can’t just ignore it like last time.</p>
<p>We recall that <em>scriptContextTxInfo</em> from the context contains a list of all the signatories of the transaction. So, we can use this to see if the required signatory is one
of them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="n">pkh</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">txSignedBy</span> <span class="p">(</span><span class="n">scriptContextTxInfo</span> <span class="n">ctx</span><span class="p">)</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>The <em>txSignedBy</em> function is a convenient way of checking this. In previous examples, we used the <em>elem</em> function to check that it existed in the list.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger</span>
<span class="kt">Prelude</span> <span class="kt">Ledger</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">txSignedBy</span>
<span class="nf">txSignedBy</span> <span class="ow">::</span> <span class="kt">TxInfo</span> <span class="ow">-&gt;</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Now, we need to update the part of the code that compiles our <em>mkPolicy</em> function into Plutus code. We will use the same techniques that we have used when writing
validator scripts. Specifically, we use the <em>applyCode</em> function to allows us to reference <em>pkh</em>, whose value is only known at runtime.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">policy</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">MonetaryPolicy</span>
<span class="nf">policy</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">mkMonetaryPolicyScript</span> <span class="o">$</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapMonetaryPolicy</span> <span class="o">.</span> <span class="n">mkPolicy</span> <span class="o">||</span><span class="p">])</span>
    <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>We also need to update the <em>curSymbol</em> function, as it now depends on the public key hash. It depends on it so that it can pass it to the <em>policy</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">curSymbol</span> <span class="ow">::</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">CurrencySymbol</span>
<span class="nf">curSymbol</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="o">.</span> <span class="n">policy</span>
</pre></div>
</div>
<p>Note, the second line here, the body, is a shorter way of writing:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">curSymbol</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>This is clear, when you consider something like the following, where <em>timesSix</em> is just another way of writing the results of combining the functions <em>timesTwo</em> and <em>timesThree</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">timesSix</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">timesTwo</span> <span class="o">$</span> <span class="n">timesThree</span> <span class="n">x</span>
</pre></div>
</div>
<p>is exactly the same as…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">timesSix</span> <span class="ow">=</span> <span class="n">timesTwo</span> <span class="o">.</span> <span class="n">timesThree</span>
</pre></div>
</div>
<p>This process of simplification is called ETA reduction, so if you ever see your IDE hinting that you can ETA reduce, this is what it’s talking about.</p>
<p>Now for the off-chain code.</p>
</div>
<div class="section" id="id14">
<h4><span class="section-number">1.5.5.2. </span>Off-chain<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>We don’t need to extend the <em>MintParams</em> data type for the off-chain code. A wallet that wants to mint or burn a currency can sign with its own public key hash. This is the only
signature that a wallet can provide, and it has the ability to look it up for itself.</p>
<p>We will make a change to the name of the schema for clarity. We’ll also, of course, update this name wherever it appears in the contract script.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">SignedSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;mint&quot;</span> <span class="kt">MintParams</span>
</pre></div>
</div>
<p>Now, for the <em>mint</em> function, we need to pass the public key hash to the <em>curSymbol</em> function. Getting hold of the public key is something that is provided by
<em>BlockchainActions</em>. So, we will get this from <em>Contract</em> and apply the <em>pubKeyHash</em> function to it.</p>
<p>One way to do this would be</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pk</span> <span class="ow">&lt;-</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
<span class="kr">let</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="n">pk</span>
</pre></div>
</div>
<p>However, as <em>Contract</em> is a monad, and therefore an instance of <em>Functor</em>, we have the <em>fmap</em> function available, which will turn a <em>Contract a</em> into a <em>Contract b</em>. In
this case we can take advantage of that by using the <em>pubKeyHash</em> function as the (a -&gt; b) function of fmap and this will turn <em>Contract pubKey</em> into <em>Contract pubKeyHash</em>,
and then we can grab this value instead.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="n">pubKeyHash</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
</pre></div>
</div>
<p>There is one more thing we can do to improve this. There is an operator for <em>fmap</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
</pre></div>
</div>
<p>Ok, now let’s update the lookups line to pass in the public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">pkh</span>
</pre></div>
</div>
<p>And now we have finished modifying the <em>mint</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">MintParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">SignedSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">mp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="n">curSymbol</span> <span class="n">pkh</span><span class="p">)</span> <span class="p">(</span><span class="n">mpTokenName</span> <span class="n">mp</span><span class="p">)</span> <span class="p">(</span><span class="n">mpAmount</span> <span class="n">mp</span><span class="p">)</span>
        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">pkh</span>
        <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;forged %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>So, let’s try it out using the <em>test</em> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Ledger</span> <span class="n">Week05</span><span class="o">.</span><span class="n">Signed</span><span class="o">&gt;</span> <span class="n">Week05</span><span class="o">.</span><span class="n">Signed</span><span class="o">.</span><span class="n">test</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">555.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mf">20289e7</span><span class="n">b1bb6692b35e24e0f9293327f9169d843ae0ea431186fdefae6092a44</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">444.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">1</span><span class="n">c367cf81dd2da478abb96235ee16facf9f7d47374c9455d5fdd516aaf04d0c2</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">1</span><span class="n">c367cf81dd2da478abb96235ee16facf9f7d47374c9455d5fdd516aaf04d0c2</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mf">20289e7</span><span class="n">b1bb6692b35e24e0f9293327f9169d843ae0ea431186fdefae6092a44</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(7183b1cf81e44b26c558ddf442c4a7161a1b504b61136a8773dc2e4960323521,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,555)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(2a964fa6314803cf1b61165aeb1d758e355aae9480a29e282b58e76983f101ba,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,444)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
<span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;mint&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;mpAmount&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="o">-</span><span class="mf">222.0</span><span class="p">),(</span><span class="s2">&quot;mpTokenName&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;ABC&quot;</span><span class="p">)]))]))]))])</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mf">6e20</span><span class="n">d243447d7f49de509ef6b52c6d947769d95a6451c9cda53e42a0ba02fa69</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mf">6e20</span><span class="n">d243447d7f49de509ef6b52c6d947769d95a6451c9cda53e42a0ba02fa69</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;forged Value (Map [(7183b1cf81e44b26c558ddf442c4a7161a1b504b61136a8773dc2e4960323521,Map [(</span><span class="se">\&quot;</span><span class="s2">ABC</span><span class="se">\&quot;</span><span class="s2">,-222)])])&quot;</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999980</span>
    <span class="p">{</span><span class="mi">7183</span><span class="n">b1cf81e44b26c558ddf442c4a7161a1b504b61136a8773dc2e4960323521</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">333</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span><span class="mi">2</span><span class="n">a964fa6314803cf1b61165aeb1d758e355aae9480a29e282b58e76983f101ba</span><span class="p">,</span> <span class="s2">&quot;ABC&quot;</span><span class="p">}:</span> <span class="mi">444</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">99999990</span>
<span class="o">...</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>This looks very similar to before, but this time, notice that, while the token names are the same, the currency symbols are different for each wallet.</p>
</div>
</div>
<div class="section" id="nfts">
<h3><span class="section-number">1.5.6. </span>NFTs<a class="headerlink" href="#nfts" title="Permalink to this headline">¶</a></h3>
<p>Let’s now talk about NFTs - Non-Fungible Tokens. NFTs are tokens that have a quantity of exactly 1.</p>
<p>The examples of native tokens that we have studied so far are definitely not NFTs because we could easily mint as many as we wanted. This is true not only in the first
example where anyone could mint tokens, but also in the second example, where, so long as you are the owner of the correct public key hash, you could mint unlimited tokens
for the associated currency symbol and token name.</p>
<p>In order to produce an NFT, perhaps the first naive idea would be to look at forge field in the policy and enforce a policy where the amount is one.</p>
<p>But that wouldn’t help us. That would only mean that during one transaction you can mint only one token. But nobody could stop us from submitting as many of those transactions
as we like.</p>
<p>The second option is actually in use already on the Cardano blockchain. NFTs have been available since the Mary fork, which predates Plutus, and to do this, they are implemented
using deadlines.</p>
<p>We saw in previous examples how time can be incorporated in validation scripts, and the same can be done in policy scripts.</p>
<p>The idea here is to only allow minting before a given deadline has passed. Using this method, if you want to mint an NFT, you mint one token before the deadline, then allow the
deadline to pass. This guarantees that, after the deadline, no new tokens will ever be minted.</p>
<p>But, in order to check that you only minted one token before the deadline, you need something like a blockchain explorer. So, in this sense, they are not true NFTs, insofar as
the currency symbol itself guarantees that they are unique.</p>
<p>Using Plutus, it is possible to mint true NFTs. If you know the policy script that corresponds to the currency symbol, you can be sure that only one token is in existence
without having to resort to something like a blockchain explorer.</p>
<p>And, thinking about how to do that, there must be a way to prevent there ever being more than one minting transaction for the token in question. Whatever you write in your
policy script, it must only return true for one transaction, so that it is impossible to do the same again in another transaction.</p>
<p>At first, this sounds impossible. Why can’t you just run the same transaction again and have validation succeed again? Even considering deadlines, what stops a second transaction
in the same slot from passing validation?</p>
<p>The key here is that we need something unique. Something that can only exist in one transaction and never again. This is an important trick, and it is something to keep in mind.</p>
<p>The idea is to use UTxOs. A UTxO is unique. A UTxO is the output of a transaction and its unique identifier is the transaction ID and its index in the list of outputs from that transaction.</p>
<p>The reason that transactions are unique is a bit subtle. They would not necessarily be unique if it were not for fees. Without fees, you could have a transaction that has
zero inputs and only with outputs without value. Such a transaction would have the exact some hash each time it was run, and therefore the exact same transaction id. But with
fees, such a transaction cannot exist, as you always need an input that provides fees, and the fees can never come from the same UTxO as input.</p>
<p>So, to create an NFT, we are going to provide a specific UTxO as a parameter to the minting policy and, in the policy, we are going to check that the transaction consumes this
UTxO. And, as we have just noted, once that UTxO is consumed, it can never be consumed again.</p>
<div class="section" id="example-3-nft">
<h4><span class="section-number">1.5.6.1. </span>Example 3 - NFT<a class="headerlink" href="#example-3-nft" title="Permalink to this headline">¶</a></h4>
<p>We start with a copy of the previous example, <em>Signed</em> and we will call it <em>NFT</em>.</p>
<p>So let’s turn the signed policy into a true NFT policy.</p>
<p>First, we will no longer use the public key hash as an input, as if we were a central bank, but will use a UTxO instead. So, what type corresponds to a UTxO?</p>
<p>Let’s look in the REPL and remind ourselves about <em>TxInfo</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger</span>
<span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Ledger</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">TxInfo</span>
<span class="kr">type</span> <span class="kt">TxInfo</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">TxInfo</span>
    <span class="ow">=</span> <span class="kt">TxInfo</span> <span class="p">{</span><span class="n">txInfoInputs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">],</span>
                <span class="n">txInfoInputsFees</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">],</span>
                <span class="n">txInfoOutputs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxOut</span><span class="p">],</span>
                <span class="n">txInfoFee</span> <span class="ow">::</span> <span class="kt">Value</span><span class="p">,</span>
                <span class="n">txInfoForge</span> <span class="ow">::</span> <span class="kt">Value</span><span class="p">,</span>
                <span class="n">txInfoDCert</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">DCert</span><span class="o">.</span><span class="kt">DCert</span><span class="p">],</span>
                <span class="n">txInfoWdrl</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Credential</span><span class="o">.</span><span class="kt">StakingCredential</span><span class="p">,</span>
                                <span class="kt">Integer</span><span class="p">)],</span>
                <span class="n">txInfoValidRange</span> <span class="ow">::</span> <span class="kt">SlotRange</span><span class="p">,</span>
                <span class="n">txInfoSignatories</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">PubKeyHash</span><span class="p">],</span>
                <span class="n">txInfoData</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">DatumHash</span><span class="p">,</span> <span class="kt">Datum</span><span class="p">)],</span>
                <span class="n">txInfoId</span> <span class="ow">::</span> <span class="kt">TxId</span><span class="p">}</span>
</pre></div>
</div>
<p>We we are interested in this field:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">txInfoInputs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">TxInInfo</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s look at the type <em>TxInInfo</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Ledger</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">TxInInfo</span>
<span class="kr">type</span> <span class="kt">TxInInfo</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">data</span> <span class="kt">TxInInfo</span>
    <span class="ow">=</span> <span class="kt">TxInInfo</span> <span class="p">{</span><span class="n">txInInfoOutRef</span> <span class="ow">::</span> <span class="kt">TxOutRef</span><span class="p">,</span> <span class="n">txInInfoResolved</span> <span class="ow">::</span> <span class="kt">TxOut</span><span class="p">}</span>
</pre></div>
</div>
<p>We see that it is a record with two fields. The first is of type <em>TxOutRef</em>, and this references a UTxO, which is exactly what we need. So, let’s use it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Now, we are ready to write the logic. We must check that the script contains the specified UTxO as input. We will delegate this to a helper function. This function, which we
will call <em>hasUTxO</em> uses the <em>any</em> function, which is a standard Prelude function, but also has a Plutus version, for reasons we have addressed previously.</p>
<p>The <em>any</em> function takes a predicate (a function that returns a boolean) and applies it to an input collection of the type <em>Foldable</em> (a list, for example), and will
return true if the predicate is true for any of the inputs.</p>
<p>Here, we use the <em>any</em> function to see if any of the <em>txInInfoOutRef*s from the *txInfoInputs</em> from the <em>TxInfo</em> field of the context matches the UTxO for which
we are validating.</p>
<p>For clarity, we will also provide a helper function to get the list of <em>txInfoInputs</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
<span class="nf">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

<span class="nf">hasUTxO</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">hasUTxO</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">txInInfoOutRef</span> <span class="n">i</span> <span class="o">==</span> <span class="n">oref</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
</pre></div>
</div>
<p>So, do we have enough to finish writing our policy? Let’s see what we have.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="n">oref</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;UTxO not consumed&quot;</span> <span class="n">hasUTxO</span>
<span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">hasUTxO</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">hasUTxO</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">txInInfoOutRef</span> <span class="n">i</span> <span class="o">==</span> <span class="n">oref</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
</pre></div>
</div>
<p>Right now, we have a policy that can only mint or burn once. But, of course, in that single transaction, we can still mint as many tokens as we like.</p>
<p>Now, we think about what we actually want. Maybe we want a policy that allows us to mint just one token for the currency symbol. Or perhaps, we would like to be able
to mint many NFTs at once, each with a different token name.</p>
<p>It’s up to us. But, let’s say we go with the first option. We just want to mint one token.</p>
<p>So, it makes sense to pass the token name as a parameter.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>And we need a second condition that checks that we mint just this one specific coin.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="n">oref</span> <span class="n">tn</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;UTxO not consumed&quot;</span>   <span class="n">hasUTxO</span>           <span class="o">&amp;&amp;</span>
                       <span class="n">traceIfFalse</span> <span class="s">&quot;wrong amount minted&quot;</span> <span class="n">checkMintedAmount</span>
</pre></div>
</div>
<p>And, of course, we need to implement <em>checkMintedAmount</em>.</p>
<p>First of all, we need access to the forged value. We get this from the field <em>txInfoForge</em> of <em>TxInfo</em>.</p>
<p>How do we check that this forged value is exactly 1 token of the name that we require? There are several approaches, but one is to use the <em>flattenValue</em> function which,
we will recall, returns a list of triples of currency symbol, token name and value. We can then check that the output of <em>flattenValue</em> is exactly one triple that matches
the symbol, token and value that we expect.</p>
<p>This would look something like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="p">[(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>But we still have a problem to solve - we need to know what the currency symbol is. Given that the currency symbol is a hash of the policy, it seems as if we have a chicken
and egg problem.</p>
<p>As luck would have it, there is a function called <em>ownCurrencySymbol</em> which exists to solve exactly this problem.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="p">[(</span><span class="n">ownCurrencySymbol</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>As it happens, this won’t compile, because <em>Eq</em> is not defined for triples in the Plutus Prelude. So, we can work around this with a case statement and some pattern matching.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
        <span class="p">[(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tn&#39;</span><span class="p">,</span> <span class="n">amt</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">cs</span>  <span class="o">==</span> <span class="n">ownCurrencySymbol</span> <span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">tn&#39;</span> <span class="o">==</span> <span class="n">tn</span> <span class="o">&amp;&amp;</span> <span class="n">amt</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="kr">_</span>                <span class="ow">-&gt;</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Now, we can complete our policy.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkPolicy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkPolicy</span> <span class="n">oref</span> <span class="n">tn</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="n">traceIfFalse</span> <span class="s">&quot;UTxO not consumed&quot;</span>   <span class="n">hasUTxO</span>           <span class="o">&amp;&amp;</span>
                    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong amount minted&quot;</span> <span class="n">checkMintedAmount</span>
<span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">hasUTxO</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">hasUTxO</span> <span class="ow">=</span> <span class="n">any</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">txInInfoOutRef</span> <span class="n">i</span> <span class="o">==</span> <span class="n">oref</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>

    <span class="n">checkMintedAmount</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">checkMintedAmount</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">flattenValue</span> <span class="p">(</span><span class="n">txInfoForge</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
        <span class="p">[(</span><span class="n">cs</span><span class="p">,</span> <span class="n">tn&#39;</span><span class="p">,</span> <span class="n">amt</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">cs</span>  <span class="o">==</span> <span class="n">ownCurrencySymbol</span> <span class="n">ctx</span> <span class="o">&amp;&amp;</span> <span class="n">tn&#39;</span> <span class="o">==</span> <span class="n">tn</span> <span class="o">&amp;&amp;</span> <span class="n">amt</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="kr">_</span>                <span class="ow">-&gt;</span> <span class="kt">False</span>
</pre></div>
</div>
<p>And we will update our boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">policy</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">MonetaryPolicy</span>
<span class="nf">policy</span> <span class="n">oref</span> <span class="n">tn</span> <span class="ow">=</span> <span class="n">mkMonetaryPolicyScript</span> <span class="o">$</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="nf">\</span><span class="n">oref&#39;</span> <span class="n">tn&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapMonetaryPolicy</span> <span class="o">$</span> <span class="n">mkPolicy</span> <span class="n">oref&#39;</span> <span class="n">tn&#39;</span> <span class="o">||</span><span class="p">])</span>
    <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">oref</span>
    <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">tn</span>

<span class="nf">curSymbol</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">CurrencySymbol</span>
<span class="nf">curSymbol</span> <span class="n">oref</span> <span class="n">tn</span> <span class="ow">=</span> <span class="n">scriptCurrencySymbol</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span>
</pre></div>
</div>
<p>That completes the on-chain part.</p>
<p>We need to think about the inputs we need for this transaction.</p>
<p>First, we need a UTxO, and we need to provide one of our own. However, we don’t need to pass that in because we can look it up directly.</p>
<p>We only need to provide the token name, so we no longer need a special data type, so we can delete <em>MintParams</em> and just use <em>TokenName</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">NFTSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;mint&quot;</span> <span class="kt">TokenName</span>
</pre></div>
</div>
<p>Now we will write the off-chain <em>mint</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">NFTSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">tn</span> <span class="ow">=</span> <span class="kr">do</span>
</pre></div>
</div>
<p>The first thing to do is to get the list of UTxOs that belong to us.</p>
<p>The <em>Plutus.Contract</em> module gives us the <em>utxoAt</em> function, which has the signature below, and looks up all the UTxOs at a given address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">utxoAt</span> <span class="ow">::</span> <span class="kt">Address</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span>
</pre></div>
</div>
<p>An <em>AddressMap</em> is a map where the keys are <a href="#id15"><span class="problematic" id="id16">*</span></a>TxOutRef*s and the values are <a href="#id17"><span class="problematic" id="id18">*</span></a>TxOutTx*s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span>
<span class="kr">type</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span> <span class="ow">::</span> <span class="o">*</span>
<span class="kr">type</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">AddressMap</span><span class="o">.</span><span class="kt">UtxoMap</span> <span class="ow">=</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Internal</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">TxOutRef</span> <span class="kt">TxOutTx</span>
</pre></div>
</div>
<p>If we pass this function our own address then the keys of this map will be the UTxOs that belong to us. It doesn’t matter which one of these we pick. So long as we own
at least one UTxO, we are good.</p>
<p>The first step is to find our own address. We know how to find our own public key, and, given this, we can use the function <em>pubKeyAddress</em> to get our address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pubKeyAddress</span> <span class="ow">::</span> <span class="kt">PubKey</span> <span class="ow">-&gt;</span> <span class="n">address</span>
</pre></div>
</div>
<p>Let’s get them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>

<span class="nf">mint</span> <span class="ow">::</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">NFTSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">tn</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pk</span>    <span class="ow">&lt;-</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">pubKeyAddress</span> <span class="n">pk</span><span class="p">)</span>
</pre></div>
</div>
<p>We only need one - we don’t care which one. We will write a case statement that will either log an error if we have no UTxO available, or will use the first
UTxO in the list continue with the forging code.</p>
<p>The first change is to specify <em>1</em> instead of the <em>mpAmount</em>, as we want exactly 1 coin minted.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">keys</span> <span class="n">utxos</span> <span class="kr">of</span>
    <span class="kt">[]</span>       <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logError</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no utxo found&quot;</span>
    <span class="n">oref</span> <span class="kt">:</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="n">curSymbol</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="n">tn</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Secondly, we add the token name argument to the lookups.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="o">$</span> <span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span>
</pre></div>
</div>
<p>Thirdly, we now need an additional constraint which insists that our specific UTxO is consumed.</p>
<p>There’s a function for that.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Ledger.Constraints</span>
<span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">mustSpendPubKeyOutput</span>
<span class="nf">mustSpendPubKeyOutput</span> <span class="ow">::</span> <span class="kt">TxOutRef</span> <span class="ow">-&gt;</span> <span class="kt">TxConstraints</span> <span class="n">i</span> <span class="n">o</span>
</pre></div>
</div>
<p>How do we combine the constraints of <em>mustForgeValue</em> and <em>mustSpendPubKeyOutput</em>? <em>Contraints</em> don’t form a <em>Monoid</em>, but they do form a <em>Semigroup</em>, and the difference
is just that in <em>Semigroup</em> we don’t have <em>mempty</em>, the neutral element. We can still combine them with the <em>&lt;&gt;</em> operator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendPubKeyOutput</span> <span class="n">oref</span>
</pre></div>
</div>
<p>Now, we need to provide a lookup that gives access to where the UTxO <em>oref</em> can be found. For that we can use</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="ow">::</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span><span class="o">.</span><span class="kt">Internal</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">TxOutRef</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">ScriptLookups</span> <span class="n">a</span>
</pre></div>
</div>
<p>So, let’s update our lookups.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="p">(</span><span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>
</pre></div>
</div>
<p>Something we need to do before this script will run is to import the operator <em>&lt;&gt;</em> for <em>Semigroup</em> from the standard Haskell Prelude, as we have explicitly excluded it from
the <em>PlutusTx.Prelude</em> module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Prelude</span> <span class="p">(</span><span class="kt">Semigroup</span> <span class="p">(</span><span class="o">..</span><span class="p">))</span>
</pre></div>
</div>
<p>Let’s take a look at the whole function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mint</span> <span class="ow">::</span> <span class="kt">TokenName</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="kt">NFTSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">mint</span> <span class="n">tn</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pk</span>    <span class="ow">&lt;-</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">pubKeyAddress</span> <span class="n">pk</span><span class="p">)</span>
    <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">keys</span> <span class="n">utxos</span> <span class="kr">of</span>
        <span class="kt">[]</span>       <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logError</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no utxo found&quot;</span>
        <span class="n">oref</span> <span class="kt">:</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">val</span>     <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="n">curSymbol</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="n">tn</span> <span class="mi">1</span>
                <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">monetaryPolicy</span> <span class="p">(</span><span class="n">policy</span> <span class="n">oref</span> <span class="n">tn</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="n">utxos</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustForgeValue</span> <span class="n">val</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendPubKeyOutput</span> <span class="n">oref</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="n">printf</span> <span class="s">&quot;forged %s&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
<p>For the test script.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">tn</span> <span class="ow">=</span> <span class="s">&quot;ABC&quot;</span>
    <span class="n">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h1</span> <span class="n">tn</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;mint&quot;</span> <span class="n">h2</span> <span class="n">tn</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Let’s test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Signed</span> <span class="kt">Ledger</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Constraints</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">Free</span><span class="o">&gt;</span> <span class="kt">Week05</span><span class="o">.</span><span class="kt">NFT</span><span class="o">.</span><span class="n">test</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;mint&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ABC&quot;</span><span class="p">)]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">691</span><span class="n">a5c0725ac09f79c8c45c899d732d26460d18c4c18167be71d55319bcd5669</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
<span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;mint&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ABC&quot;</span><span class="p">)]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="n">e53519b17bf7d11a148ce17ac0305330f138a684530ba08b1c57f714672b8c68</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">e53519b17bf7d11a148ce17ac0305330f138a684530ba08b1c57f714672b8c68</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">691</span><span class="n">a5c0725ac09f79c8c45c899d732d26460d18c4c18167be71d55319bcd5669</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;forged Value (Map [(9d969e597d45fcd1732ce255e12a97599e883f924b4565fc3a2407bc08d34524,Map [(</span><span class="se">\&quot;</span><span class="s">ABC</span><span class="se">\&quot;</span><span class="s">,1)])])&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;forged Value (Map [(913f220c3b1ba49531bae2fedd9edb138a8b360e7e605bfcf4ff3f2045433069,Map [(</span><span class="se">\&quot;</span><span class="s">ABC</span><span class="se">\&quot;</span><span class="s">,1)])])&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{</span><span class="mi">9</span><span class="n">d969e597d45fcd1732ce255e12a97599e883f924b4565fc3a2407bc08d34524</span><span class="p">,</span> <span class="s">&quot;ABC&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">99999990</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{</span><span class="mi">913</span><span class="n">f220c3b1ba49531bae2fedd9edb138a8b360e7e605bfcf4ff3f2045433069</span><span class="p">,</span> <span class="s">&quot;ABC&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">99999990</span>
<span class="o">...</span>
<span class="kt">Wallet</span> <span class="mi">10</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>And now we have minted some NFTs.</p>
</div>
</div>
</div>
<div class="section" id="week-06-oracles">
<h2><span class="section-number">1.6. </span>Week 06 - Oracles<a class="headerlink" href="#week-06-oracles" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=Tr2VBm8vOhw">Lecture
#6</a>.</p>
<p>In this lecture we learn about oracles and using the PAB (Plutus Application Backend).</p>
<p>These notes use Plutus commit 476409eaee94141e2fe076a7821fc2fcdec5dfcb</p>
</div>
<div class="section" id="id19">
<h3><span class="section-number">1.6.1. </span>Overview<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>In this lecture we are going to look at a case study, to see how what we have learned so far can be turned into an actual application. A collection of executables that even come with a little front end.</p>
<p>It will be a real dApp, apart from the fact that we don’t have a real blockchain available yet. This will run on a
simulated blockchain - a mockchain.</p>
<p>The example we are going to use for this is to implement a very simple oracle.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the blockchain world, an oracle is a way to get real-world information onto the blockchain, in order to
make it usable in smart contracts.</p>
</div>
<p>There are numerous examples of use cases for oracles. We can think of external data sources such as weather data, election
results, stock exchange data or randomness. You may have a betting contract that depends on the outcome of a specific
sports game, for example.</p>
<p>There are various ways to implement oracles, of varying sophistication.</p>
<p>We are going to use a very simple approach, where we have one trusted data provider. And, as an example of data, we
are going to use the ADA/USD exchange rate.</p>
<p>There are lots of problems with this approach, as we have to trust the data source. There are ways to mitigate the risk
that the data source is either untrustworthy or unreliable. For example, we could ask the provider to put down some
collateral that is lost if data is not provided or is inaccurate. Or, you could combine several oracles into one
and only accept the result if they all agree, or take the median, or average value of various sources. You could also
come up with more sophisticated mechanisms.</p>
<p>As we know, for anything to happen on the blockchain, there must be a UTxO, so the obvious thing to do is to represent
the data feed as a UTxO. The UTxO sits at the script address of the oracle, and its datum field it carries the current
value of the oracle data.</p>
<div class="figure align-default">
<img alt="_images/week06__00000.png" src="_images/week06__00000.png" />
</div>
<p>And this is where we find our first problem. As we have noted before, validation only happens when you want to consume
something from a script address, not when you produce an output at a script address. This means that we can’t prevent
anybody producing arbitrary outputs at the script address.</p>
<div class="figure align-default">
<img alt="_images/week06__00001.png" src="_images/week06__00001.png" />
</div>
<p>Somehow we need to distinguish the true oracle output from other outputs that may be sitting at the same script address.
And the way we do this is to put an NFT on the output. Because an NFT can only exist once, there can only be one UTxO
at the script address that holds the NFT.</p>
<div class="figure align-default">
<img alt="_images/week06__00002.png" src="_images/week06__00002.png" />
</div>
<p>How can such an oracle be used?</p>
<p>Here we come to something we haven’t seen before. In all our code writing validators and contracts, we always knew the
full API up front. In the case of an oracle, this is different. At the point that an oracle is created, you don’t know how
people may want to use it. It must be like an open API, able to work with smart contracts that have not yet been
designed.</p>
<p>As an example of a use-case that might make use of this specific oracle, let’s consider a swap contract where, at the swap
address, somebody can deposit ADA, and then somebody else can take those ADA in exchange for USD.</p>
<div class="figure align-default">
<img alt="_images/week06__00003.png" src="_images/week06__00003.png" />
</div>
<p>Of course, we don’t have USD directly on the blockchain, but we can imagine that they are represented by some native token.</p>
<p>In this example, as the value at the oracle is 1.75, then if someone offers 100 ADA, the price for that should be
175 USD.</p>
<p>In addition to this, we need an incentive for the oracle to provide the data, because in additional to other costs for
providing the data, at a minimum they would have to pay fees to create the UTxO.</p>
<p>So, let’s say that the oracle provider determines a fee of 1 ADA that has to be paid each time the oracle is used.</p>
<p>In this example, that would mean that the person wanting to by the ADA would have to pay 175 USD to the seller of the ADA,
and 1 ADA to the oracle.</p>
<p>What will the transaction look like?</p>
<div class="figure align-default">
<img alt="_images/week06__00004.png" src="_images/week06__00004.png" />
</div>
<p>First of all, the swap validation logic will need access to the current oracle value, which means that the oracle UTxO must be an input to the transaction.</p>
<p>Then we have the oracle validation logic. In this case we want to use the oracle. So, let’s say we have a redeemer called <em>use</em>. Now, the oracle validator has
to check several things.</p>
<ol class="arabic simple">
<li><p>Is the NFT present in the consumed input?</p></li>
<li><p>Is there an output from the transaction at the same address containing the same NFT?</p></li>
<li><p>Is the value in the output UTxO the same as the input value?</p></li>
<li><p>Is the fee present?</p></li>
</ol>
<p>Now we can complete the transaction.</p>
<p>We consume two additional inputs - the fee paid by the buyer and the 100 ADA deposited by the seller. Then we have two additional outputs - the 175 USD to the seller, and the 100 ADA to the buyer. And for these new inputs and
outputs, it is the responsibility of the swap validator to make sure that it is correct. Whereas, the oracle validator is only interested with making sure that everything concerning the oracle is correct.</p>
<div class="figure align-default">
<img alt="_images/week06__00005.png" src="_images/week06__00005.png" />
</div>
<p>Just to emphasize, this swap contract is just an example. The oracle should be capable of working with many different smart contracts that want to make use of its data.</p>
<p>If this was all, then we wouldn’t need an oracle. If the value was fixed, so that it was always 1.75 then we could simply hard-code this into our contract. So, the value must be able to change. At least, in an example such
as this one where we have an exchange rate that can, of course, change over time. There may be other examples such as the result of a sports match, where it is a singular event in history, but in this case, it is important
that it be able to change.</p>
<p>This means that the oracle validator, in addition to the <em>use</em> redeemer, must be able to support another operation where the provider of the oracle can actually change the data.</p>
<p>So let’s say the the value changes from 1.75 to 1.77.</p>
<p>We know that on a (E)UTxO blockchain, nothing ever changes, so you can’t change the datum of an existing UTxO. All you can do is consume UTxOs and produce new ones.</p>
<p>We would have a transaction that uses an <em>update</em> redeemer. The validation logic is somewhat different. It is the same as before in that the NFT needs to be present in the consumed oracle input, and also needs to be
present in the new output. In addition to that, the transaction must be signed by the oracle provider. And, we can use this update transaction as an opportunity for the oracle provider to collect the fees.</p>
<p>We insist that the NFT be present in the output, but we don’t say anything about other values. All the fees that got there by other transactions using this oracle data can be collected during the <em>update</em> transaction.</p>
<div class="figure align-default">
<img alt="_images/week06__00006.png" src="_images/week06__00006.png" />
</div>
<div class="section" id="id20">
<h4><span class="section-number">1.6.1.1. </span>Summary<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>To sum up, we represent the oracle by a UTxO and identify the correct UTxO with an NFT. The oracle value is the datum of the UTxO. We support two operations.</p>
<p>One is <em>use</em> which uses the oracle in some arbitrary
transaction. The <em>use</em> validator will make sure that the consumed oracle input carries the NFT, that there is an output that again carries the NFT, doesn’t change the datum, and carries additional fees.</p>
<p>The second operation is <em>update</em> which can only be done by the oracle provider. For an <em>update</em> transaction, the oracle input must again carry the NFT, there must be an oracle output, also carrying the NFT. There are no
further restrictions. The datum can change, and the accumulated fees can be taken out.</p>
</div>
</div>
<div class="section" id="oracle-core">
<h3><span class="section-number">1.6.2. </span>Oracle Core<a class="headerlink" href="#oracle-core" title="Permalink to this headline">¶</a></h3>
<p>Now that we know how it is supposed to work, let’s look at some code.</p>
<div class="section" id="id21">
<h4><span class="section-number">1.6.2.1. </span>On-chain<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>First, let’s look at the Plutus code that implements the oracle itself.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week06.Oracle.Core</span>
</pre></div>
</div>
<p>The oracle will be a parameterized contract, and it will depend on four fields.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Oracle</span> <span class="ow">=</span> <span class="kt">Oracle</span>
    <span class="p">{</span> <span class="n">oSymbol</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">oOperator</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">oFee</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">oAsset</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><em>oSymbol</em> is the currencySymbol of the NFT that is used to identify the transaction. We don’t need the token name as we will just use the empty string as the token name.</p></li>
<li><p><em>oOperator</em> is the owner of the oracle - the hash of the public key owner which can make updates</p></li>
<li><p><em>oFee</em> is the fee in lovelace that is due every time the oracle is used</p></li>
<li><p><em>oAsset</em> represents the asset class that we want to exchange rate for against Ada, which in our case will be some kind of USD token</p></li>
</ul>
<p>The redeemer will support two operations.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">OracleRedeemer</span> <span class="ow">=</span> <span class="kt">Update</span> <span class="o">|</span> <span class="kt">Use</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kt">PlutusTx</span><span class="o">.</span><span class="n">unstableMakeIsData</span> <span class="kt">&#39;&#39;OracleRedeemer</span>
</pre></div>
</div>
<p>We need to define the NFT asset class. As mentioned, we are going to use the empty string for the token name.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE oracleTokenName #-}</span>
<span class="nf">oracleTokenName</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">oracleTokenName</span> <span class="ow">=</span> <span class="kt">TokenName</span> <span class="n">emptyByteString</span>
</pre></div>
</div>
<p>The <em>oracleAsset</em> will be used to identify the NFT - this is not to be confused with <em>oAsset</em>, defined above.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE oracleAsset #-}</span>
<span class="nf">oracleAsset</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">AssetClass</span>
<span class="nf">oracleAsset</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">oSymbol</span> <span class="n">oracle</span><span class="p">,</span> <span class="n">oracleTokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>We create a little helper function called <em>oracleValue</em>. This takes an output transaction and a function which looks up the datum, and then returns an <em>Integer</em>. The <em>Integer</em> represents the exchange rate (e.g. 1.75) multiplied
by a million. This avoids potential complications when using real numbers.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE oracleValue #-}</span>
<span class="nf">oracleValue</span> <span class="ow">::</span> <span class="kt">TxOut</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">DatumHash</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Datum</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="nf">oracleValue</span> <span class="n">o</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">dh</span>      <span class="ow">&lt;-</span> <span class="n">txOutDatum</span> <span class="n">o</span>
    <span class="kt">Datum</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">dh</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">d</span>
</pre></div>
</div>
<p>This function is an example of monadic computation in monad that is not <em>IO</em> or the <em>Contract</em> monad. First we call <em>txOutDatum</em>, which can fail if because not every output has a datum. If it succeeds, we get a datum hash
which we can reference in <em>dh</em>. Next we used the function <em>f</em> which is provided as the second argument to maybe turn this datum hash into a datum. This too can fail. If it succeeds we can reference the result in <em>d</em>. <em>Datum</em>
is just a newtype wrapper around <em>Data</em>, so we can then use <em>PlutusTx.fromData</em> to maybe turn <em>d</em> into an <em>Integer</em>. Again, this can fail, because even if the datum is there, it may not be convertible to an integer value.</p>
<p>We will see in a moment where we use the <em>oracleValue</em> function.</p>
<p>The most important function is <em>mkOracleValidator</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# INLINABLE mkOracleValidator #-}</span>
<span class="nf">mkOracleValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">OracleRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkOracleValidator</span> <span class="n">oracle</span> <span class="n">x</span> <span class="n">r</span> <span class="n">ctx</span> <span class="ow">=</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span>  <span class="n">inputHasToken</span>  <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span> <span class="n">outputHasToken</span> <span class="o">&amp;&amp;</span>
    <span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
        <span class="kt">Update</span> <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;operator signature missing&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">oOperator</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                  <span class="n">traceIfFalse</span> <span class="s">&quot;invalid output datum&quot;</span>       <span class="n">validOutputDatum</span>
        <span class="kt">Use</span>    <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;oracle value changed&quot;</span>       <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>              <span class="o">&amp;&amp;</span>
                  <span class="n">traceIfFalse</span> <span class="s">&quot;fees not paid&quot;</span>              <span class="n">feesPaid</span>
  <span class="kr">where</span>
    <span class="n">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
    <span class="n">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

    <span class="n">ownInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
    <span class="n">ownInput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;oracle input missing&quot;</span>
        <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>

    <span class="n">inputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">inputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">ownOutput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
    <span class="n">ownOutput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">getContinuingOutputs</span> <span class="n">ctx</span> <span class="kr">of</span>
        <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
        <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one oracle output&quot;</span>

    <span class="n">outputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">outputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">outputDatum</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
    <span class="n">outputDatum</span> <span class="ow">=</span> <span class="n">oracleValue</span> <span class="n">ownOutput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span>

    <span class="n">validOutputDatum</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">validOutputDatum</span> <span class="ow">=</span> <span class="n">isJust</span> <span class="n">outputDatum</span>

    <span class="n">feesPaid</span> <span class="ow">::</span> <span class="kt">Bool</span>
    <span class="n">feesPaid</span> <span class="ow">=</span>
      <span class="kr">let</span>
        <span class="n">inVal</span>  <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownInput</span>
        <span class="n">outVal</span> <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownOutput</span>
      <span class="kr">in</span>
        <span class="n">outVal</span> <span class="p">`</span><span class="n">geq</span><span class="p">`</span> <span class="p">(</span><span class="n">inVal</span> <span class="o">&lt;&gt;</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">))</span>
</pre></div>
</div>
<p>The function <em>mkOracleValidator</em> takes our parameter <em>Oracle</em>, the datum, which, in this example is an <em>Integer</em>, the redeemer type <em>OracleRedeemer</em> and finally the <em>ScriptContext</em>.</p>
<p>There are two cases for this validator - <em>use</em> and <em>update</em> - but there are similarities. In both cases we want to check that we have the input that holds the NFT and that there is an output that holds the NFT.</p>
<p>As both these checks need to be done regardless of the use case, they are done upfront.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span>  <span class="n">inputHasToken</span>  <span class="o">&amp;&amp;</span>
<span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span> <span class="n">outputHasToken</span> <span class="o">&amp;&amp;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>After this, we consider which use case we are dealing with.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
    <span class="kt">Update</span> <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;operator signature missing&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">oOperator</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="n">traceIfFalse</span> <span class="s">&quot;invalid output datum&quot;</span>       <span class="n">validOutputDatum</span>
    <span class="kt">Use</span>    <span class="ow">-&gt;</span> <span class="n">traceIfFalse</span> <span class="s">&quot;oracle value changed&quot;</span>       <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>              <span class="o">&amp;&amp;</span>
              <span class="n">traceIfFalse</span> <span class="s">&quot;fees not paid&quot;</span>              <span class="n">feesPaid</span>
</pre></div>
</div>
<p>Before looking at the <em>inputHasToken</em> function there is another help function to look at.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownInput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;oracle input missing&quot;</span>
    <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>
</pre></div>
</div>
<p>The <em>ownInput</em> function returns the <em>TxOut</em> that the script is trying to consume, which in this case is the oracle output. The <em>Nothing</em> case here can happen if we are in a
different context, such as a minting context, so this eventuality will not occur for us. The <em>findOwnInput</em> function is provided by Plutus and will, given the context,
find the relevant input. The <em>txInInfoResolved</em> function gets the <em>TxOut</em> from the <em>TxInInfo</em>.</p>
<p>The <em>inputHashToken</em> function checks that the token is present. It uses the <em>assetClassValueOf</em> function to look for the NFT within the <em>ownInput</em> response.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">inputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The next helper function, <em>ownOutput</em> checks that we have exactly one output and returns that output to us.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownOutput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownOutput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">getContinuingOutputs</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
    <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one oracle output&quot;</span>
</pre></div>
</div>
<p>We can use this for the <em>outputHasToken</em> helper function in the same way as we did for the <em>inputHashToken</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">outputHasToken</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">outputHasToken</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>That covers the code for the common cases. Now, let’s let at the code specific to the <em>update</em> case.</p>
<p>There are two conditions to check. The first is that the operator actually signed the transaction. This is so simple that we can do it inline without
a helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;operator signature missing&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="o">$</span> <span class="n">oOperator</span> <span class="n">oracle</span><span class="p">)</span>
</pre></div>
</div>
<p>The next thing to check is that the output datum. We know that the value can change, but we need to check that it is at least of the correct type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;invalid output datum&quot;</span> <span class="n">validOutputDatum</span>
</pre></div>
</div>
<p>And for this we have referenced a new helper function <em>validOutputDatum</em>, which itself makes use of a helper function <em>outputDatum</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">outputDatum</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Integer</span>
<span class="nf">outputDatum</span> <span class="ow">=</span> <span class="n">oracleValue</span> <span class="n">ownOutput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span>

<span class="nf">validOutputDatum</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">validOutputDatum</span> <span class="ow">=</span> <span class="n">isJust</span> <span class="n">outputDatum</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you look up <em>findDatum</em> in the REPL, you will see it has a type of <em>DatumHash -&gt; TxInfo -&gt; Maybe Datum</em>. As we are using its infix notation here, we
can pass in <em>info</em> as the only parameter, and this will result in the whole expression having the type <em>DatumHash -&gt; Maybe Datum</em>, which is the type we
need to pass into <em>oracleValue</em>.</p>
</div>
<p>This works by trying to get the datum value from the datum hash and then trying to create the oracle value from it. If it succeeds it will return a <em>Just Integer</em>,
otherwise it will return <em>Nothing</em>, so the <em>validOutputDatum</em> function just needs to check that the return value is not <em>Nothing</em>, in other words, that it
is a <em>Just</em>.</p>
<p>Note that we are not checking anything about the value of the <em>Integer</em>. This could even remain the same as the input value, if the transaction is used
just to collect the fees that have accumulated from the use the oracle.</p>
<p>The second case for <em>mkOracleValidator</em> is the <em>use</em> case. This case can be used by anyone, but it is much more restrictive.</p>
<p>First, we don’t allow the value to change. So this is the first condition.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;oracle value changed&quot;</span> <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>We have already written the <em>outputDatum</em> helper function. Instead of checking only that it is an <em>Integer</em>, here we also check that its output value is the same
as the input value.</p>
<p>And finally, we must check that the fees have been paid. And for this we use a new helper function called <em>feesPaid</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">feesPaid</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">feesPaid</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">inVal</span>  <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownInput</span>
    <span class="n">outVal</span> <span class="ow">=</span> <span class="n">txOutValue</span> <span class="n">ownOutput</span>
  <span class="kr">in</span>
    <span class="n">outVal</span> <span class="p">`</span><span class="n">geq</span><span class="p">`</span> <span class="p">(</span><span class="n">inVal</span> <span class="o">&lt;&gt;</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">))</span>
</pre></div>
</div>
<p>This <em>feesPaid</em> function checks that the output value is at least as much as the input value plus the required fee. We again use the semigroup operator
<em>&lt;&gt;</em> to add the fee value to the input value. We could have used equal (eq) instead of greater than or equal (geq). Using <em>geq</em> allows the user of the
oracle to give the oracle provider a tip, if they so wish.</p>
<p>So this now is basically the core business logic of the oracle as shown in the diagrams.</p>
<div class="figure align-default">
<img alt="_images/week06__00006.png" src="_images/week06__00006.png" />
</div>
<p>Now we have our usual boilerplate. In particular notice that we use the pattern that we need for a parameterized validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Oracling</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Oracling</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Oracling</span> <span class="ow">=</span> <span class="kt">Integer</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Oracling</span> <span class="ow">=</span> <span class="kt">OracleRedeemer</span>

<span class="nf">oracleInst</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Oracling</span>
<span class="nf">oracleInst</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Oracling</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkOracleValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">oracle</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
<span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">Integer</span> <span class="o">@</span><span class="kt">OracleRedeemer</span>

<span class="nf">oracleValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">oracleValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">oracleInst</span>

<span class="nf">oracleAddress</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">oracleAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">oracleValidator</span>
</pre></div>
</div>
<p>And this concludes the on-chain part of the oracle code.</p>
</div>
<div class="section" id="id22">
<h4><span class="section-number">1.6.2.2. </span>Off-chain<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>We also create some off-chain code, namely to start the oracle, and to update it. However, we don’t write off-chain code to <em>use</em> the oracle. That is not the
responsibility of the author of this contract. That will be the responsibility of the person that wants to use the oracle - they will write the code to create the
transaction with the <em>use</em> redeemer. This is the first time that we have seen the situation where we have some on-chain code that is not paired with some off-chain code.</p>
<p>To start the oracle, we need some parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">OracleParams</span> <span class="ow">=</span> <span class="kt">OracleParams</span>
    <span class="p">{</span> <span class="n">opFees</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">opSymbol</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">opToken</span>  <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>opFees</em> parameter represents the number of lovelace that will be charged to use the oracle.</p>
<p>The <em>opSymbol</em> and <em>opToken</em> parameters represent the token against which we are providing the Ada exchange rate, in this case a USD token.</p>
<p>First we create a <em>startOracle</em> function, whose responsibility is to mint the NFT that will be used to identify the oracle UTxO. The <em>startOracle</em> function will
not provide an initial value for the oracle, this will be handled by the <em>updateOracle</em> function. The reason for this is that, if we provided an initial value, it may
be outdated by the time the NFT is minted.</p>
<p>We could have used the same code for minting the NFT as we used in lecture 5. This would have worked perfectly well.</p>
<p>However, this is a currency module provided in <em>plutus-use-cases</em> that provides a <em>forgeContract</em> function that allows us to mint NFTs.</p>
<p>Here is the type of the <em>forgeContract</em> function shown in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Prelude Week06.Oracle.Core&gt; :t Plutus.Contracts.Currency.forgeContract
Plutus.Contracts.Currency.forgeContract
  :: (row-types-1.0.1.0:Data.Row.Internal.AllUniqueLabels
        (Plutus.Contract.Schema.Input s),
      row-types-1.0.1.0:Data.Row.Internal.AllUniqueLabels
        (Plutus.Contract.Schema.Output s),
      Plutus.Contracts.Currency.AsCurrencyError e,
      (Plutus.Contract.Schema.Input s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx-confirmation&quot;)
      ~ Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed,
      (Plutus.Contract.Schema.Input s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx&quot;)
      ~ Plutus.Contract.Effects.WriteTx.WriteTxResponse,
      (Plutus.Contract.Schema.Output s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx&quot;)
      ~ Ledger.Constraints.OffChain.UnbalancedTx,
      (Plutus.Contract.Schema.Output s
       row-types-1.0.1.0:Data.Row.Internal..! &quot;tx-confirmation&quot;)
      ~ Plutus.V1.Ledger.TxId.TxId) =&gt;
     Plutus.V1.Ledger.Crypto.PubKeyHash
     -&gt; [(Plutus.V1.Ledger.Value.TokenName, Integer)]
     -&gt; Plutus.Contract.Types.Contract
          w s e Plutus.Contracts.Currency.OneShotCurrency
</pre></div>
</div>
<p>The important part starts towards the end, where the first parameter - of type <em>PubKeyHash</em> - is defined. This is the hash of the public key of the recipient of the NFT.</p>
<p>The <em>forgeContract</em> function provides more general functionality than our previous NFT contract. It allows is to generate multiple NFTs in one go. It will create a currency symbol that can only be used one, similar
to our NFT from last time, so there can only be one minting transaction. But for the one currency symbol, you can mint various tokens in the same transaction, with
various token names and in various quantities. The second parameter allows us to define these token names and quantities.</p>
<p>And it gives us a <em>Contract</em> that returns a value of the <em>OneShotCurrency</em> type. This type is specific to the currency and it doesn’t really matter to us what it is. All that matters
for us is that we can get the currency symbol out of it again.</p>
<p>There is one slight problem. This is not compatible with what we want. We want this types</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">Oracle</span>
</pre></div>
</div>
<p>An arbitrary writer type (because we don’t make use of it), an arbitrary schema (as long as we have <em>BlockChainActions</em> available), <em>Text</em> error messages and a return
type of <em>Oracle</em>.</p>
<p>The problem is that the <em>Contract</em> returned by <em>forgeContract</em> doesn’t allow <em>Text</em> error messages. You can see this in the verbose output from the REPL - there is
a constraint on the <em>e</em> parameter.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contracts</span><span class="o">.</span><span class="kt">Currency</span><span class="o">.</span><span class="kt">AsCurrencyError</span> <span class="n">e</span><span class="p">,</span>
</pre></div>
</div>
<p>Unfortunately <em>Text</em> doesn’t implement <em>AsCurrencyError</em>.</p>
<p>Luckily there is a function that can helper</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="n">mapError</span>
<span class="ow">::</span> <span class="p">(</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="n">e&#39;</span><span class="p">)</span>
   <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Types</span><span class="o">.</span><span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span>
   <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Types</span><span class="o">.</span><span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e&#39;</span> <span class="n">a</span>
</pre></div>
</div>
<p>Given a <em>Contract</em>, it allows us to create a new <em>Contract</em> with a new type of error message. That is provided we give a function that converts from the first error
type to the second error type.</p>
<p>So, let’s look at the <em>startOracle</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startOracle</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">OracleParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">Oracle</span>
<span class="nf">startOracle</span> <span class="n">op</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">osc</span> <span class="ow">&lt;-</span> <span class="n">mapError</span> <span class="p">(</span><span class="n">pack</span> <span class="o">.</span> <span class="n">show</span><span class="p">)</span> <span class="p">(</span><span class="n">forgeContract</span> <span class="n">pkh</span> <span class="p">[(</span><span class="n">oracleTokenName</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">CurrencyError</span> <span class="kt">OneShotCurrency</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">cs</span>     <span class="ow">=</span> <span class="kt">Currency</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="n">osc</span>
        <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">Oracle</span>
            <span class="p">{</span> <span class="n">oSymbol</span>   <span class="ow">=</span> <span class="n">cs</span>
            <span class="p">,</span> <span class="n">oOperator</span> <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">oFee</span>      <span class="ow">=</span> <span class="n">opFees</span> <span class="n">op</span>
            <span class="p">,</span> <span class="n">oAsset</span>    <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">opSymbol</span> <span class="n">op</span><span class="p">,</span> <span class="n">opToken</span> <span class="n">op</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;started oracle &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">oracle</span>
    <span class="n">return</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>Here we see the error conversion function is provided as <em>pack . show</em>. The <em>show</em> function converts the error to a <em>String</em> and the <em>pack</em> function converts a <em>String</em>
to a <em>Data.Text</em> type.</p>
<p>At this point, <em>osc</em> holds the <em>OneShotCurrency</em>, and we can then use the <em>currencySymbol</em> function to get the currency symbol as <em>cs</em>.</p>
<p>The <em>currencySymbol</em> function has type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">currencySymbol</span>
      <span class="ow">::</span> <span class="kt">OneShotCurrency</span> <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">V1</span><span class="o">.</span><span class="kt">Ledger</span><span class="o">.</span><span class="kt">Value</span><span class="o">.</span><span class="kt">CurrencySymbol</span>
</pre></div>
</div>
<p>And is used accordingly</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">cs</span> <span class="ow">=</span> <span class="kt">Currency</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="n">osc</span>
</pre></div>
</div>
<p>Now we have minted our NFT and it has currency symbol <em>cs</em>. And now we can construct our <em>Oracle</em> parameter value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracle</span> <span class="ow">=</span> <span class="kt">Oracle</span>
    <span class="p">{</span> <span class="n">oSymbol</span>   <span class="ow">=</span> <span class="n">cs</span>
    <span class="p">,</span> <span class="n">oOperator</span> <span class="ow">=</span> <span class="n">pkh</span>
    <span class="p">,</span> <span class="n">oFee</span>      <span class="ow">=</span> <span class="n">opFees</span> <span class="n">op</span>
    <span class="p">,</span> <span class="n">oAsset</span>    <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">opSymbol</span> <span class="n">op</span><span class="p">,</span> <span class="n">opToken</span> <span class="n">op</span><span class="p">)</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>The reason that <em>opSymbol</em> and <em>opToken</em> are defined separately in the <em>OracleParams</em> type <em>op</em> is just that this makes is easier when we are using the playground.</p>
<p>The <em>updateOracle</em> function is more complicated.</p>
<p>This function has to deal with two cases. Namely, the case where we have a value that we wish to update, and the case where we have just started the oracle and we want
to create a value for the very first time.</p>
<p>It takes our oracle parameters and also the <em>Integer</em> value that we wish to have the oracle hold.</p>
<p>First we create a helper function <em>findOracle</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findOracle</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">))</span>
<span class="nf">findOracle</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">oracleAddress</span> <span class="n">oracle</span><span class="p">)</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span> <span class="kr">of</span>
        <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">oracleValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="n">dh</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
            <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="kr">_</span>           <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The purpose of <em>findOracle</em> is to look up the existing oracle UTxO. This can fail because the oracle might not be there. This will happen if we have just started the
oracles and have not yet created a UTxO with the oracle value. But, if we find it, we return a triple containing the UTxO identifer (TxOutRef), the UTxO itself, which
contains all the data (TxOutTx) and the oracle value (the current exchange rate held by the oracle). The <em>Integer</em> containing the oracle value is encoded also in the
TxOutTx value, but we add it to the triple to make it easier to work with.</p>
<p>The first thing we do is to get all the UTxOs sitting at this address. But only one of these will be the one we are looking for - the one that contains the NFT.</p>
<p>We do this by using the <em>Map.filter</em> function which takes a function as a parameter which, in this case, returns True for the UTxO where the NFT is present.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">utxos</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">utxoAt</span> <span class="p">(</span><span class="n">oracleAddress</span> <span class="n">oracle</span><span class="p">)</span>
<span class="o">...</span>
<span class="kr">where</span>
  <span class="n">f</span> <span class="ow">::</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
  <span class="n">f</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We will end up with a map in <em>utxos</em> which is either empty or contains one item. Now, we distinguish between these two cases.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">return</span> <span class="o">$</span> <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span> <span class="kr">of</span>
    <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">oracleValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="n">dh</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="kr">_</span>           <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>We convert the map to a list of tuples representing key value pairs of transaction ids and the transactions themselves.</p>
<p>For the case where there is no element, we use the _ case to represent all other cases. This could only ever be the empty list, but the compiler doesn’t know that.</p>
<p>If, however, we have found the UTxO, then, as we already have its id and transaction, we just need to find its <em>Integer</em> value. This part could still go wrong. Even
though we have found the correct UTxO, there could be some corrupt data in it for whatever reason.</p>
<p>We use the <em>oracleValue</em> function that we used also in validation. This function takes a <em>TxOut</em> parameter followed by a second parameter is a function, which, given a datum hash will return the associated datum.</p>
<p>In the off-chain code, we can use the following function parameter</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">dh</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
</pre></div>
</div>
<p>Here, <em>txData</em> is a field of the transaction and it is a map from datum hashes to datums. We get the transaction from <em>txOutTxTx o</em>.</p>
<p>If this all succeeds, when will return the triple (oref, o, x), where x is the <em>Integer</em> value of the oracle.</p>
<p>Now that we have written the <em>findOracle</em> function we can look at the <em>updateOracle</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">updateOracle</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">updateOracle</span> <span class="n">oracle</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
    <span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="n">x</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="mi">1</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="n">c</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;set initial oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span>  <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>     <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">scriptInstanceLookups</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">c</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Update</span><span class="p">)</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Oracling</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;updated oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>After the <em>findOracle</em> line there is a helper function definition, as we will need this constraint twice.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="n">x</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oracleAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>After looking for the oracle, there are wo possibilities - either we found it or we did not.</p>
<p>If we didn’t find it, then we have started the oracle but we have not yet provided an initial value. This is the first case. And in this case, all we have to
do is to submit a transaction that produces the first value for the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="n">c</span>
<span class="nf">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;set initial oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>Here is the first usage of the <em>c</em> helper function. It provides the constraint <em>mustPayToTheScript</em> which ensures that the transaction will have an output
that pays to a script address. As arguments it takes the datum <em>x</em> and the NFT. The script that it must pay to is always the script that is in focus - here it is
the first parameter to <em>submitTxConstraints</em> - <em>(oracleInst oracle)</em>.</p>
<p>We then wait for confirmation and write a log message. And this is all we need to do for this case.</p>
<p>In the other case, where we already have a value, we need to reference the UTxO parts, but we don’t care about the current datum, as we are going to update it anyway.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span>  <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
</pre></div>
</div>
<p>Now it gets a bit more complicated, because now we need two conditions.</p>
<p>The first constraint is the same as in the other case - the constraint referenced by the helper function <em>c</em>. But there is now an extra constraint that we must also
consume the existing UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="n">c</span> <span class="o">&lt;&gt;</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Update</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>mustSpendScriptOutput</em> function is basically the opposite of <em>mustPayToTheScript</em>. It creates an input to this script address. As parameters it takes the reference
to the UTxO we want to consume, and it takes a <em>Redeemer</em>. In this case the <em>Redeemer</em> is <em>Update</em> and it is converted to the Plutus <em>Data</em> type.</p>
<p>In order for this to work we need to provide some lookups.</p>
<p>In order to find the output <em>oref</em> that it wants to spend, we must use the <em>unspentOutputs</em> lookup, and in this case, we just provide the lookup with one UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we must provide the script instances. We need to do this twice, once for the input side, and once for the output side. For this, we provide the oracle instance and
the oracle validator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">scriptInstanceLookups</span> <span class="p">(</span><span class="n">oracleInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
<span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
</pre></div>
</div>
<p>We didn’t need to provide the <em>scriptInstanceLookups</em> lookup in the first case, as we were able to pass <em>oracleInst oracle</em> to the <em>submitTxConstraints</em> function. However,
with the <em>submitTxConstraintsWith</em> function, we don’t have that option.</p>
<p>When submitting the transaction, we need to give the compiler a little nudge to let it know the script we are talking about - so that it knows, for example, what The Script is in <em>mustPayToTheScript</em>. For
this we reference the <em>Oracling</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Oracling</span> <span class="n">lookups</span> <span class="n">tx</span>
</pre></div>
</div>
<p>Hopefully now we have a valid transaction that gets submitted, and then we wait for it to be confirmed, and write some logging information.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;updated oracle value to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>Remember, we talked about fee collecting earlier. This will happen automatically. The function <em>submitTxConstraintsWith</em> will send the fees to our own wallet. It does
this because there is an imbalance between the value attached to the input, which includes the fees and the NFT, and the value we have said must be paid to the script,
which is just the NFT.</p>
<p>This process will also automatically create an extra input from our own input to pay the transaction fees for executing the transaction.</p>
<p>Lastly, we provide a function that combines these two operations, <em>startOracle</em> and <em>updateOracle</em> into one contract. This will make it possible to use in the playground
and the <em>EmulatorTrace</em> monad, as well as in the PAB.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">OracleSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;update&quot;</span> <span class="kt">Integer</span>

<span class="nf">runOracle</span> <span class="ow">::</span> <span class="kt">OracleParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">runOracle</span> <span class="n">op</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">oracle</span> <span class="ow">&lt;-</span> <span class="n">startOracle</span> <span class="n">op</span>
    <span class="n">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">oracle</span>
    <span class="n">go</span> <span class="n">oracle</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span>
        <span class="n">updateOracle</span> <span class="n">oracle</span> <span class="n">x</span>
        <span class="n">go</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>The function <em>runOracle</em> first starts the oracle. Then, for reasons that will become clear later, we use <em>tell</em> to write the oracle parameter. We need to be able to
communicate the parameter value of the oracle to the outside world, so that people can use the oracle. We will not know until runtime the currency symbol that will be used
for the NFT, so we don’t know the value of the oracle parameter yet.</p>
<p>Remember that <em>tell</em> expects a <em>Monoid</em> type. The typical example is a list of strings that get concatenated to one list of all log messages.</p>
<p>But it doesn’t have to be lists. In <em>Data.Monoid</em> we have this <em>Last</em> Monoid.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Monoid</span> <span class="p">(</span><span class="kt">Last</span> <span class="p">(</span><span class="o">..</span><span class="p">))</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Monoid</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="kt">Last</span>
<span class="kr">type</span> <span class="kt">Last</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="kr">newtype</span> <span class="kt">Last</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Last</span> <span class="p">{</span><span class="n">getLast</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span><span class="p">}</span>
      <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Ord</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Read</span> <span class="p">(</span><span class="kt">Last</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in ‘Data.Monoid’</span>
<span class="kr">instance</span> <span class="kt">Traversable</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Traversable’</span>
<span class="kr">instance</span> <span class="kt">Foldable</span> <span class="kt">Last</span> <span class="c1">-- Defined in ‘Data.Foldable’</span>
</pre></div>
</div>
<p>We see that it is just a <em>newtype</em> wrapper around <em>Maybe</em>. The point is to provide a specific <em>Monoid</em> instance. The idea, as the name suggests, is that it is
a monoid operation that always remembers the last Just value. For example:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Monoid</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;x&#39;</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;y&#39;</span><span class="p">)</span>
<span class="kt">Last</span> <span class="p">{</span><span class="n">getLast</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="sc">&#39;y&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>However, if the second <em>Last</em> is a nothing, it will return the first one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Monoid</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;x&#39;</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="kt">Last</span> <span class="kt">Nothing</span>
<span class="kt">Last</span> <span class="p">{</span><span class="n">getLast</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="sc">&#39;x&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>If both are <em>Nothing</em>, it will be <em>Nothing</em>.</p>
<p><em>Last</em> is very useful because it allows us to keep the current state. The value of the log will basically be the last <em>Just</em> we told.</p>
<p>In this contract we will only do that once. In the beginning it will be <em>Last Nothing</em>. Then we mint the NFT, and then, when we get the oracle value in
<em>runOracle</em>, and then <em>tell</em> it, it will always have that value. If other contracts from the outside query the state, they will always get the <em>Just oracle</em>, so
they will be able to discover the value of the oracle.</p>
<p>So, next in <em>runOracle</em>, we call the helper function <em>go</em>. What this does is to block at the update endpoint. As soon as someone provides an <em>Integer</em> as the new value,
it will call the <em>updateOracle</em> function with the new value, and then just loop to go again.</p>
<p>In summary, <em>runOracle</em> starts the oracle, <em>tell</em>s the oracle, then loops to allow others to update the oracle.</p>
<p>And that concludes the code for the oracle itself. What is now missing is an example, a contract that actually uses the oracle - a swap contract. And also using the
Plutus Application Backend to run this code in the real world or, in our case, in a simulated blockchain.</p>
</div>
</div>
<div class="section" id="swap-validation">
<h3><span class="section-number">1.6.3. </span>Swap Validation<a class="headerlink" href="#swap-validation" title="Permalink to this headline">¶</a></h3>
<p>Our example swap contract can be found in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week06.Oracle.swap</span>
</pre></div>
</div>
<p>The purpose of this contract is for someone to be able to deposit ADA and exchange it for a token, in our case a token that we will call USDT for US Dollar Token.</p>
<p>The idea is that the price, the amount of USDT that will be required to be paid for the ADA, will be determined by the value of the oracle. Remember that we are using
an <em>Integer</em> to reflect the exchange rate, with a value of one million being equal to one USDT.</p>
<p>We’ll start with a helper function called <em>price</em>, which, given a number of lovelace and the exchange rate, returns the USDT price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">price</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">price</span> <span class="n">lovelace</span> <span class="n">exchangeRate</span> <span class="ow">=</span> <span class="p">(</span><span class="n">lovelace</span> <span class="o">*</span> <span class="n">exchangeRate</span><span class="p">)</span> <span class="p">`</span><span class="n">divide</span><span class="p">`</span> <span class="mi">1000000</span>
</pre></div>
</div>
<p>The next helper function, <em>lovelaces</em>, combines to functions from the Plutus libraries to extract a number of lovelace from a <em>Value</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>Now we will write <em>mkSwapValidator</em>. This is a parameterized validator with two parameters.</p>
<p>The first parameter is the oracle that we are using. To use this, we import the oracle module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Week06.Oracle.core</span>
</pre></div>
</div>
<p>The second parameter is the address of the oracle. Normally, given the oracle, we would be able to compute the address from it. In the core module we saw a function
<em>oracleAddress</em> which does this for us. But this is a function that we can’t use in the validator, because it can’t be compiled to Plutus script. So, here, we explicitly
hand the address to the validator.</p>
<p>For the datum, we use the public key hash of the seller. We don’t use a redeemer, so we give it a type of Unit.</p>
<p>We recall from the diagram, the swap transaction should have three inputs and three outputs.</p>
<div class="figure align-default">
<img alt="_images/week06__00006.png" src="_images/week06__00006.png" />
</div>
<table class="colwidths-given docutils align-default" id="id28">
<caption><span class="caption-text">Swap Transaction Inputs and Outputs</span><a class="headerlink" href="#id28" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Inputs</p></th>
<th class="head"><p>Outputs</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>The oracle, to check the current exchange rate</p></td>
<td><p>The oracle, which we don’t need to look at in the swap validation</p></td>
</tr>
<tr class="row-odd"><td><p>The swap UTxO that holds the lovelace</p></td>
<td><p>The tokens for the seller</p></td>
</tr>
<tr class="row-even"><td><p>The source of the buyer’s funds</p></td>
<td><p>The lovelace for the buyer</p></td>
</tr>
</tbody>
</table>
<p>Note that we don’t need to worry about the oracle as an output. The oracle validator takes care of ensuring that the value is not changed and that the fees are added.</p>
<p>We also want to support the second use case, the case where the seller can retrieve the ADA tokens in the case that they no longer want to do the swap. If we don’t
support this case, the ADA could be locked there forever, if nobody ever decides to make the swap.</p>
<p>This second case is the condition we check in the validator. If the seller themselves signs the transaction, there are no further constraints - we don’t need to check
the oracle or anything else - the seller can just get back their lovelace.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkSwapValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Address</span> <span class="ow">-&gt;</span> <span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkSwapValidator</span> <span class="n">oracle</span> <span class="n">addr</span> <span class="n">pkh</span> <span class="nb">()</span> <span class="n">ctx</span> <span class="ow">=</span>
    <span class="n">txSignedBy</span> <span class="n">info</span> <span class="n">pkh</span> <span class="o">||</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The more interesting case is the second one, where we check two conditions.</p>
<p>Firstly, there must be two inputs - the oracle and the swap UTxO. All additional inputs (the buyer’s funds) must be public key inputs. This is because we don’t want to worry about interference with other smart contracts.</p>
<p>Secondly, we want to check that the seller gets paid.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">traceIfFalse</span> <span class="s">&quot;expected exactly two script inputs&quot;</span> <span class="n">hasTwoScriptInputs</span> <span class="o">&amp;&amp;</span>
 <span class="n">traceIfFalse</span> <span class="s">&quot;price not paid&quot;</span>                     <span class="n">sellerPaid</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we have our helper function definitions.</p>
<p>First, the usual.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
<span class="nf">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>
</pre></div>
</div>
<p>Then, we have <em>oracleInput</em> to get the UTxO from the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracleInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">oracleInput</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">ins</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">o</span>
          <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
          <span class="p">,</span> <span class="kr">let</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>
          <span class="p">,</span> <span class="n">txOutAddress</span> <span class="n">o</span> <span class="o">==</span> <span class="n">addr</span>
          <span class="p">]</span>
  <span class="kr">in</span>
    <span class="kr">case</span> <span class="n">ins</span> <span class="kr">of</span>
        <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
        <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one oracle input&quot;</span>
</pre></div>
</div>
<p>We do this by getting a list of all the inputs. For this we use list comprehension, which allows us to draw from other lists using a filter. In this case we draw
from the list from <em>txInfoInputs info</em>, which is a list of <em>TxInfo</em>. We use the <em>txInInfoResolved</em> function to look at each element as a <em>TxOut</em> type, which we then compare with the
<em>addr</em> parameter. The resulting list will either by empty, or will have the <em>TxOut</em> that matches the oracle UTxO.</p>
<p>We then check that there is exactly one element in the resulting list, and, if there is, we return it. We don’t return the list, just the <em>TxOut</em>.</p>
<p>This has now given us the oracle output that we are consuming as an input.</p>
<p>Now, we want to check the actual exchange rate. For that, we use the <em>oracleValue</em> function that we defined in the core module. Here again, it may succeed, or it may
fail. If it succeeds we return the value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracleValue&#39;</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">oracleValue</span> <span class="n">oracleInput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;oracle value not found&quot;</span>
    <span class="kt">Just</span> <span class="n">x</span>  <span class="ow">-&gt;</span> <span class="n">x</span>
</pre></div>
</div>
<p>We do not need to check whether the oracle contains the NFT. Due to the way validation works for the oracle, we know that it is present.</p>
<p>Now, let’s look at the <em>hasTwoScriptInputs</em> helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hasTwoScriptInputs</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">hasTwoScriptInputs</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">xs</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="n">isJust</span> <span class="o">.</span> <span class="n">toValidatorHash</span> <span class="o">.</span> <span class="n">txOutAddress</span> <span class="o">.</span> <span class="n">txInInfoResolved</span><span class="p">)</span> <span class="o">$</span> <span class="n">txInfoInputs</span> <span class="n">info</span>
  <span class="kr">in</span>
    <span class="n">length</span> <span class="n">xs</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
<p>First, we filter, using the composite function</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">isJust</span> <span class="o">.</span> <span class="n">toValidatorHash</span> <span class="o">.</span> <span class="n">txOutAddress</span> <span class="o">.</span> <span class="n">txInInfoResolved</span><span class="p">)</span>
</pre></div>
</div>
<p>Reading right to left, we get the UTxO from the input, then we get the address for this UTxO, then we get the validator hash for that address. Then, finally, we check
if it is a script output, by seeing if it is a <em>Just</em>. If it is a <em>Nothing</em>, then this would show that it is a public key, not a script address.</p>
<p>We then use this composite function as a filter against the list of <em>TxInInfo</em>s. And then we check that the length of the resulting list is exactly two.</p>
<p>Going back to our validation conditions, we now have to deal with checking that the seller is getting paid. So let’s write the <em>sellerPaid</em> helper function that
we referenced.</p>
<p>For this we will use another helper function to determine the required price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">minPrice</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">minPrice</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">lovelaceIn</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;own input not found&quot;</span>
        <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>
  <span class="kr">in</span>
    <span class="n">price</span> <span class="n">lovelaceIn</span> <span class="n">oracleValue&#39;</span>
</pre></div>
</div>
<p>First we check that we have an input, and if so, we extract the number of lovelaces and assign that number to <em>lovelaceIn</em>. Then, we use the <em>price</em> helper function
to determine the price in USD tokens.</p>
<p>Now, we can define the <em>sellerPaid</em> helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sellerPaid</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">sellerPaid</span> <span class="ow">=</span>
  <span class="kr">let</span>
    <span class="n">pricePaid</span> <span class="ow">::</span> <span class="kt">Integer</span>
    <span class="n">pricePaid</span> <span class="ow">=</span>  <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">valuePaidTo</span> <span class="n">info</span> <span class="n">pkh</span><span class="p">)</span> <span class="p">(</span><span class="n">oAsset</span> <span class="n">oracle</span><span class="p">)</span>
  <span class="kr">in</span>
    <span class="n">pricePaid</span> <span class="o">&gt;=</span> <span class="n">minPrice</span>
</pre></div>
</div>
<p>The function <em>valuePaidTo</em> is from the Plutus libraries. Given <em>info</em> and a public key hash, it will add up all the values of all the public key outputs that go
to this address. We then use the <em>assetClassValueOf</em> function to check the component of the value that is in USD token, and the check that we have at least as many
as we require.</p>
<p>That’s the end of the main part of the code for the swap validator. We just have our normal boiler plate to write.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Swapping</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Swapping</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Swapping</span> <span class="ow">=</span> <span class="kt">PubKeyHash</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Swapping</span> <span class="ow">=</span> <span class="nb">()</span>

<span class="nf">swapInst</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Swapping</span>
<span class="nf">swapInst</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Swapping</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkSwapValidator</span> <span class="o">||</span><span class="p">])</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">oracle</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="p">(</span><span class="n">oracleAddress</span> <span class="n">oracle</span><span class="p">))</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">PubKeyHash</span> <span class="o">@</span><span class="nb">()</span>

<span class="nf">swapValidator</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">swapValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">swapInst</span>

<span class="nf">swapAddress</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">swapAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">swapValidator</span>
</pre></div>
</div>
<p>Note that in the <em>swapInst</em> function, where we use template haskell to generate the Plutus validator from the <em>mkSwapValidator</em> function, we do not need to pass in the
oracle address as a parameter. This is because we will compute this inside the function. Remember that we can’t use the <em>oracleAddress</em> function inside the Plutus validator.</p>
<p>Now to define some contracts.</p>
<div class="section" id="offerswap">
<h4><span class="section-number">1.6.3.1. </span>offerSwap<a class="headerlink" href="#offerswap" title="Permalink to this headline">¶</a></h4>
<p>First <em>offerSwap</em>. This is for a seller who wants to offer a certain number of lovelace for exchange.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">offerSwap</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">offerSwap</span> <span class="n">oracle</span> <span class="n">amt</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="n">pkh</span> <span class="o">$</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="n">amt</span>
    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">swapInst</span> <span class="n">oracle</span><span class="p">)</span> <span class="n">tx</span>
    <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;offered &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">amt</span> <span class="o">++</span> <span class="s">&quot; lovelace for swap&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="findswaps">
<h4><span class="section-number">1.6.3.2. </span>findSwaps<a class="headerlink" href="#findswaps" title="Permalink to this headline">¶</a></h4>
<p>Next, a helper function that will find all swaps that satisfy a given predicate. It takes an oracle plus a predicate based on public key hashes, and returns a list
of triples of the UTxOs that satisfy the predicate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findSwaps</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">PubKeyHash</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="p">[(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)]</span>
<span class="nf">findSwaps</span> <span class="n">oracle</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">swapAddress</span> <span class="n">oracle</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">mapMaybe</span> <span class="n">g</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">PubKeyHash</span>
    <span class="n">f</span> <span class="n">o</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">dh</span>        <span class="ow">&lt;-</span> <span class="n">txOutDatumHash</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span>
        <span class="p">(</span><span class="kt">Datum</span> <span class="n">d</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">dh</span> <span class="o">$</span> <span class="n">txData</span> <span class="o">$</span> <span class="n">txOutTxTx</span> <span class="n">o</span>
        <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">d</span>

    <span class="n">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span>
    <span class="n">g</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">o</span>
        <span class="n">guard</span> <span class="o">$</span> <span class="n">p</span> <span class="n">pkh</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">pkh</span><span class="p">)</span>
</pre></div>
</div>
<p>First, we get a list of all the UTxOs sitting at the swap contract address. We then apply <em>mapMaybe</em> to this list.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapMaybe</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</pre></div>
</div>
<p>This function will apply the <em>(a -&gt; Maybe b)</em> function to each element in a list of <em>a</em>s and creates a list of <em>Maybe b</em>s, which could contain a mixture of <em>Just</em>s
and <em>Nothing</em>s. It then throws away the <em>Nothing</em>s and returns the values contained in the <em>Just</em>s.</p>
<p>To clarify this, imagine we have a function that returns as <em>Just</em> for even numbers and a <em>Nothing</em> for odd numbers.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span> <span class="p">(</span><span class="n">n</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">even</span> <span class="n">n</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">div</span> <span class="n">n</span> <span class="mi">2</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>We can use this as the first parameter to map Maybe</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Data.Maybe</span>
<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="n">mapMaybe</span> <span class="n">f</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">50</span><span class="p">]</span>
</pre></div>
</div>
<p>We use the <em>mapMaybe</em> and the function <em>g</em> to filter the list of UTxOs.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">g</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span>
<span class="nf">g</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">o</span>
    <span class="n">guard</span> <span class="o">$</span> <span class="n">p</span> <span class="n">pkh</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">pkh</span><span class="p">)</span>
</pre></div>
</div>
<p>This function takes a key value pair representing the UTxO and returns a <em>Maybe</em> triple containing the items from the pair alongside a <em>PubKeyHash</em>.</p>
<p>Function <em>g</em> is inside the <em>Maybe</em> monad and makes use of function <em>f</em>, which is also inside the <em>Maybe</em> monad. Function <em>f</em> gets the public key hash from a UTxO,
if it exists. After this, function <em>g</em> uses the <em>guard</em> function with the predicate function <em>p</em> that we passed in as an argument.</p>
<p>The <em>guard</em> function is available in some monads, and the <em>Maybe</em> monad is one of them. It takes a boolean as a parameter, and, if the boolean is false, the computation
fails. In this case, failure means returning <em>Nothing</em>. If it is true, it just continues. In this case, that means returning the <em>Just</em> of the triple containing the
public key hash.</p>
<p>We will see how we use the <em>findSwaps</em> function in a moment.</p>
</div>
<div class="section" id="retrieveswaps">
<h4><span class="section-number">1.6.3.3. </span>retrieveSwaps<a class="headerlink" href="#retrieveswaps" title="Permalink to this headline">¶</a></h4>
<p>The <em>retrieveSwaps</em> contract is for the seller if they want to change their mind and get their Ada back.</p>
<p>Here is where we use the <em>findSwaps</em> function. We use it with <em>(== pkh)</em> as the predicate, meaning that we want only those UTxOs sitting at the swap address that
belong to the operator.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">retrieveSwaps</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">retrieveSwaps</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">findSwaps</span> <span class="n">oracle</span> <span class="p">(</span><span class="o">==</span> <span class="n">pkh</span><span class="p">)</span>
    <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span>
        <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no swaps found&quot;</span>
        <span class="kr">_</span>  <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">])</span> <span class="o">&lt;&gt;</span>
                          <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">swapValidator</span> <span class="n">oracle</span><span class="p">)</span>
                <span class="n">tx</span>      <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
            <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Swapping</span> <span class="n">lookups</span> <span class="n">tx</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;retrieved &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot; swap(s)&quot;</span>
</pre></div>
</div>
<p>If there are none, then there is nothing to do. If there are some, we construct a transaction that retrieves all of them.</p>
<p>To do that, we create a list of <em>mustSpendScriptOutput</em> constraints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tx</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="p">[</span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="o">$</span> <span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div>
</div>
<p>The line looks intimidating, but it is just extracting a list of <em>oref</em>s from the <em>xs</em> list and using it to construct a constraint for each of them, using <em>Unit</em> as
the <em>Redeemer</em> type. The function <em>mconcat</em> applies the <em>Semigroup</em> operator <em>&lt;&gt;</em> throughout the list in order to combine them.</p>
<p>As lookups, we must provide all the UTxOs and the swap validator.</p>
<p>We have the list of UTxOs in <em>xs</em> and we use list comprehension to turn this list into a list of pairs, and we then use <em>Map.fromList</em> to turn those pairs into a
map, to which we then apply the <em>unspentOutputs</em> constraint.</p>
</div>
<div class="section" id="useswaps">
<h4><span class="section-number">1.6.3.4. </span>useSwaps<a class="headerlink" href="#useswaps" title="Permalink to this headline">¶</a></h4>
<p>And now the most interesting one, <em>useSwaps</em>. This is where we actually use the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">useSwap</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">useSwap</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">funds</span> <span class="ow">&lt;-</span> <span class="n">ownFunds</span>
    <span class="kr">let</span> <span class="n">amt</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="n">funds</span> <span class="o">$</span> <span class="n">oAsset</span> <span class="n">oracle</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;available assets: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">amt</span>

    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>           <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;oracle not found&quot;</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
            <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;found oracle, exchange rate &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
            <span class="n">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
            <span class="n">swaps</span> <span class="ow">&lt;-</span> <span class="n">findSwaps</span> <span class="n">oracle</span> <span class="p">(</span><span class="o">/=</span> <span class="n">pkh</span><span class="p">)</span>
            <span class="kr">case</span> <span class="n">find</span> <span class="p">(</span><span class="n">f</span> <span class="n">amt</span> <span class="n">x</span><span class="p">)</span> <span class="n">swaps</span> <span class="kr">of</span>
                <span class="kt">Nothing</span>                <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no suitable swap found&quot;</span>
                <span class="kt">Just</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">,</span> <span class="n">pkh&#39;</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                    <span class="kr">let</span> <span class="n">v</span>       <span class="ow">=</span> <span class="n">txOutValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">)</span>
                        <span class="n">p</span>       <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">$</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o&#39;</span><span class="p">)</span> <span class="n">x</span>
                        <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">swapValidator</span> <span class="n">oracle</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>                   <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">),</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">)])</span>
                        <span class="n">tx</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span>  <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Use</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref&#39;</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span><span class="p">)</span>  <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToOtherScript</span>
                                    <span class="p">(</span><span class="n">validatorHash</span> <span class="o">$</span> <span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">Datum</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="n">x</span><span class="p">)</span>
                                    <span class="n">v</span>                                                                      <span class="o">&lt;&gt;</span>
                                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="n">pkh&#39;</span> <span class="n">p</span>
                    <span class="n">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Swapping</span> <span class="n">lookups</span> <span class="n">tx</span>
                    <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
                    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made swap with price &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="kt">Value</span><span class="o">.</span><span class="n">flattenValue</span> <span class="n">p</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">getPrice</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
    <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="n">x</span>

    <span class="n">f</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="n">amt</span> <span class="n">x</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="o">&lt;=</span> <span class="n">amt</span>
</pre></div>
</div>
<p>First, we use the <em>ownFunds</em> function. This is defined in a separate module that we will get to in a bit. All it does is to add up all the money in our own
wallet and returns a <em>Value</em>. We then find out how many USD Tokens we have.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">funds</span> <span class="ow">&lt;-</span> <span class="n">ownFunds</span>
<span class="kr">let</span> <span class="n">amt</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="n">funds</span> <span class="o">$</span> <span class="n">oAsset</span> <span class="n">oracle</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;available assets: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">amt</span>
</pre></div>
</div>
<p>The <em>findOracle</em> function is defined in the Oracle.Core module from earlier. You will recall that it finds us the oracle UTxO that contains the oracle value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>If we don’t find the oracle, we will just log a message to that effect.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>           <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;oracle not found&quot;</span>
</pre></div>
</div>
<p>If we do find it, we will log a message with the current exchange rate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;found oracle, exchange rate &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</pre></div>
</div>
<p>Next, we check our own public key and check for all available swaps where we are <em>not</em> the owner.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span>   <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
<span class="nf">swaps</span> <span class="ow">&lt;-</span> <span class="n">findSwaps</span> <span class="n">oracle</span> <span class="p">(</span><span class="o">/=</span> <span class="n">pkh</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we use a function <em>find</em> which is from the Haskell prelude, in module <em>Data.List</em>. The <em>find</em> function takes a predicate and a list and <em>Maybe</em> returns one
element of that list that satisfies the predicate.</p>
<p>The function used in the predicate is defined as the helper function <em>f</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">where</span>
    <span class="n">getPrice</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TxOutTx</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
    <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="ow">=</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="n">x</span>

    <span class="n">f</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">PubKeyHash</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="n">amt</span> <span class="n">x</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">getPrice</span> <span class="n">x</span> <span class="n">o</span> <span class="o">&lt;=</span> <span class="n">amt</span>
</pre></div>
</div>
<p>We give it an amount, the current exchange rate, and a UTxO triple. The function determines if there is a swap that is cheaper to or equal to the amount parameter.</p>
<p>Now, we have searched for a swap that we can afford. If we don’t find one, we log a message saying so.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">find</span> <span class="p">(</span><span class="n">f</span> <span class="n">amt</span> <span class="n">x</span><span class="p">)</span> <span class="n">swaps</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>                <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no suitable swap found&quot;</span>
</pre></div>
</div>
<p>If we <em>do</em> find one, we just take the first one. This isn’t very realistic, of course. In a real-world example we would probably specify the exact amount we want to swap. Here,
we are just keeping it simple as we are focussed on oracles rather than swapping.</p>
<p>So, now we construct a transaction.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">txOutValue</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">oFee</span> <span class="n">oracle</span><span class="p">)</span>
</pre></div>
</div>
<p>This is the output for the oracle. It is the same as the input, including any fees that have accumulated there, plus the fee in lovelace that we need to pay.</p>
<p>We then create a <em>Value</em> representing the USD Tokens that we need to pay.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">p</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">oAsset</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">$</span> <span class="n">price</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o&#39;</span><span class="p">)</span> <span class="n">x</span>
</pre></div>
</div>
<p>Now, let’s look at the constraints.</p>
<p>The first constraint is that we must consume the oracle as an input. And here we see the first use of the <em>Use</em> redeemer. We never used this redeemer in the oracle
core itself, as the oracle provider is only responsible for updating values, which uses the <em>Update</em> redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">Use</span><span class="p">)</span>
</pre></div>
</div>
<p>The second constraint is to consume the swap input, which just uses a <em>Unit</em> redeeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref&#39;</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="nb">()</span><span class="p">)</span>
</pre></div>
</div>
<p>The third constraint is to pay the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToOtherScript</span>
    <span class="p">(</span><span class="n">validatorHash</span> <span class="o">$</span> <span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">Datum</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">v</span>
</pre></div>
</div>
<p>Here we use <em>mustPayToOtherScript</em>, specifying the oracle script, because now we have two scripts in play - the oracle script and the swap script. As <em>Datum</em> we use
the exist datum - we mustn’t change it - and as <em>Value</em> we use the value <em>v</em> that we computed earlier.</p>
<p>The final constraint is that we must pay the seller of the lovelace - and the payment is the price <em>p</em> that we calculated before.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="n">pkh&#39;</span> <span class="n">p</span>
</pre></div>
</div>
<p>For lookups, we must provide the validators of the oracle and swap contracts, and we must provide the two UTxOs that we want to consume.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">swapValidator</span> <span class="n">oracle</span><span class="p">)</span>               <span class="o">&lt;&gt;</span>
    <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">oracleValidator</span> <span class="n">oracle</span><span class="p">)</span>                   <span class="o">&lt;&gt;</span>
    <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">),</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">)])</span>
</pre></div>
</div>
<p>Now, the usual - we submit it, wait for confirmation, then log a message.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Swapping</span> <span class="n">lookups</span> <span class="n">tx</span>
<span class="nf">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made swap with price &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="kt">Value</span><span class="o">.</span><span class="n">flattenValue</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="contract-bundle">
<h4><span class="section-number">1.6.3.5. </span>Contract bundle<a class="headerlink" href="#contract-bundle" title="Permalink to this headline">¶</a></h4>
<p>That defines the raw contracts. Now, we provide a bundle that contains all of them.</p>
<p>First, we define, as always, a schema, which defines the endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">SwapSchema</span> <span class="ow">=</span>
    <span class="kt">BlockchainActions</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;offer&quot;</span>    <span class="kt">Integer</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;retrieve&quot;</span> <span class="nb">()</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;use&quot;</span>      <span class="nb">()</span>
        <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;funds&quot;</span>    <span class="nb">()</span>
</pre></div>
</div>
<p>Next, we see the <em>select</em> operator. This use of this operator will cause our code to wait until one of the endpoints is picked, and then executes the
associated code.</p>
<p>The <em>swap</em> function recursively calls itself, offering again and again the same choice of endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">swap</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">swap</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="p">(</span><span class="n">offer</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">retrieve</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">use</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">funds</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">swap</span> <span class="n">oracle</span>
    <span class="kr">where</span>
        <span class="n">offer</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">offer</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">amt</span> <span class="ow">&lt;-</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span>
            <span class="n">offerSwap</span> <span class="n">oracle</span> <span class="n">amt</span>

        <span class="n">retrieve</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">retrieve</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span>
            <span class="n">retrieveSwaps</span> <span class="n">oracle</span>

        <span class="n">use</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">use</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span>
            <span class="n">useSwap</span> <span class="n">oracle</span>

        <span class="n">funds</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">funds</span> <span class="ow">=</span> <span class="n">h</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;funds&quot;</span>
            <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">ownFunds</span>
            <span class="n">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">v</span>

        <span class="n">h</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">SwapSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
        <span class="n">h</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span>
</pre></div>
</div>
<p>The code for the four endpoints are wrappers for the code we have already written.</p>
<p>For <em>offer</em>, for example, we block until we are provided with an <em>amt</em> and then we call the <em>offerSwap</em> contract.</p>
<p>It is the same for the <em>retrieve</em> and <em>use</em> endpoints, except that they require no parameters.</p>
<p>For the <em>funds</em> endpoint it is a little different. The <em>ownFunds</em> function comes from the <em>Funds</em> module, which, as we noted earlier, we have not yet looked at. It gives us the <em>Value</em> that we own. We
then <em>tell</em> this value as a way of reporting to the outside world how much we have.</p>
<p>The <em>h</em> in each of the endpoints is an error handler. Each of the endpoints is wrapped inside the error handler, which just logs the error, but does not halt execution.</p>
<p>And that concludes the swap example.</p>
</div>
</div>
<div class="section" id="funds-module">
<h3><span class="section-number">1.6.4. </span>Funds Module<a class="headerlink" href="#funds-module" title="Permalink to this headline">¶</a></h3>
<p>Now let’s quickly look at the <em>Funds</em> module. It’s a short module that provides two contracts.</p>
<p>The <em>ownFunds</em> function is tasked with summing up all the <em>Value</em> in our own UTxOs.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownFunds</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">Value</span>
<span class="nf">ownFunds</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pk</span>    <span class="ow">&lt;-</span> <span class="n">ownPubKey</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">pubKeyAddress</span> <span class="n">pk</span>
    <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">mconcat</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">elems</span> <span class="o">$</span> <span class="n">txOutValue</span> <span class="o">.</span> <span class="n">txOutTxOut</span> <span class="o">&lt;$&gt;</span> <span class="n">utxos</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;own funds: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="kt">Value</span><span class="o">.</span><span class="n">flattenValue</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">v</span>
</pre></div>
</div>
<p>It does this by looking up our public key, then getting all the UTxOs at that public key address. The <em>utxos</em> are then a map from UTxO references to UTxOs.</p>
<p>As <em>map</em> implements <em>Functor</em> we can map over the map to change the elements to something else. In this case, we change them to <em>Value</em>s by applying the composite
function <em>txOutValue</em> . <em>txOutTxOut</em>.</p>
<p>The <em>Map.elems</em> function ignores the keys and just gives us the values. And, as we saw before, <em>mconcat</em>, when given a <em>Semigroup</em> or <em>Monoid</em> type, will combine the
list of values into one value.</p>
<p>So <em>v</em> is not the sum of all the values of all the UTxOs that we own. Our <em>ownFunds</em> function is a contract that has a return type of <em>Value</em>, we return <em>v</em>.</p>
<p>The function <em>ownFunds’</em> is a variation that, instead of returning the value, permanently tells it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ownFunds&#39;</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Value</span><span class="p">)</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">ownFunds&#39;</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">ownFunds</span> <span class="o">&gt;&gt;=</span> <span class="n">tell</span> <span class="o">.</span> <span class="kt">Last</span> <span class="o">.</span> <span class="kt">Just</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
    <span class="n">ownFunds&#39;</span>
</pre></div>
</div>
<p>This calls the <em>ownFunds</em> function, performs a monadic bind to the composite function <em>tell . Last . Just</em> which tells the value, then it waits for a slot, and then
calls itself. So, every block, it writes the value into the log.</p>
</div>
<div class="section" id="testing">
<h3><span class="section-number">1.6.5. </span>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h3>
<p>We will now write code, using the <em>EmulatorTrace</em> monad, that tests the contracts we have written.</p>
<p>This code can be found in the following module</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week06.Oracle.Test</span>
</pre></div>
</div>
<p>First, we need to define a token that we can test with. The <em>assetSymbol</em> is an arbitrary hash, which is fine for test purposes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assetSymbol</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
<span class="nf">assetSymbol</span> <span class="ow">=</span> <span class="s">&quot;ff&quot;</span>

<span class="nf">assetToken</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">assetToken</span> <span class="ow">=</span> <span class="s">&quot;USDT&quot;</span>
</pre></div>
</div>
<p>This time we are going to use the primed version of <em>runEmulatorTraceIO</em>, which takes two more arguments and gives more fine-grained over the emulation environment.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">emCfg</span> <span class="n">myTrace</span>
  <span class="kr">where</span>
    <span class="n">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
    <span class="n">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">]]</span>

    <span class="n">v</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>                    <span class="mi">100_000_000</span> <span class="o">&lt;&gt;</span>
        <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">assetSymbol</span> <span class="n">assetToken</span> <span class="mi">100_000_000</span>
</pre></div>
</div>
<p>The first argument to <em>runEmulatorTraceIO’</em> determines how the various log messages are displayed. Using <em>def</em>, we have selected the default, which is the same as
in the unprimed version.</p>
<p>The reason we are using the primed version is that we want to configure the initial distribution, and we can do that with the second argument, which here we have
labelled <em>emCfg</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
<span class="nf">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">]]</span>
</pre></div>
</div>
<p>We use this with the helper function <em>v</em> to give everyone 100 million lovelace (100 Ada) and 100 million USD Tokens to begin with.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">v</span> <span class="ow">::</span> <span class="kt">Value</span>
<span class="nf">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>                    <span class="mi">100_000_000</span> <span class="o">&lt;&gt;</span>
    <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">assetSymbol</span> <span class="n">assetToken</span> <span class="mi">100_000_000</span>
</pre></div>
</div>
<p>We define a helper contract, <em>checkOracle</em>, that will continually check the oracle value and log it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkOracle</span> <span class="ow">::</span> <span class="kt">Oracle</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">checkOracle</span> <span class="n">oracle</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">findOracle</span> <span class="n">oracle</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>        <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;Oracle value: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
    <span class="kt">Contract</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="n">checkOracle</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>And now we can define our trace.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">op</span> <span class="ow">=</span> <span class="kt">OracleParams</span>
                <span class="p">{</span> <span class="n">opFees</span> <span class="ow">=</span> <span class="mi">1_000_000</span>
                <span class="p">,</span> <span class="n">opSymbol</span> <span class="ow">=</span> <span class="n">assetSymbol</span>
                <span class="p">,</span> <span class="n">opToken</span>  <span class="ow">=</span> <span class="n">assetToken</span>
                <span class="p">}</span>

    <span class="n">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">runOracle</span> <span class="n">op</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
    <span class="n">oracle</span> <span class="ow">&lt;-</span> <span class="n">getOracle</span> <span class="n">h1</span>

    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">checkOracle</span> <span class="n">oracle</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_500_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>

    <span class="n">h3</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
    <span class="n">h4</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
    <span class="n">h5</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h3</span> <span class="mi">10_000_000</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h4</span> <span class="mi">20_000_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_700_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_800_000</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h3</span> <span class="nb">()</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h4</span> <span class="nb">()</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
  <span class="kr">where</span>
    <span class="n">getOracle</span> <span class="ow">::</span> <span class="kt">ContractHandle</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="kt">Oracle</span>
    <span class="n">getOracle</span> <span class="n">h</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
        <span class="kr">case</span> <span class="n">l</span> <span class="kr">of</span>
            <span class="kt">Last</span> <span class="kt">Nothing</span>       <span class="ow">-&gt;</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="n">getOracle</span> <span class="n">h</span>
            <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">oracle</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="p">(</span><span class="n">show</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>This is all stuff that we have already seen. We define our oracle parameters, setting the oracle fee at 1 million lovelace, and our arbitrary asset class defined earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">op</span> <span class="ow">=</span> <span class="kt">OracleParams</span>
    <span class="p">{</span> <span class="n">opFees</span> <span class="ow">=</span> <span class="mi">1_000_000</span>
    <span class="p">,</span> <span class="n">opSymbol</span> <span class="ow">=</span> <span class="n">assetSymbol</span>
    <span class="p">,</span> <span class="n">opToken</span>  <span class="ow">=</span> <span class="n">assetToken</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Then, we start the oracle and wait for one slot.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">runOracle</span> <span class="n">op</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span>
<span class="nf">oracle</span> <span class="ow">&lt;-</span> <span class="n">getOracle</span> <span class="n">h1</span>
</pre></div>
</div>
<p>We have grabbed a handle to the oracle using the helper function defined in the <em>where</em> clause.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getOracle</span> <span class="ow">::</span> <span class="kt">ContractHandle</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">Oracle</span><span class="p">)</span> <span class="kt">OracleSchema</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="kt">Oracle</span>
<span class="nf">getOracle</span> <span class="n">h</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
    <span class="kr">case</span> <span class="n">l</span> <span class="kr">of</span>
        <span class="kt">Last</span> <span class="kt">Nothing</span>       <span class="ow">-&gt;</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="n">getOracle</span> <span class="n">h</span>
        <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">oracle</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="p">(</span><span class="n">show</span> <span class="n">oracle</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>We need this because the swap contract is parameterized with the oracle value. And this is why we used <em>tell</em> in the <em>runOracle</em> function.</p>
<p>We use the <em>observableState</em> function to get hold of this information. If it does not exist, we wait for a slot, and try again. Otherwise, we log it for debugging
purposes, and the return it.</p>
<p>Next, we use Wallet 2 to execute the <em>checkOracle</em> function which we saw earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">checkOracle</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>We then initialize the oracle to an exchange rate of 1.5 Ada, and wait for 3 slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_500_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>We now call the <em>ownFunds’</em> function on Wallets 1, 3, 4 and 5 to check the initial balances.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="n">ownFunds&#39;</span>
</pre></div>
</div>
<p>Then we start the swap contract on Wallets 3, 4, and 5.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h3</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
<span class="nf">h4</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">4</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
<span class="nf">h5</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">5</span><span class="p">)</span> <span class="o">$</span> <span class="n">swap</span> <span class="n">oracle</span>
</pre></div>
</div>
<p>Then we try some scenarios. First, Wallets 3 and 4 offer 10 and 20 Ada for swap respectively.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h3</span> <span class="mi">10_000_000</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;offer&quot;</span> <span class="n">h4</span> <span class="mi">20_000_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>And now Wallet 5 uses the swap. It will pick one of the two. It is not obvious which one, whichever it finds first. Remember that we only wrote code that would find
the first affordable slot. It will then pay USD Token for it. The amount paid will depend on the current value of the oracle.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Now, Wallet 1 updates the oracle value to 1.7. This also results in the accumulated fees (1 Ada) being paid to Wallet 1.</p>
<blockquote>
<div><p>callEndpoint &#64;”update” h1 1_700_000
void $ Emulator.waitNSlots 3</p>
</div></blockquote>
<p>Then, Wallet 5 tries again, grabbing the remaining swap, but now paying a different USD Token price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;use&quot;</span> <span class="n">h5</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>We then set the oracle value to 1.8.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;update&quot;</span> <span class="n">h1</span> <span class="mi">1_800_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>This will allow Wallet 1 to collect the fees. The oracle value didn’t actually need to change for this to happen.</p>
<p>Wallets 3 and 4 now issues <em>retrieve</em> requests to get back any funds that have not been bought. This will result in no funds being returned because all the swaps
have been used.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h3</span> <span class="nb">()</span>
<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;retrieve&quot;</span> <span class="n">h4</span> <span class="nb">()</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>
</pre></div>
</div>
<p>And that’s it. So let’s run it in the REPL.</p>
<div class="section" id="test-in-the-repl">
<h4><span class="section-number">1.6.5.1. </span>Test in the REPL<a class="headerlink" href="#test-in-the-repl" title="Permalink to this headline">¶</a></h4>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="kr">import</span> <span class="nn">Week06.Oracle.Test</span>
<span class="kt">Prelude</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Test</span> <span class="kt">Week06</span><span class="o">.</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">Core</span><span class="o">&gt;</span> <span class="n">test</span>
</pre></div>
</div>
<p>There will be a lot of output.</p>
<p>Let’s look at some key parts. First, slot 3, where the oracle is created. Here we get the <em>oSymbol</em> value that we can use for everything else.</p>
<p>We also see in slot 3 that <em>getOracle</em> is started which will log the value of the oracle, for our information, every slot from now on.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;started oracle Oracle {oSymbol = 6122edd57c938cda24066f434da9aee55120b4eb362d4a1bd37547ef6e4a6cbb, oOperator = 21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9, oFee = 1000000, oAsset = (ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">)}&quot;</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="n">Oracle</span> <span class="p">{</span><span class="n">oSymbol</span> <span class="o">=</span> <span class="mi">6122</span><span class="n">edd57c938cda24066f434da9aee55120b4eb362d4a1bd37547ef6e4a6cbb</span><span class="p">,</span> <span class="n">oOperator</span> <span class="o">=</span> <span class="mi">21</span><span class="n">fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9</span><span class="p">,</span> <span class="n">oFee</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">,</span> <span class="n">oAsset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ff</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">)}</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;update&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1500000.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">93</span><span class="n">fab1c0845a5b96863a50d248fa2de68bd6702185e3de92ae0c58b869569909</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">93</span><span class="n">fab1c0845a5b96863a50d248fa2de68bd6702185e3de92ae0c58b869569909</span>
</pre></div>
</div>
<p>And, in slot 4, we see the first value that <em>getOracle</em> finds is 1,500,000.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Oracle value: 1500000&quot;</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;set initial oracle value to 1500000&quot;</span>
</pre></div>
</div>
<p>Slot 6 is the result of all the <em>activateContractWallet</em> calls. These do not necessarily appear in the same order as in the code. Notice that Wallet 1 has slightly
fewer Ada than the other wallets. This is because Wallet 1 started the oracle and needed to pay transaction fees for that.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000003</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000004</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">4</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,99999970),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000005</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">5</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000006</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000007</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">4</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000008</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">5</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Oracle value: 1500000&quot;</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000006</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;offer&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1.0e7</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">W3</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">8274315</span><span class="n">b83fb8b4d721146a75772cf39be3f96730557bd6021235864f0f37bc6</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000007</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">4</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;offer&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">2.0e7</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">W4</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">221</span><span class="n">f86cc1d6087a5967793aaf9eb078d8ec0677b2d6aca586f985f6f2c57a100</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">221</span><span class="n">f86cc1d6087a5967793aaf9eb078d8ec0677b2d6aca586f985f6f2c57a100</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">8274315</span><span class="n">b83fb8b4d721146a75772cf39be3f96730557bd6021235864f0f37bc6</span>
</pre></div>
</div>
<p>In slot 7, the offers of 10 Ada and 20 Ada are made.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,99999970),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;offered 10000000 lovelace for swap&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,89999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;offered 20000000 lovelace for swap&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,79999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,100000000),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;Oracle value: 1500000&quot;</span>
</pre></div>
</div>
<p>In slot 9, the first <em>use</em> is requested.</p>
<p>And in slot 10, we see the swap happen.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,99999970),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,89999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,79999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,130000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;made swap with price [(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,30000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,118999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,70000000)]&quot;</span>
</pre></div>
</div>
<p>The oracle gets and update request in slot 12.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;update&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1700000.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">ff7e1fbfb51897b100dcfdf551ad9a03886432af0a9fa92ff8dd986a0f7c90fe</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">ff7e1fbfb51897b100dcfdf551ad9a03886432af0a9fa92ff8dd986a0f7c90fe</span>
</pre></div>
</div>
<p>And we see it happen in slot 13.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00013</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;updated oracle value to 1700000&quot;</span>
</pre></div>
</div>
<p>The second <em>use</em> request arrives at slot 15.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000008</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">5</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;use&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[])]))])</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;own funds: [(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,118999990),(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,70000000)]&quot;</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;available assets: 70000000&quot;</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;found oracle, exchange rate 1700000&quot;</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">W5</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">84</span><span class="n">bec9a9044eee9c5b40029dca5bbc8346214504e5adb4745bbe6e5d7d96078e</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">84</span><span class="n">bec9a9044eee9c5b40029dca5bbc8346214504e5adb4745bbe6e5d7d96078e</span>
</pre></div>
</div>
<p>And the swap happens at slot 16.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;made swap with price [(ff,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,17000000)]&quot;</span>
</pre></div>
</div>
<p>And at the bottom, we see the final balances.</p>
<p>Wallet 2 still has all its funds. All Wallet 2 has done is the oracle checking, which doesn’t cost anything, as it is purely an off-chain matter.</p>
<p>Wallet 1 paid some transaction fees but ends up with roughly 2 Ada more than it started with. This is because it collected the 2 Ada in fees for the use of the oracle.</p>
<p>Wallets 3 and 4 both made offers, and their balances reflect the exchange rates at which their offers were accepted.</p>
<p>Wallet 5 was the one accepting the offers, and so has the additional Ada, but a reduced USD Token balance. Note that Wallet 5 has also had some fees deducted from its
Ada balance.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">101999950</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">117000000</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">89999990</span>
<span class="n">Wallet</span> <span class="mi">4</span><span class="p">:</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">130000000</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">79999990</span>
<span class="n">Wallet</span> <span class="mi">5</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">127999980</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">53000000</span>
<span class="n">Wallet</span> <span class="mi">6</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">7</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">8</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">9</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
<span class="n">Wallet</span> <span class="mi">10</span><span class="p">:</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s2">&quot;USDT&quot;</span><span class="p">}:</span> <span class="mi">100000000</span>
</pre></div>
</div>
<p>And finally, as well as the wallets, we see that the oracle is still going, and still owns the NFT. Note that, in this log, we don’t see the datum value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Script</span> <span class="n">cc6a43073dce46eebc7b309223904c7a8033ffab7d9b239cf013342d4c69a5d6</span><span class="p">:</span>
    <span class="p">{</span><span class="mi">6122</span><span class="n">edd57c938cda24066f434da9aee55120b4eb362d4a1bd37547ef6e4a6cbb</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="plutus-application-backend">
<h3><span class="section-number">1.6.6. </span>Plutus Application Backend<a class="headerlink" href="#plutus-application-backend" title="Permalink to this headline">¶</a></h3>
<p>Apart from the idea of how to implement an oracle in Plutus, nothing we have done in this lecture so far is new, except for a few library functions and Haskell
techniques. In principle, we are familiar with the way validators are written for off-chain code and how contracts are written for on-chain code, and how we
can test our code with the <em>EmulatorTrace</em> monad.</p>
<p>But now we will talk about something new - the Plutus Application Backend (PAB), which allows us to take all the stuff we have done and turn it into an executable that
runs the contracts.</p>
<p>If the testnet or the mainnet were available with Plutus support, we could deploy such an application, but for now we will need to be happy with a simulated blockchain.
But, the process of turning the code into a dApp is practically the same as it would be on a real blockchain.</p>
<p>We need one more tiny module, which is basically just a type definition. It is so small, we can include the entire file contents here.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE DeriveAnyClass     #-}</span>
<span class="cm">{-# LANGUAGE DeriveGeneric      #-}</span>

<span class="kr">module</span> <span class="nn">Week06.Oracle.PAB</span>
    <span class="p">(</span> <span class="kt">OracleContracts</span> <span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span>           <span class="nn">Data.Aeson</span>                <span class="p">(</span><span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Data.Text.Prettyprint.Doc</span> <span class="p">(</span><span class="kt">Pretty</span> <span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="nf">viaShow</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">GHC.Generics</span>              <span class="p">(</span><span class="kt">Generic</span><span class="p">)</span>
<span class="kr">import</span>           <span class="nn">Ledger</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Week06.Oracle.Core</span>        <span class="k">as</span> <span class="n">Oracle</span>

<span class="kr">data</span> <span class="kt">OracleContracts</span> <span class="ow">=</span> <span class="kt">Init</span> <span class="o">|</span> <span class="kt">Oracle</span> <span class="kt">CurrencySymbol</span> <span class="o">|</span> <span class="kt">Swap</span> <span class="kt">Oracle</span><span class="o">.</span><span class="kt">Oracle</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Pretty</span> <span class="kt">OracleContracts</span> <span class="kr">where</span>
    <span class="n">pretty</span> <span class="ow">=</span> <span class="n">viaShow</span>
</pre></div>
</div>
<p>The idea is that it reifies the contract instances that we want to run. We have various contracts, and we want to have a data type where each value of the data type
corresponds to a contact that we eventually want to run.</p>
<p>The <em>Init</em> constructor will be used to setup an environment where there is a USD Token available and where the wallets have an initial supply of those.</p>
<p>The <em>Oracle</em> constructor corresponds to the <em>runOracle</em> contract that will start the oracle and provide the <em>update</em> endpoint, and the <em>CurrencySymbol</em> parameter is
going to be used for the USD Token.</p>
<p>Finally, the <em>Swap</em>, parameterized by <em>Oracle</em> will be used to run the swap contract, which provides various endpoints like <em>offer</em>, <em>retrieve</em>, <em>use</em> and <em>funds</em>.</p>
<p>We need to put the <em>OracleContracts</em> definition in a separate module because we will use it both from the PAB and also from the front end.</p>
<p>We are going to look at the Cabal file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week06</span><span class="o">.</span><span class="n">cabal</span>
</pre></div>
</div>
<p>In it we have definitions for various executables.</p>
<p>The <em>oracle-pab</em> executable will set up a simulated wallet, initialize all the contracts and setup a web server that allows the outside world
to interact with these contracts.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">executable</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span><span class="o">.</span><span class="n">hs</span>
<span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="p">:</span>      <span class="n">app</span>
<span class="n">ghc</span><span class="o">-</span><span class="n">options</span><span class="p">:</span>         <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">threaded</span>
<span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="p">:</span>       <span class="n">aeson</span>
                   <span class="p">,</span> <span class="n">base</span> <span class="o">^&gt;=</span> <span class="mf">4.14</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">freer</span><span class="o">-</span><span class="n">extras</span>
                   <span class="p">,</span> <span class="n">freer</span><span class="o">-</span><span class="n">simple</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">contract</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">ledger</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pab</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week06</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">use</span><span class="o">-</span><span class="n">cases</span>
                   <span class="p">,</span> <span class="n">text</span>
</pre></div>
</div>
<p>The <em>oracle-client</em> executable will be run by the oracle provider, so that will interact with the <em>runOracle</em> contract. It will also fetch exchange rates from the
internet and feed them into the system.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">executable</span> <span class="n">oracle</span><span class="o">-</span><span class="n">client</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">oracle</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
<span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="p">:</span>      <span class="n">app</span>
<span class="n">ghc</span><span class="o">-</span><span class="n">options</span><span class="p">:</span>         <span class="o">-</span><span class="n">Wall</span>
<span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="p">:</span>       <span class="n">base</span> <span class="o">^&gt;=</span> <span class="mf">4.14</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">bytestring</span>
                   <span class="p">,</span> <span class="n">regex</span><span class="o">-</span><span class="n">tdfa</span> <span class="o">^&gt;=</span> <span class="mf">1.3</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">req</span> <span class="o">^&gt;=</span> <span class="mf">3.9</span><span class="o">.</span><span class="mi">0</span>
                   <span class="p">,</span> <span class="n">text</span>
                   <span class="p">,</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>Then there is the <em>swap-client</em> executable that will be run by the clients who want to make use of the swap contract.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">executable</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
<span class="n">hs</span><span class="o">-</span><span class="n">source</span><span class="o">-</span><span class="n">dirs</span><span class="p">:</span>      <span class="n">app</span>
<span class="n">ghc</span><span class="o">-</span><span class="n">options</span><span class="p">:</span>         <span class="o">-</span><span class="n">Wall</span>
<span class="n">build</span><span class="o">-</span><span class="n">depends</span><span class="p">:</span>       <span class="n">aeson</span>
                   <span class="p">,</span> <span class="n">base</span> <span class="o">^&gt;=</span> <span class="mf">4.14</span><span class="o">.</span><span class="mf">1.0</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">ledger</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pab</span>
                   <span class="p">,</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week06</span>
                   <span class="p">,</span> <span class="n">req</span> <span class="o">^&gt;=</span> <span class="mf">3.9</span><span class="o">.</span><span class="mi">0</span>
                   <span class="p">,</span> <span class="n">text</span>
                   <span class="p">,</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>We will look at each of these in turn.</p>
<p>The code for each of these apps can be found in the <em>app</em> directory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">/</span><span class="n">oracle</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
<span class="n">app</span><span class="o">/</span><span class="n">oracle</span><span class="o">-</span><span class="n">pab</span><span class="o">.</span><span class="n">hs</span>
<span class="n">app</span><span class="o">/</span><span class="n">swap</span><span class="o">-</span><span class="n">client</span><span class="o">.</span><span class="n">hs</span>
</pre></div>
</div>
<div class="section" id="oracle-pab">
<h4><span class="section-number">1.6.6.1. </span>Oracle PAB<a class="headerlink" href="#oracle-pab" title="Permalink to this headline">¶</a></h4>
<p>First some boilerplate to hook up the data type we just defined - the reified contract instances - with the schemas and contracts that we defined earlier.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handleOracleContracts</span> <span class="ow">::</span>
    <span class="p">(</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">Error</span> <span class="kt">PABError</span><span class="p">)</span> <span class="n">effs</span>
    <span class="p">,</span> <span class="kt">Member</span> <span class="p">(</span><span class="kt">LogMsg</span> <span class="p">(</span><span class="kt">PABMultiAgentMsg</span> <span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)))</span> <span class="n">effs</span>
    <span class="p">)</span>
    <span class="ow">=&gt;</span> <span class="kt">ContractEffect</span> <span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span>
    <span class="o">~&gt;</span> <span class="kt">Eff</span> <span class="n">effs</span>
<span class="nf">handleOracleContracts</span> <span class="ow">=</span> <span class="n">handleBuiltin</span> <span class="n">getSchema</span> <span class="n">getContract</span> <span class="kr">where</span>
    <span class="n">getSchema</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
        <span class="kt">Init</span>     <span class="ow">-&gt;</span> <span class="n">endpointsToSchemas</span> <span class="o">@</span><span class="kt">Empty</span>
        <span class="kt">Oracle</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">endpointsToSchemas</span> <span class="o">@</span><span class="p">(</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">OracleSchema</span> <span class="o">.\\</span> <span class="kt">BlockchainActions</span><span class="p">)</span>
        <span class="kt">Swap</span> <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">endpointsToSchemas</span> <span class="o">@</span><span class="p">(</span><span class="kt">Oracle</span><span class="o">.</span><span class="kt">SwapSchema</span>   <span class="o">.\\</span> <span class="kt">BlockchainActions</span><span class="p">)</span>
    <span class="n">getContract</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">case</span>
        <span class="kt">Init</span>        <span class="ow">-&gt;</span> <span class="kt">SomeBuiltin</span>   <span class="n">initContract</span>
        <span class="kt">Oracle</span> <span class="n">cs</span>   <span class="ow">-&gt;</span> <span class="kt">SomeBuiltin</span> <span class="o">$</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">runOracle</span> <span class="o">$</span> <span class="n">oracleParams</span> <span class="n">cs</span>
        <span class="kt">Swap</span> <span class="n">oracle</span> <span class="ow">-&gt;</span> <span class="kt">SomeBuiltin</span> <span class="o">$</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">swap</span> <span class="n">oracle</span>
</pre></div>
</div>
<p><em>Init</em> won’t have any schema, so it just has <em>BlockChainActions</em>. <em>Oracle</em> uses the <em>OracleSchema</em> and <em>Swap</em> uses the <em>SwapSchema</em>. No surprise there.</p>
<p><em>Init</em> will run the <em>initContract</em>, which we will see in a moment.</p>
<p><em>Oracle</em> will run the <em>runOracle</em> contract with <em>oracleParams</em> which takes the currency symbol of the USD Token and defines example oracle params.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">oracleParams</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">Oracle</span><span class="o">.</span><span class="kt">OracleParams</span>
<span class="nf">oracleParams</span> <span class="n">cs</span> <span class="ow">=</span> <span class="kt">Oracle</span><span class="o">.</span><span class="kt">OracleParams</span>
    <span class="p">{</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">opFees</span>   <span class="ow">=</span> <span class="mi">1_000_000</span>
    <span class="p">,</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">opSymbol</span> <span class="ow">=</span> <span class="n">cs</span>
    <span class="p">,</span> <span class="kt">Oracle</span><span class="o">.</span><span class="n">opToken</span>  <span class="ow">=</span> <span class="n">usdt</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>And finally <em>Swap</em> will run our swap contract with an oracle value.</p>
<p>Here is some more copy/paste boilerplate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">handlers</span> <span class="ow">::</span> <span class="kt">SimulatorEffectHandlers</span> <span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span>
<span class="nf">handlers</span> <span class="ow">=</span>
    <span class="kt">Simulator</span><span class="o">.</span><span class="n">mkSimulatorHandlers</span> <span class="o">@</span><span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span> <span class="kt">[]</span>
    <span class="o">$</span> <span class="n">interpret</span> <span class="n">handleOracleContracts</span>
</pre></div>
</div>
<p>And here is the <em>initContract</em> function we mentioned just a moment ago.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">initContract</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">CurrencySymbol</span><span class="p">)</span> <span class="kt">BlockchainActions</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">initContract</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">ownPK</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="n">ownPubKey</span>
    <span class="n">cur</span>   <span class="ow">&lt;-</span>
        <span class="n">mapError</span> <span class="p">(</span><span class="n">pack</span> <span class="o">.</span> <span class="n">show</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Currency</span><span class="o">.</span><span class="n">forgeContract</span> <span class="n">ownPK</span> <span class="p">[(</span><span class="n">usdt</span><span class="p">,</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">length</span> <span class="n">wallets</span><span class="p">)</span> <span class="o">*</span> <span class="n">amount</span><span class="p">)]</span>
        <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">CurrencySymbol</span><span class="p">)</span> <span class="kt">BlockchainActions</span> <span class="kt">Currency</span><span class="o">.</span><span class="kt">CurrencyError</span> <span class="kt">Currency</span><span class="o">.</span><span class="kt">OneShotCurrency</span><span class="p">)</span>
    <span class="kr">let</span> <span class="n">cs</span> <span class="ow">=</span> <span class="kt">Currency</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="n">cur</span>
        <span class="n">v</span>  <span class="ow">=</span> <span class="kt">Value</span><span class="o">.</span><span class="n">singleton</span> <span class="n">cs</span> <span class="n">usdt</span> <span class="n">amount</span>
    <span class="n">forM_</span> <span class="n">wallets</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">pkh</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="n">w</span>
        <span class="n">when</span> <span class="p">(</span><span class="n">pkh</span> <span class="o">/=</span> <span class="n">ownPK</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">tx</span> <span class="ow">&lt;-</span> <span class="n">submitTx</span> <span class="o">$</span> <span class="n">mustPayToPubKey</span> <span class="n">pkh</span> <span class="n">v</span>
            <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">tx</span>
    <span class="n">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">cs</span>
  <span class="kr">where</span>
    <span class="n">amount</span> <span class="ow">::</span> <span class="kt">Integer</span>
    <span class="n">amount</span> <span class="ow">=</span> <span class="mi">100_000_000</span>
</pre></div>
</div>
<p>The <em>initContract</em> function mints USD Tokens and distributes them to the wallets, then it <em>tell</em>s the currency symbol for the USD Token.</p>
<p>The wallets are hardcoded earlier in the code. The number of wallets and the tokens given to them are completely arbitrary.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">wallets</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Wallet</span><span class="p">]</span>
<span class="nf">wallets</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Wallet</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]]</span>
</pre></div>
</div>
<p>Now we can look at the actual PAB code.</p>
<p>For the first time, we see a <em>main</em> function, which is the entry point for the executable.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">runSimulationWith</span> <span class="n">handlers</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="kt">Simulator</span><span class="o">.</span><span class="n">logString</span> <span class="o">@</span><span class="p">(</span><span class="kt">Builtin</span> <span class="kt">OracleContracts</span><span class="p">)</span> <span class="s">&quot;Starting Oracle PAB webserver. Press enter to exit.&quot;</span>
    <span class="n">shutdown</span> <span class="ow">&lt;-</span> <span class="kt">PAB</span><span class="o">.</span><span class="kt">Server</span><span class="o">.</span><span class="n">startServerDebug</span>

    <span class="n">cidInit</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">Init</span>
    <span class="n">cs</span>      <span class="ow">&lt;-</span> <span class="n">waitForLast</span> <span class="n">cidInit</span>
    <span class="kr">_</span>       <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">waitUntilFinished</span> <span class="n">cidInit</span>

    <span class="n">cidOracle</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Oracle</span> <span class="n">cs</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="s">&quot;oracle.cid&quot;</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cidOracle</span>
    <span class="n">oracle</span> <span class="ow">&lt;-</span> <span class="n">waitForLast</span> <span class="n">cidOracle</span>

    <span class="n">forM_</span> <span class="n">wallets</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span>
        <span class="n">when</span> <span class="p">(</span><span class="n">w</span> <span class="o">/=</span> <span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
            <span class="n">cid</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="n">w</span> <span class="o">$</span> <span class="kt">Swap</span> <span class="n">oracle</span>
            <span class="n">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="p">(</span><span class="sc">&#39;W&#39;</span> <span class="kt">:</span> <span class="n">show</span> <span class="p">(</span><span class="n">getWallet</span> <span class="n">w</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;.cid&quot;</span><span class="p">)</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cid</span>

    <span class="n">void</span> <span class="o">$</span> <span class="n">liftIO</span> <span class="n">getLine</span>
    <span class="n">shutdown</span>
</pre></div>
</div>
<p>The <em>main</em> function makes use of another monad that we haven’t seen before and is specific to the PAB - the <em>Simulator</em> monad.</p>
<p>The <em>Simulator</em> monad is very similar to the <em>EmulatorTrace</em> monad. In principle it has the same capabilities. You can start contracts on wallets, you can inspect
the state using the log, you can call endpoints, and so on.</p>
<p>It is a bit unfortunate that there are two monads for this as they are so similar. The Plutus team plan to align them and maybe turn them into one. So it may not be
worth learning the intricacies of the <em>Simulator</em> monad as it will probably change soon.</p>
<p>Similar to the <em>runEmulatorTraceIO</em>, we have <em>runSimulationWith</em> to which we pass the <em>handlers</em> boilerplate.</p>
<p>One significant difference to the <em>EmulatorTrace</em> monad though is that the <em>EmulatorTrace</em> monad was pure code - there were no real world side-effects, no IO involved. In particular there is a pure interpreter <em>runEmulatorTrace</em> that is a pure Haskell function with no side-effects.</p>
<p><em>Simulator</em> s different - you can do IO. The way it works is using <em>MonadIO</em>, which has one method, <em>liftIO</em>, which takes an <em>IO</em> action and <em>lifts</em> it into the monad
in question. So, if you have some arbitrary IO action that you can do in Haskell, then by applying <em>liftIO</em> to it, you can move it into this <em>Simulator</em> monad.</p>
<p>Apart from that, if you squint, it looks very similar to an <em>EmulatorTrace</em>.</p>
<p>The first thing we do is use <em>logString</em> to log that we are starting the PAB server. We then call the <em>startServerDebug</em> function, and the return value of that
function which gets bound to <em>shutdown</em> can be used later to shut down the server.</p>
<p>Now we use something called <em>activateContract</em> which is the equivalent of <em>activateContractWallet</em> from the <em>EmulatorTrace</em> monad.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cidInit</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">Init</span>
</pre></div>
</div>
<p>It takes a wallet where we want to start that instance, and then a value of the reified contract type. Remember that we associated the <em>Init</em> constructor with the
<em>initContract</em> function.</p>
<p>Now we need the currency symbol. This is an example of how we get information out of a contract using <em>tell</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cs</span> <span class="ow">&lt;-</span> <span class="n">waitForLast</span> <span class="n">cidInit</span>
</pre></div>
</div>
<p>The function <em>cidInit</em> uses a function from the <em>Simulator</em> monad called <em>waitForState</em>, which takes a contract instance and a predicate. The predicate gets a
JSON expression and returns a <em>Maybe a</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">waitForLast</span> <span class="ow">::</span> <span class="kt">FromJSON</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">ContractInstanceId</span> <span class="ow">-&gt;</span> <span class="kt">Simulator</span><span class="o">.</span><span class="kt">Simulation</span> <span class="n">t</span> <span class="n">a</span>
<span class="nf">waitForLast</span> <span class="n">cid</span> <span class="ow">=</span>
    <span class="n">flip</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">waitForState</span> <span class="n">cid</span> <span class="o">$</span> <span class="nf">\</span><span class="n">json</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">fromJSON</span> <span class="n">json</span> <span class="kr">of</span>
        <span class="kt">Success</span> <span class="p">(</span><span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span>
        <span class="kr">_</span>                       <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>The idea is that it will read the state of the contract which we wrote using <em>tell</em>. This is serialized as a JSON value, and it applies this JSON value to the
provided predicate. If the result is <em>Nothing</em>, it simply waits until the state changes again. But, if it is <em>Just x</em>, it will return the <em>x</em>.</p>
<p>There are two ways it could be <em>Nothing</em> - either the JSON parsing could fail, or we could get a <em>Last Nothing</em>. So, the end result is that the function waits until
the state of the contract has told a <em>Just</em> value.</p>
<p>At this point we have the currency symbol bound to <em>cs</em>. And then we wait until <em>initContract</em> has finished.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">waitUntilFinished</span> <span class="n">cidInit</span>
</pre></div>
</div>
<p>The next step is to start the oracle on Wallet 1, using the <em>cs</em> value we have recently obtained.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cidOracle</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Oracle</span> <span class="n">cs</span>
</pre></div>
</div>
<p>In order to interact with the oracle contract from the outside world, e.g. from the web interface, we need to get our hands on the <em>cidOracle</em> handle.</p>
<p>So what we do is write this into a file called <em>oracle.cid</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="s">&quot;oracle.cid&quot;</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cidOracle</span>
</pre></div>
</div>
<p>This is just quick and dirty for the demonstration. In production code you would use a safer mechanism.</p>
<p>Now we use <em>waitForLast</em> again to get the oracle value, which we have provided from the <em>runOracle</em> contract via a <em>tell</em>. We need this because the swap contract
is parameterized by this value.</p>
<p>At this stage the NFT is minted and we know what the oracle value is.</p>
<p>Next, we loop over all the wallets, except wallet 1 which runs the oracle, and we activate the swap contract on each of them. Here we use a similar file-writing method
to get hold of the contract handles.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">forM_</span> <span class="n">wallets</span> <span class="o">$</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">w</span> <span class="o">/=</span> <span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">cid</span> <span class="ow">&lt;-</span> <span class="kt">Simulator</span><span class="o">.</span><span class="n">activateContract</span> <span class="n">w</span> <span class="o">$</span> <span class="kt">Swap</span> <span class="n">oracle</span>
        <span class="n">liftIO</span> <span class="o">$</span> <span class="n">writeFile</span> <span class="p">(</span><span class="sc">&#39;W&#39;</span> <span class="kt">:</span> <span class="n">show</span> <span class="p">(</span><span class="n">getWallet</span> <span class="n">w</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;.cid&quot;</span><span class="p">)</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">unContractInstanceId</span> <span class="n">cid</span>
</pre></div>
</div>
<p>Now we just block until the user presses enter, and then we shutdown the server.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">liftIO</span> <span class="n">getLine</span>
<span class="nf">shutdown</span>
</pre></div>
</div>
<p>It is not actually necessary to do all of this, because you can also start and stop contract instances from the web interface. It was easier for us here to do it in a
scripted way for the demo, but in principle you could just start the simulator and then wait until you shutdown.</p>
<p>If you are curious about the API provided by the PAB, you can check that in the <em>plutus-pab</em> package, in the module <em>Plutus.PAB.Webserver.API</em>. There are several, but
the one that we are using here is:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | PAB client API for contracts of type @t@. Examples of @t@ are</span>
<span class="c1">--   * Contract executables that reside in the user&#39;s file system</span>
<span class="c1">--   * &quot;Builtin&quot; contracts that run in the same process as the PAB (ie. the PAB is compiled &amp; distributed with these contracts)</span>
<span class="kr">type</span> <span class="kt">NewAPI</span> <span class="n">t</span> <span class="n">walletId</span> <span class="c1">-- see note [WalletID type in wallet API]</span>
    <span class="ow">=</span> <span class="s">&quot;api&quot;</span> <span class="kt">:&gt;</span> <span class="s">&quot;new&quot;</span> <span class="kt">:&gt;</span> <span class="s">&quot;contract&quot;</span> <span class="kt">:&gt;</span>
        <span class="p">(</span><span class="s">&quot;activate&quot;</span> <span class="kt">:&gt;</span> <span class="kt">ReqBody</span> <span class="kt">&#39;[ JSON]</span> <span class="p">(</span><span class="kt">ContractActivationArgs</span> <span class="n">t</span><span class="p">)</span> <span class="kt">:&gt;</span> <span class="kt">Post</span> <span class="kt">&#39;[JSON]</span> <span class="kt">ContractInstanceId</span> <span class="c1">-- start a new instance</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;instance&quot;</span> <span class="kt">:&gt;</span>
                    <span class="p">(</span><span class="kt">Capture</span> <span class="s">&quot;contract-instance-id&quot;</span> <span class="kt">Text</span> <span class="kt">:&gt;</span>
                        <span class="p">(</span> <span class="s">&quot;status&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[JSON]</span> <span class="p">(</span><span class="kt">ContractInstanceClientState</span> <span class="n">t</span><span class="p">)</span> <span class="c1">-- Current status of contract instance</span>
                        <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;endpoint&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Capture</span> <span class="s">&quot;endpoint-name&quot;</span> <span class="kt">String</span> <span class="kt">:&gt;</span> <span class="kt">ReqBody</span> <span class="kt">&#39;[JSON]</span> <span class="kt">JSON</span><span class="o">.</span><span class="kt">Value</span> <span class="kt">:&gt;</span> <span class="kt">Post</span> <span class="kt">&#39;[JSON]</span> <span class="nb">()</span> <span class="c1">-- Call an endpoint. Make</span>
                        <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;stop&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Put</span> <span class="kt">&#39;[JSON]</span> <span class="nb">()</span> <span class="c1">-- Terminate the instance.</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;instances&quot;</span> <span class="kt">:&gt;</span> <span class="s">&quot;wallet&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Capture</span> <span class="s">&quot;wallet-id&quot;</span> <span class="n">walletId</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[JSON]</span> <span class="p">[</span><span class="kt">ContractInstanceClientState</span> <span class="n">t</span><span class="p">]</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;instances&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[ JSON]</span> <span class="p">[</span><span class="kt">ContractInstanceClientState</span> <span class="n">t</span><span class="p">]</span> <span class="c1">-- list of all active contract instances</span>
            <span class="kt">:&lt;|&gt;</span> <span class="s">&quot;definitions&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="kt">&#39;[JSON]</span> <span class="p">[</span><span class="kt">ContractSignatureResponse</span> <span class="n">t</span><span class="p">]</span> <span class="c1">-- list of available contracts</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>This makes use of the popular Haskell library <em>Servant</em> to write type safe web applications, but it should be readable more or less without knowledge of the <em>Servant</em>
library. For example, you can see the <em>/api/new/contract/activate</em> endpoint declared to which you can POST a <em>ContractActivationArgs</em> as its body and returns a <em>ContractInstanceId</em>.</p>
<p>There is also a web socket API, but we have not used that in this example.</p>
<p>So let’s try our executable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span>
</pre></div>
</div>
<p>We get log output similar to what we see with <em>EmulatorTrace</em>, but this is now a live server.</p>
<p>The output below is reduced to avoid the full verbosity.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">0</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">af5e6d25b5ecb26185289a03d50786b7ac4425b21849143ed7e18bcd70dc4db8</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Starting</span> <span class="n">Oracle</span> <span class="n">PAB</span> <span class="n">webserver</span><span class="o">.</span> <span class="n">Press</span> <span class="n">enter</span> <span class="n">to</span> <span class="n">exit</span><span class="o">.</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Starting</span> <span class="n">PAB</span> <span class="n">backend</span> <span class="n">server</span> <span class="n">on</span> <span class="n">port</span><span class="p">:</span> <span class="mi">8080</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="n">dda39c83</span><span class="o">-</span><span class="mi">5</span><span class="n">a0f</span><span class="o">-</span><span class="mi">484</span><span class="n">f</span><span class="o">-</span><span class="n">b49a</span><span class="o">-</span><span class="mi">9943</span><span class="n">b1ff5526</span> <span class="n">on</span> <span class="n">W1</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
                     <span class="n">Tx</span><span class="p">:</span>
                       <span class="n">Tx</span> <span class="n">da767478580878690990b3a22387be9c5b27fabed2c0ca7b9991eb682a6781f8</span><span class="p">:</span>
                         <span class="p">{</span><span class="n">inputs</span><span class="p">:</span>
                         <span class="n">outputs</span><span class="p">:</span>
                           <span class="o">-</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)])])</span> <span class="n">addressed</span> <span class="n">to</span>
                             <span class="n">addressed</span> <span class="n">to</span> <span class="n">ScriptCredential</span><span class="p">:</span> <span class="n">e9827f1a9e43109d1c8d4555913734b8c48a467a31061b312959f270850fc8a0</span> <span class="p">(</span><span class="n">no</span> <span class="n">staking</span> <span class="n">credential</span><span class="p">)</span>
                         <span class="n">forge</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[])</span>
                         <span class="n">fee</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">)])])</span>
                         <span class="n">mps</span><span class="p">:</span>
                         <span class="n">signatures</span><span class="p">:</span>
                         <span class="n">validity</span> <span class="nb">range</span><span class="p">:</span> <span class="n">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="o">=</span> <span class="n">LowerBound</span> <span class="n">NegInf</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="o">=</span> <span class="n">UpperBound</span> <span class="n">PosInf</span> <span class="kc">True</span><span class="p">}</span>
                         <span class="n">data</span><span class="p">:</span>
                           <span class="o">&lt;&gt;</span><span class="p">}</span>
                     <span class="n">Requires</span> <span class="n">signatures</span><span class="p">:</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">b7d6ba18d02898aa5d0814a306e4a05cf153c199aabb175ef9b00328105ab98f</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">2</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
 <span class="o">...</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">6</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">d690122263521c37f308a0d5ae858aa4807cb1e493c2a3374bf65b934c74782a</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="n">deceaa52</span><span class="o">-</span><span class="n">f117</span><span class="o">-</span><span class="mi">46</span><span class="n">bc</span><span class="o">-</span><span class="n">b0f1</span><span class="o">-</span><span class="n">eb1f2f529b5a</span> <span class="n">on</span> <span class="n">W1</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">7</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
<span class="o">...</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">7</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">a679948d128735ec1f380e9f733d7f4a5e54c81f39c73a656d61b077111840e1</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">8</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
<span class="o">...</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">8</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">f0125e685edd6de2d09f9547f53b18d1bad11bd7fad570a057ba74737ab3053e</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">deceaa52</span><span class="o">-</span><span class="n">f117</span><span class="o">-</span><span class="mi">46</span><span class="n">bc</span><span class="o">-</span><span class="n">b0f1</span><span class="o">-</span><span class="n">eb1f2f529b5a</span><span class="p">:</span> <span class="s2">&quot;started oracle Oracle {oSymbol = b8a1d67cd94acf75d7e00f27015ec5e31242adad0967eee473f49c5d1d686169, oOperator = 21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9, oFee = 1000000, oAsset = (9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">)}&quot;</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">5</span><span class="n">bac6e67</span><span class="o">-</span><span class="n">f956</span><span class="o">-</span><span class="mi">45</span><span class="n">ef</span><span class="o">-</span><span class="n">b386</span><span class="o">-</span><span class="n">f1d045cf5e37</span> <span class="n">on</span> <span class="n">W2</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">2</span><span class="n">c3a2794</span><span class="o">-</span><span class="mi">2592</span><span class="o">-</span><span class="mi">4</span><span class="n">c2b</span><span class="o">-</span><span class="mi">9</span><span class="n">a7d</span><span class="o">-</span><span class="mi">9</span><span class="n">c810cedf886</span> <span class="n">on</span> <span class="n">W3</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">6</span><span class="n">f8d611d</span><span class="o">-</span><span class="n">a3f6</span><span class="o">-</span><span class="mi">4794</span><span class="o">-</span><span class="mi">9048</span><span class="o">-</span><span class="mi">8</span><span class="n">ea3201e3c56</span> <span class="n">on</span> <span class="n">W4</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="mi">387</span><span class="n">d9651</span><span class="o">-</span><span class="mi">6024</span><span class="o">-</span><span class="mi">48</span><span class="n">c1</span><span class="o">-</span><span class="n">a72d</span><span class="o">-</span><span class="mi">5</span><span class="n">b3c6d3a6b53</span> <span class="n">on</span> <span class="n">W5</span>
</pre></div>
</div>
<p>We can see, for example, where we can find instance IDs of contracts if we want to interact with them via the API.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Activated</span> <span class="n">instance</span> <span class="n">deceaa52</span><span class="o">-</span><span class="n">f117</span><span class="o">-</span><span class="mi">46</span><span class="n">bc</span><span class="o">-</span><span class="n">b0f1</span><span class="o">-</span><span class="n">eb1f2f529b5a</span> <span class="n">on</span> <span class="n">W1</span>
</pre></div>
</div>
<p>If we now stop the server and look in the directory, we will see the files where we stored the instance IDs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[nix-shell:~/git/ada/pioneer-fork/code/week06]$ ls
app            dist-newstyle  LICENSE     plutus-pioneer-program-week06.cabal  W2.cid  W4.cid
cabal.project  hie.yaml       oracle.cid  src                                  W3.cid  W5.cid

[nix-shell:~/git/ada/pioneer-fork/code/week06]$ cat W5.cid
387d9651-6024-48c1-a72d-5b3c6d3a6b53
</pre></div>
</div>
<p>With this information - either obtained from the web server log, or from the files we have created, we could use any HTTP tool such as Curl or Postman to interact
with the contracts when the web server is running. By default it runs on port 8080. We could also write code in any programming language we like to interact with the
web server using the HTTP endpoints.</p>
<p>We will now briefly look at the <em>oracle-client</em> and the <em>swap-client</em>. We won’t go into too much detail because we are not so interested in how to write a front end
here.</p>
</div>
<div class="section" id="oracle-client">
<h4><span class="section-number">1.6.6.2. </span>Oracle Client<a class="headerlink" href="#oracle-client" title="Permalink to this headline">¶</a></h4>
<p>We use the Haskell library <em>Req</em> to interact with the web server.</p>
<p>We first read the <em>oracle.cid</em> file to get the oracle instance ID. Then we have a recursive function <em>go</em>.</p>
<p>The function <em>go</em> looks up the current exchange rate on CoinMarketCap, checks whether that has changed, and, if it has change, it calls <em>updateOracle</em> which calls the
update oracle endpoint on our contract. And, whether or not a change is detected, it waits for an arbitrary five seconds, and then goes again.</p>
<p>The length of the delay would depend on things such as that rate cap imposed by CoinMarketCap. In reality, as blocks on Cardano only appear every twenty seconds, five
seconds is probably too short.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">uuid</span> <span class="ow">&lt;-</span> <span class="n">read</span> <span class="o">&lt;$&gt;</span> <span class="n">readFile</span> <span class="s">&quot;oracle.cid&quot;</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;oracle contract instance id: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">uuid</span>
    <span class="n">go</span> <span class="n">uuid</span> <span class="kt">Nothing</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">uuid</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">getExchangeRate</span>
        <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">x</span>
        <span class="n">when</span> <span class="p">(</span><span class="n">m</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span> <span class="o">$</span>
            <span class="n">updateOracle</span> <span class="n">uuid</span> <span class="n">x</span>
        <span class="n">threadDelay</span> <span class="mi">5_000_000</span>
        <span class="n">go</span> <span class="n">uuid</span> <span class="n">y</span>
</pre></div>
</div>
<p>Now, the <em>updateOracle</em> function prepares an POST request using the oracle instance ID and a JSON body containing the exchange rate.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">updateOracle</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">updateOracle</span> <span class="n">uuid</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">runReq</span> <span class="n">defaultHttpConfig</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">req</span>
        <span class="kt">POST</span>
        <span class="p">(</span><span class="n">http</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="o">/:</span> <span class="s">&quot;api&quot;</span>  <span class="o">/:</span> <span class="s">&quot;new&quot;</span> <span class="o">/:</span> <span class="s">&quot;contract&quot;</span> <span class="o">/:</span> <span class="s">&quot;instance&quot;</span> <span class="o">/:</span> <span class="n">pack</span> <span class="p">(</span><span class="n">show</span> <span class="n">uuid</span><span class="p">)</span> <span class="o">/:</span> <span class="s">&quot;endpoint&quot;</span> <span class="o">/:</span> <span class="s">&quot;update&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">ReqBodyJson</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="kt">JsonResponse</span> <span class="nb">()</span><span class="p">))</span>
        <span class="p">(</span><span class="n">port</span> <span class="mi">8080</span><span class="p">)</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="kr">if</span> <span class="n">responseStatusCode</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">200</span>
        <span class="kr">then</span> <span class="s">&quot;updated oracle to &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
        <span class="kr">else</span> <span class="s">&quot;error updating oracle&quot;</span>
</pre></div>
</div>
<p>And here is the <em>getExchangeRate</em> function which is a quick and dirty way of getting the exchange rate from CoinMarketCap. They provide a proper API, but here we
are just doing some screen scraping from the web page and using a regex to extract the value we are interested in. This is, of course, very fragile, and could never
be used as production code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getExchangeRate</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Integer</span>
<span class="nf">getExchangeRate</span> <span class="ow">=</span> <span class="n">runReq</span> <span class="n">defaultHttpConfig</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">req</span>
        <span class="kt">GET</span>
        <span class="p">(</span><span class="n">https</span> <span class="s">&quot;coinmarketcap.com&quot;</span> <span class="o">/:</span> <span class="s">&quot;currencies&quot;</span> <span class="o">/:</span> <span class="s">&quot;cardano&quot;</span><span class="p">)</span>
        <span class="kt">NoReqBody</span>
        <span class="n">bsResponse</span>
        <span class="n">mempty</span>
    <span class="kr">let</span> <span class="n">priceRegex</span>      <span class="ow">=</span> <span class="s">&quot;priceValue___11gHJ</span><span class="se">\&quot;</span><span class="s">&gt;</span><span class="se">\\</span><span class="s">$([</span><span class="se">\\</span><span class="s">.0-9]*)&quot;</span> <span class="ow">::</span> <span class="kt">ByteString</span>
        <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="p">[</span><span class="n">bs</span><span class="p">])</span> <span class="ow">=</span> <span class="n">responseBody</span> <span class="n">v</span> <span class="o">=~</span> <span class="n">priceRegex</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">ByteString</span><span class="p">,</span> <span class="kt">ByteString</span><span class="p">,</span> <span class="kt">ByteString</span><span class="p">,</span> <span class="p">[</span><span class="kt">ByteString</span><span class="p">])</span>
        <span class="n">d</span>               <span class="ow">=</span> <span class="n">read</span> <span class="o">$</span> <span class="n">unpack</span> <span class="n">bs</span> <span class="ow">::</span> <span class="kt">Double</span>
        <span class="n">x</span>               <span class="ow">=</span> <span class="n">round</span> <span class="o">$</span> <span class="mi">1_000_000</span> <span class="o">*</span> <span class="n">d</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;queried exchange rate: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">d</span>
    <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Let us run it.</p>
<p>First we need to make sure the PAB is running.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">oracle</span><span class="o">-</span><span class="n">pab</span>
</pre></div>
</div>
<p>Then, in another terminal</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">oracle</span><span class="o">-</span><span class="n">client</span>
<span class="o">...</span>
<span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.54</span>
<span class="n">updated</span> <span class="n">oracle</span> <span class="n">to</span> <span class="mi">1540000</span>
<span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.54</span>
</pre></div>
</div>
<p>We can see the exchange rate that it has obtained from CoinMarketCap, and its request to update the oracle.</p>
<p>And if we wait long enough, we see</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.55</span>
<span class="n">updated</span> <span class="n">oracle</span> <span class="n">to</span> <span class="mi">1550000</span>
<span class="n">queried</span> <span class="n">exchange</span> <span class="n">rate</span><span class="p">:</span> <span class="mf">1.55</span>
</pre></div>
</div>
<p>And we see that we are mooning.</p>
<p>If you switch back to the PAB, you will also see additional log messages.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">16</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
    <span class="n">Tx</span><span class="p">:</span>
    <span class="n">Tx</span> <span class="n">c5b384f75f93ebc8f1e6b514237aa70d0d982e9b035eececa27af0b3e72568e4</span><span class="p">:</span>
        <span class="p">{</span><span class="n">inputs</span><span class="p">:</span>
        <span class="n">outputs</span><span class="p">:</span>
        <span class="o">-</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(</span><span class="n">b8a1d67cd94acf75d7e00f27015ec5e31242adad0967eee473f49c5d1d686169</span><span class="p">,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)])])</span> <span class="n">addressed</span> <span class="n">to</span>
            <span class="n">addressed</span> <span class="n">to</span> <span class="n">ScriptCredential</span><span class="p">:</span> <span class="mi">04</span><span class="n">a718132f7ca493a011c40926e191a76bd84cbf8e7c14b6c99bbea8b8bc0bba</span> <span class="p">(</span><span class="n">no</span> <span class="n">staking</span> <span class="n">credential</span><span class="p">)</span>
        <span class="n">forge</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[])</span>
        <span class="n">fee</span><span class="p">:</span> <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">)])])</span>
        <span class="n">mps</span><span class="p">:</span>
        <span class="n">signatures</span><span class="p">:</span>
        <span class="n">validity</span> <span class="nb">range</span><span class="p">:</span> <span class="n">Interval</span> <span class="p">{</span><span class="n">ivFrom</span> <span class="o">=</span> <span class="n">LowerBound</span> <span class="n">NegInf</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ivTo</span> <span class="o">=</span> <span class="n">UpperBound</span> <span class="n">PosInf</span> <span class="kc">True</span><span class="p">}</span>
        <span class="n">data</span><span class="p">:</span>
        <span class="mi">1540000</span><span class="p">}</span>
    <span class="n">Requires</span> <span class="n">signatures</span><span class="p">:</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">16</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">40</span><span class="n">c5dbb5e7c8de390a6943d8f0a84d218cf86dd81af1fd7cfc62612e6b616c2c</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="mi">5</span><span class="n">d9d778e</span><span class="o">-</span><span class="mi">55</span><span class="n">f9</span><span class="o">-</span><span class="mi">45</span><span class="n">ab</span><span class="o">-</span><span class="mi">89</span><span class="n">a6</span><span class="o">-</span><span class="mi">2</span><span class="n">ba9aa18045e</span><span class="p">:</span> <span class="s2">&quot;set initial oracle value to 1540000&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="swap-client">
<h4><span class="section-number">1.6.6.3. </span>Swap Client<a class="headerlink" href="#swap-client" title="Permalink to this headline">¶</a></h4>
<p>The swap client is very similar.</p>
<p>Here, we are just giving a simple console interface, so we didn’t bother with graphics or a nice web UI.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">[</span><span class="n">i</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">]</span> <span class="ow">&lt;-</span> <span class="n">map</span> <span class="n">read</span> <span class="o">&lt;$&gt;</span> <span class="n">getArgs</span>
    <span class="n">uuid</span>       <span class="ow">&lt;-</span> <span class="n">read</span> <span class="o">&lt;$&gt;</span> <span class="n">readFile</span> <span class="p">(</span><span class="sc">&#39;W&#39;</span> <span class="kt">:</span> <span class="n">show</span> <span class="n">i</span> <span class="o">++</span> <span class="s">&quot;.cid&quot;</span><span class="p">)</span>
    <span class="n">hSetBuffering</span> <span class="n">stdout</span> <span class="kt">NoBuffering</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;swap contract instance id for Wallet &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">i</span> <span class="o">++</span> <span class="s">&quot;: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">uuid</span>
    <span class="n">go</span> <span class="n">uuid</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
    <span class="n">go</span> <span class="n">uuid</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">cmd</span> <span class="ow">&lt;-</span> <span class="n">readCommand</span>
        <span class="kr">case</span> <span class="n">cmd</span> <span class="kr">of</span>
            <span class="kt">Offer</span> <span class="n">amt</span> <span class="ow">-&gt;</span> <span class="n">offer</span> <span class="n">uuid</span> <span class="n">amt</span>
            <span class="kt">Retrieve</span>  <span class="ow">-&gt;</span> <span class="n">retrieve</span> <span class="n">uuid</span>
            <span class="kt">Use</span>       <span class="ow">-&gt;</span> <span class="n">use</span> <span class="n">uuid</span>
            <span class="kt">Funds</span>     <span class="ow">-&gt;</span> <span class="n">getFunds</span> <span class="n">uuid</span>
        <span class="n">go</span> <span class="n">uuid</span>

    <span class="n">readCommand</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Command</span>
    <span class="n">readCommand</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">putStr</span> <span class="s">&quot;enter command (Offer amt, Retrieve, Use or Funds): &quot;</span>
        <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
        <span class="n">maybe</span> <span class="n">readCommand</span> <span class="n">return</span> <span class="o">$</span> <span class="n">readMaybe</span> <span class="n">s</span>
</pre></div>
</div>
<p>The idea is to take a command from the console and the call the appropriate endpoint.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">cmd</span> <span class="kr">of</span>
    <span class="kt">Offer</span> <span class="n">amt</span> <span class="ow">-&gt;</span> <span class="n">offer</span> <span class="n">uuid</span> <span class="n">amt</span>
    <span class="kt">Retrieve</span>  <span class="ow">-&gt;</span> <span class="n">retrieve</span> <span class="n">uuid</span>
    <span class="kt">Use</span>       <span class="ow">-&gt;</span> <span class="n">use</span> <span class="n">uuid</span>
    <span class="kt">Funds</span>     <span class="ow">-&gt;</span> <span class="n">getFunds</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>The endpoint calling uses the same method for each endpoint, creating an HTTP call in the same way that we did for the oracle client.</p>
<p>The <em>getFunds</em> function is slightly more complicated than the other three as it needs to get information out of the server. For this it needs to make
two requests. The second request is to read the state that was <em>told</em> by the first call.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getFunds</span> <span class="ow">::</span> <span class="kt">UUID</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">getFunds</span> <span class="n">uuid</span> <span class="ow">=</span> <span class="n">handle</span> <span class="n">h</span> <span class="o">$</span> <span class="n">runReq</span> <span class="n">defaultHttpConfig</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">req</span>
        <span class="kt">POST</span>
        <span class="p">(</span><span class="n">http</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="o">/:</span> <span class="s">&quot;api&quot;</span>  <span class="o">/:</span> <span class="s">&quot;new&quot;</span> <span class="o">/:</span> <span class="s">&quot;contract&quot;</span> <span class="o">/:</span> <span class="s">&quot;instance&quot;</span> <span class="o">/:</span> <span class="n">pack</span> <span class="p">(</span><span class="n">show</span> <span class="n">uuid</span><span class="p">)</span> <span class="o">/:</span> <span class="s">&quot;endpoint&quot;</span> <span class="o">/:</span> <span class="s">&quot;funds&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">ReqBodyJson</span> <span class="nb">()</span><span class="p">)</span>
        <span class="p">(</span><span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="kt">JsonResponse</span> <span class="nb">()</span><span class="p">))</span>
        <span class="p">(</span><span class="n">port</span> <span class="mi">8080</span><span class="p">)</span>
    <span class="kr">if</span> <span class="n">responseStatusCode</span> <span class="n">v</span> <span class="o">/=</span> <span class="mi">200</span>
        <span class="kr">then</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="s">&quot;error getting funds&quot;</span>
        <span class="kr">else</span> <span class="kr">do</span>
            <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">req</span>
                <span class="kt">GET</span>
                <span class="p">(</span><span class="n">http</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="o">/:</span> <span class="s">&quot;api&quot;</span>  <span class="o">/:</span> <span class="s">&quot;new&quot;</span> <span class="o">/:</span> <span class="s">&quot;contract&quot;</span> <span class="o">/:</span> <span class="s">&quot;instance&quot;</span> <span class="o">/:</span> <span class="n">pack</span> <span class="p">(</span><span class="n">show</span> <span class="n">uuid</span><span class="p">)</span> <span class="o">/:</span> <span class="s">&quot;status&quot;</span><span class="p">)</span>
                <span class="kt">NoReqBody</span>
                <span class="p">(</span><span class="kt">Proxy</span> <span class="ow">::</span> <span class="kt">Proxy</span> <span class="p">(</span><span class="kt">JsonResponse</span> <span class="p">(</span><span class="kt">ContractInstanceClientState</span> <span class="kt">OracleContracts</span><span class="p">)))</span>
                <span class="p">(</span><span class="n">port</span> <span class="mi">8080</span><span class="p">)</span>
            <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="kr">case</span> <span class="n">fromJSON</span> <span class="o">$</span> <span class="n">observableState</span> <span class="o">$</span> <span class="n">cicCurrentState</span> <span class="o">$</span> <span class="n">responseBody</span> <span class="n">w</span> <span class="kr">of</span>
                <span class="kt">Success</span> <span class="p">(</span><span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="s">&quot;funds: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">flattenValue</span> <span class="n">f</span><span class="p">)</span>
                <span class="kr">_</span>                       <span class="ow">-&gt;</span> <span class="s">&quot;error decoding state&quot;</span>
  <span class="kr">where</span>
    <span class="n">h</span> <span class="ow">::</span> <span class="kt">HttpException</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
    <span class="n">h</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">threadDelay</span> <span class="mi">1_000_000</span> <span class="o">&gt;&gt;</span> <span class="n">getFunds</span> <span class="n">uuid</span>
</pre></div>
</div>
<p>Let’s run the swap client. We will leave the web server and the oracle client running.</p>
<p>When using cabal, we pass parameters in following a <em>–</em>. For the swap client we pass the wallet number in as a parameter.</p>
<p>We will launch the swap client for wallets 2 and 3, each in a separate window, and query their respective funds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span> <span class="o">--</span> <span class="mi">2</span>

<span class="n">swap</span> <span class="n">contract</span> <span class="n">instance</span> <span class="nb">id</span> <span class="k">for</span> <span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span> <span class="n">ab65f248</span><span class="o">-</span><span class="mi">450</span><span class="n">d</span><span class="o">-</span><span class="mi">4988</span><span class="o">-</span><span class="n">ab2a</span><span class="o">-</span><span class="mi">651</span><span class="n">ad5697596</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)]</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">run</span> <span class="n">swap</span><span class="o">-</span><span class="n">client</span> <span class="o">--</span> <span class="mi">3</span>

<span class="n">swap</span> <span class="n">contract</span> <span class="n">instance</span> <span class="nb">id</span> <span class="k">for</span> <span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="n">dc4f6f2</span><span class="o">-</span><span class="mf">142e-40</span><span class="n">a2</span><span class="o">-</span><span class="n">a1b8</span><span class="o">-</span><span class="n">c431eb29a3a2</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)]</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span>
</pre></div>
</div>
<p>Wallet 2 now offers 10 Ada as a swap, and we check the funds, and we see that the Ada balance has gone down (by the 10 Ada plus the transaction fee),
but the USD Token balance remains the same.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Offer</span> <span class="mi">10000000</span>
<span class="n">offered</span> <span class="n">swap</span> <span class="n">of</span> <span class="mi">10000000</span> <span class="n">lovelace</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">89999990</span><span class="p">)]</span>
</pre></div>
</div>
<p>While these commands are running, you can also see the calls being made in the PAB output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1662</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">17</span><span class="n">f640f03e4dc7d0a4c246129454aa19daa8d9d674bfebeeee486d6143c6648e</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">ab65f248</span><span class="o">-</span><span class="mi">450</span><span class="n">d</span><span class="o">-</span><span class="mi">4988</span><span class="o">-</span><span class="n">ab2a</span><span class="o">-</span><span class="mi">651</span><span class="n">ad5697596</span><span class="p">:</span> <span class="s2">&quot;offered 10000000 lovelace for swap&quot;</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">ab65f248</span><span class="o">-</span><span class="mi">450</span><span class="n">d</span><span class="o">-</span><span class="mi">4988</span><span class="o">-</span><span class="n">ab2a</span><span class="o">-</span><span class="mi">651</span><span class="n">ad5697596</span><span class="p">:</span> <span class="s2">&quot;own funds: [(9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,100000000),(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,89999990)]&quot;</span>
</pre></div>
</div>
<p>Now, Wallet 3 is going to take up the offer of the swap.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Use</span>
<span class="n">used</span> <span class="n">swap</span>
<span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">100000000</span><span class="p">)]</span>
</pre></div>
</div>
<p>It takes a little while for the funds to update, so let’s try the <em>Funds</em> command again.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">84400000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">108999990</span><span class="p">)]</span>
</pre></div>
</div>
<p>That’s better. And we can see that wallet 3 has received the 10 Ada, minus the oracle fee of 1 Ada and minus the transaction fees.</p>
<p>In the PAB output, we see something like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1868</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">00</span><span class="n">afd25af063d58b4f290e43057f4738483098f26ff0134bc14c9d54b9b94090</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="mi">2</span><span class="n">dc4f6f2</span><span class="o">-</span><span class="mf">142e-40</span><span class="n">a2</span><span class="o">-</span><span class="n">a1b8</span><span class="o">-</span><span class="n">c431eb29a3a2</span><span class="p">:</span> <span class="s2">&quot;made swap with price [(9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,15600000)]&quot;</span>
<span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="mi">2</span><span class="n">dc4f6f2</span><span class="o">-</span><span class="mf">142e-40</span><span class="n">a2</span><span class="o">-</span><span class="n">a1b8</span><span class="o">-</span><span class="n">c431eb29a3a2</span><span class="p">:</span> <span class="s2">&quot;own funds: [(9a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a,</span><span class="se">\&quot;</span><span class="s2">USDT</span><span class="se">\&quot;</span><span class="s2">,84400000),(,</span><span class="se">\&quot;\&quot;</span><span class="s2">,108999990)]&quot;</span>
</pre></div>
</div>
<p>Let’s look at wallet 2’s funds.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">enter</span> <span class="n">command</span> <span class="p">(</span><span class="n">Offer</span> <span class="n">amt</span><span class="p">,</span> <span class="n">Retrieve</span><span class="p">,</span> <span class="n">Use</span> <span class="ow">or</span> <span class="n">Funds</span><span class="p">):</span> <span class="n">Funds</span>
<span class="n">funds</span><span class="p">:</span> <span class="p">[(</span><span class="mi">9</span><span class="n">a91216e55e5369b926acc07c70a11d9ae7fef454e43e3e5c0aa1733f48c798a</span><span class="p">,</span><span class="s2">&quot;USDT&quot;</span><span class="p">,</span><span class="mi">115600000</span><span class="p">),(,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">89999990</span><span class="p">)]</span>
</pre></div>
</div>
<p>And we see that wallet 2 has lost some Ada, but gained some USD Tokens. The swap is complete, using the exchange rate as it is live, right now, which was injected
into the mock blockchain via the oracle.</p>
<p>So now we have seen an end-to-end example of a Plutus dApp. It has a front end, it talks to the outside world, goes on the internet, gets information and interacts with Plutus smart contracts.
The smart contracts submit transactions to the blockchain where the validation logic kicks in and makes sure that everything follows the business rules.</p>
<p>In this example, as we have no real blockchain to play with, all wallets use the same PAB server, which, of course, in real life would be silly. Obviously, different
wallets will have different instances of PAB running.</p>
<p>But, apart from that, it is almost exactly, end-to-end, how such a system would work.</p>
</div>
</div>
</div>
<div class="section" id="week-07-state-machines">
<h2><span class="section-number">1.7. </span>Week 07 - State Machines<a class="headerlink" href="#week-07-state-machines" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=oJupInqvJUI">Lecture
#7</a>.</p>
<p>It covers commit schemes and state machines.</p>
<p>This week we were using Plutus commit 530cc134364ae186f39fb2b54239fb7c5e2986e9</p>
</div>
<div class="section" id="id23">
<h3><span class="section-number">1.7.1. </span>Introduction<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<p>In this lecture we will look at state machines. State machines can be very useful for writing shorter and more concise contracts, both on-chain and off-chain. There is higher level support for state machines in the Plutus libraries that builds on top of the lower level mechanisms we have seen so far.</p>
<p>As a running example, we are going to implement a little game, played between Alice and Bob. It’s a bit like Rock, Paper, Scissors, but even simpler, because there are
only two options.</p>
<p>Alice and Bob both have two options, they can either play 0 or 1.</p>
<div class="figure align-default">
<img alt="_images/week07__00000.png" src="_images/week07__00000.png" />
</div>
<p>If there were to play this game while being physically in the same room, they would make their moves at the same time. There would be one gesture for 0 and one
gesture for 1, they would raise their hands simultaneously, and, depending on what they play, one of them wins.</p>
<p>If they both play the same number, Alice wins. If they play different numbers, Bob wins.</p>
<div class="figure align-default">
<img alt="_images/week07__00001.png" src="_images/week07__00001.png" />
</div>
<p>Now let’s imagine that Alice and Bob can’t meet in person but that they still want to play the game. So, they decide to play it via mail - email or snail mail, it doesn’t
matter. How would that work?</p>
<p>Alice could send her move to Bob.</p>
<div class="figure align-default">
<img alt="_images/week07__00004.png" src="_images/week07__00004.png" />
</div>
<p>This, however, gives a very unfair advantage to Bob, because now he opens Alice’s mail, see that she has played 0, and he can simply reply with 1, and he wins.</p>
<div class="figure align-default">
<img alt="_images/week07__00003.png" src="_images/week07__00003.png" />
</div>
<p>And, if Alice plays 1, Bob can simply respond with 1. So Bob always wins, at least if he is unfair.</p>
<div class="figure align-default">
<img alt="_images/week07__00005.png" src="_images/week07__00005.png" />
</div>
<p>What can we do about that?</p>
<p>There’s a very clever trick which is often used in cryptographic protocols, and that is commit schemes. The idea is that Alice doesn’t reveal her choice to Bob, but she commits to it, so that she cannot later change her mind.</p>
<p>One way to make that work is using hash functions.</p>
<p>Hashes are all over the place in the blockchain world. We have seen that script addresses are just the hash of the Plutus code script, and we have seen lots of examples of
public key hashes.</p>
<p>A hash function is a one-way function. Given a hash, tt is difficult, or impossible, to reconstruct the original byte string that was hashed.</p>
<p>So, one way we could try to make this work is that, instead of Alice sending her choice to Bob, she instead sends the hash of her choice.</p>
<div class="figure align-default">
<img alt="_images/week07__00006.png" src="_images/week07__00006.png" />
</div>
<p>Bob then sees this cryptic byte string and he has no idea whether Alice picked 0 or 1.</p>
<p>Bob then replies with his move, picking, for example 0. There is no need for him to use a hash, he can just send his response in clear text.</p>
<p>Now, Alice would have won. But perhaps Bob doesn’t believe her. So there is one additional step that Alice has to take.</p>
<p>Alice has to send her actual choice to Bob in clear text. Bob then has to check that the hash of her choice is indeed the same as the hash Alice sent earlier.</p>
<div class="figure align-default">
<img alt="_images/week07__00007.png" src="_images/week07__00007.png" />
</div>
<p>If it is, then he knows sees that Alice is not lying and that indeed he lost. If it does not match, then he knows that Alice is cheating and he would win.</p>
<p>This all sounds promising, but there is one big problem with it.</p>
<p>In this game there are only two choices, 0 and 1. Which means that there are only two possible hashes. They may look very cryptic to Bob the first time they play,
but before long he will notice that he always sees one of only two possible hashes, and then he can know which choice Alice made.</p>
<p>This is almost as bad as if Alice had just sent her choice in clear text.</p>
<p>What we can do about this is that, instead of sending the hash of her choice, she instead first selects an arbitrary byte string and then hashes the
concatenated of this byte string and her choice. The arbitrary byte string that Alice chooses is called a <em>nonce</em> - a number to be used just once.</p>
<div class="figure align-default">
<img alt="_images/week07__00008.png" src="_images/week07__00008.png" />
</div>
<p>So now, it is not always the same byte string if she picks 0, provided she chooses some random, unpredictable nonce.</p>
<p>Now, Bob receives this and we proceed as before - Bob sends his choice, and then, in the third message Alice needs to send not only her original choice, but she also
has to send the nonce as well.</p>
<div class="figure align-default">
<img alt="_images/week07__00010.png" src="_images/week07__00010.png" />
</div>
<p>And then Bob checks that the hash of Alice’s claimed nonce concatenated with her choice is indeed the hash that he originally received. If it is, he knows he lost, and
if it is not, he knows that she tried to cheat him.</p>
<p>This works very nicely and this is what we will try to implement in Cardano. First we will do it using techniques we have already seen, and then we will see how, by using
state machines, the code can be much clearer and much shorter.</p>
</div>
<div class="section" id="code-example-1">
<h3><span class="section-number">1.7.2. </span>Code Example 1<a class="headerlink" href="#code-example-1" title="Permalink to this headline">¶</a></h3>
<p>We can imagine that, at the start of the game, Alice and Bob have put down the same amount of money each and that the winner will take it all.</p>
<p>The game starts with Alice posting her hash, as described above. Bob, if he plays along, will post his own choice. At this point, we have Alice’s hash and Bob’s choice.</p>
<div class="figure align-default">
<img alt="_images/week07__00011.png" src="_images/week07__00011.png" />
</div>
<p>If, at this point, Alice realizes that she has won, based on Bob’s choice, she can reveal her secret, the game ends, and she has won.</p>
<div class="figure align-default">
<img alt="_images/week07__00012.png" src="_images/week07__00012.png" />
</div>
<p>If, however, after Bob makes his move, Alice sees that she has lost, there is no need for her to do anything. After a certain deadline has been reached, if Alice has
not responded, Bob will be able to claim the funds.</p>
<div class="figure align-default">
<img alt="_images/week07__00013.png" src="_images/week07__00013.png" />
</div>
<p>There is a another scenario. Perhaps, after Alice starts playing, Bob simply isn’t interested. In this case, there must be a way for Alice to get her own money back.</p>
<div class="figure align-default">
<img alt="_images/week07__00016.png" src="_images/week07__00016.png" />
</div>
<p>As mentioned, our first attempt at coding this in Plutus will be using the techniques we have learned in previous lectures.</p>
<p>The code we are working with is in the following module</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week07.EvenOdd</span>
</pre></div>
</div>
<p>We call the game <em>EvenOdd</em> due to the fact that if the sum of the numbers is even, then the first player wins, and if the sum is odd, the second player wins.</p>
<p>In our code we will call the players <em>first</em> and <em>second</em> rather than Alice and Bob.</p>
<div class="section" id="id24">
<h4><span class="section-number">1.7.2.1. </span>On chain<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>We define a data type <em>Game</em> which will be used as a parameter for the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Game</span> <span class="ow">=</span> <span class="kt">Game</span>
    <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>The players are identified by their public key hashes as <em>gFirst</em> and <em>gSecond</em>.</p>
<p>The number of lovelace to be used as stake in the game is represented by <em>gStake</em> - This stake must be provided by each player.</p>
<p>There are two deadlines. The <em>gPlayDeadline</em> is the slot by which the second player must make their move. In the case where the second player has made a move,
the <em>gRevealDeadline</em> is the slot by which player 1 must claim victory by revealing his nonce.</p>
<p>Finally we have a token represented by <em>gToken</em>. This will be the same trick that we used for the oracle. It will be an arbitrary NFT, used to identify the right
instance of the UTxO that we are using. The idea is to use the datum sitting at a UTxO in this contract’s script address to keep track of where we are in the game.</p>
<p>Next, we define the two moves that the players can make.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameChoice</span> <span class="ow">=</span> <span class="kt">Zero</span> <span class="o">|</span> <span class="kt">One</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameChoice</span> <span class="kr">where</span>
    <span class="cm">{-# INLINABLE (==) #-}</span>
    <span class="kt">Zero</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">One</span>  <span class="o">==</span> <span class="kt">One</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span>    <span class="o">==</span> <span class="kr">_</span>    <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>We need Plutus <em>Eq</em> for the instance, but it is not possible to declare that in the deriving clause, which is why the <em>Eq</em> in the deriving clause is qualified as being
from the standard Haskell Prelude.</p>
<p>Note that we have used the <em>INLINABLE</em> pragma on the <em>Eq</em> instance for <em>GameChoice</em>. This is again to make it compatible with the Template Haskell we will need to
use.</p>
<p>For state, we will use a type called <em>GameDatum</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameDatum</span> <span class="ow">=</span> <span class="kt">GameDatum</span> <span class="kt">ByteString</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">GameChoice</span><span class="p">)</span>
<span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameDatum</span> <span class="kr">where</span>
    <span class="cm">{-# INLINABLE (==) #-}</span>
    <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="n">mc</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs&#39;</span> <span class="n">mc&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">bs</span> <span class="o">==</span> <span class="n">bs&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mc</span> <span class="o">==</span> <span class="n">mc&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the <em>ByteString</em> is the hash that the first player submits, and <em>Maybe GameChoice</em> is either <em>Just</em> the move of the second player, or <em>Nothing</em>, if they have not yet moved.</p>
<p>Now we come to the redeemer, and we will use a custom type for this as well.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameRedeemer</span> <span class="ow">=</span> <span class="kt">Play</span> <span class="kt">GameChoice</span> <span class="o">|</span> <span class="kt">Reveal</span> <span class="kt">ByteString</span> <span class="o">|</span> <span class="kt">ClaimFirst</span> <span class="o">|</span> <span class="kt">ClaimSecond</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>Here <em>Play</em> is where the second player moves and, as an argument, it has a <em>GameChoice</em>. <em>Reveal</em> is for the case where the first player has won and must prove that
by revealing their nonce, and the nonce is represented by the <em>ByteString</em> argument. We don’t need to include the move for the <em>Reveal</em>, as they will only reveal if they
have won, and we know what move makes them win.</p>
<p><em>ClaimFirst</em> is when the first player claims back the stake in the even that the second player does not make a move by the play deadline. <em>ClaimSecond</em> is for the
case when the first player does not reveal by the reveal deadline.</p>
<p>We then have our <em>lovelaces</em> helper function which we have used in other scripts, which gets the number of lovelaces held in a <em>Value</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>And we have a helper function <em>gameDatum</em> which behaves exactly the same way as the function <em>oracleValue</em>, which you can find in the notes from lecture 6.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameDatum</span> <span class="ow">::</span> <span class="kt">TxOut</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">DatumHash</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Datum</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">GameDatum</span>
<span class="nf">gameDatum</span> <span class="n">o</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">dh</span>      <span class="ow">&lt;-</span> <span class="n">txOutDatum</span> <span class="n">o</span>
    <span class="kt">Datum</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">dh</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">d</span>
</pre></div>
</div>
<p>Now we come to the core business logic in the <em>mkGameValidator</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkGameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkGameValidator</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="n">dat</span> <span class="n">red</span> <span class="n">ctx</span> <span class="ow">=</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first argument is the <em>Game</em> parameter discussed above.</p>
<p>The second and the third arguments are somewhat of a nuisance. We just need them due to the fact that it is not possible to use string literals to
get <em>ByteStrings</em> in Haskell that is compiled to Plutus core. And, we want string literals representing the 0 and 1 choices. So <em>bsZero’</em> will hold “0” and
<em>beOne’</em> will hold “1”. You will see how we pass these in as auxiliary arguments later.</p>
<p>Then we pass in the usual arguments for datum, redeemer and context.</p>
<p>Let’s look at some helper functions first. There are three functions we have used before and discussed in lecture 6.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
<span class="nf">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

<span class="nf">ownInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownInput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;game input missing&quot;</span>
    <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>

<span class="nf">ownOutput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownOutput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">getContinuingOutputs</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
    <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one game output&quot;</span>
</pre></div>
</div>
<p>Note the <em>ownInput</em> should never fail as we are in the process of validating a UTxO.</p>
<p>The <em>outputDatum</em> helper makes use of the <em>GameDatum</em> type which we defined earlier. Given the case we have exactly one output (the return from <em>ownOutput</em>), it will
give us the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">outputDatum</span> <span class="ow">::</span> <span class="kt">GameDatum</span>
<span class="nf">outputDatum</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">gameDatum</span> <span class="n">ownOutput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;game output datum not found&quot;</span>
    <span class="kt">Just</span> <span class="n">d</span>  <span class="ow">-&gt;</span> <span class="n">d</span>
</pre></div>
</div>
<p>The <em>checkNonce</em> function is for the case where the first player as won and wants to prove it by revealing their nonce. The first argument is hash that was original sent,
the second argument is the nonce that is being revealed.</p>
<p>For the <em>GameChoice</em>-typed parameter, we will be passing in the move made by player 2. This should be the same as the move made by player 1, and this is what this function will determine using the hash and the nonce.</p>
<p>In order to check the hash of the nonce concatenated with the <em>GameChoice</em>, we use a helper function to convert the <em>GameChoice</em> to a <em>ByteString</em>. Note that the use
of the <em>cFirst</em> and <em>cSecond</em> in the <em>checkNonce</em> function could be swapped around, and the function would work just the same - the difference between the two is that
one is a <em>GameChoice</em> and one is a <em>ByteString</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkNonce</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">cSecond</span> <span class="ow">=</span> <span class="n">sha2_256</span> <span class="p">(</span><span class="n">nonce</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="n">cFirst</span><span class="p">)</span> <span class="o">==</span> <span class="n">bs</span>
  <span class="kr">where</span>
    <span class="n">cFirst</span> <span class="ow">::</span> <span class="kt">ByteString</span>
    <span class="n">cFirst</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">cSecond</span> <span class="kr">of</span>
        <span class="kt">Zero</span> <span class="ow">-&gt;</span> <span class="n">bsZero&#39;</span>
        <span class="kt">One</span>  <span class="ow">-&gt;</span> <span class="n">bsOne&#39;</span>
</pre></div>
</div>
<p>Finally, there is the question of what happens to the NFT once the game is over and there is no game address anymore. The way we have implemented it here, is that the NFT goes back to the first player. The first player needs it in the beginning to kick off the game and put the NFT
into the correct UTxO, so it is reasonable to give it back the player 1 in the end.</p>
<p>To verify that this condition is met, we have created a helper function called <em>nftToFirst</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nftToFirst</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">nftToFirst</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">valuePaidTo</span> <span class="n">info</span> <span class="o">$</span> <span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Now that we have covered the helper functions, let’s look at the conditions.</p>
<p>There is one condition that covers all the cases, and that is that the input we are validating must contain the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</pre></div>
</div>
<p>After that, the rules depend on the situation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">red</span><span class="p">)</span> <span class="kr">of</span>
</pre></div>
</div>
<p>The first situation is the one where the second player has not yet moved, and they are just now making their move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span>            <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>                             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>         <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span>     <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the first part is the <em>GameDatum</em> and it contains the first player’s hash and a <em>Nothing</em> which shows that the second player has not yet moved. The second part is the <em>GameRedeemer</em> and has been determined
to be of type <em>Play GameChoice</em>. We assign the <em>GameChoice</em> part to <em>c</em> using pattern matching.</p>
<p>We check that the second player has signed the transaction.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>
</pre></div>
</div>
<p>Then, we check that the first player’s stake is present in the input.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>The output should have the second player’s stake added to the total stake.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>
</pre></div>
</div>
<p>We now exactly what the datum of the output must be. It must be the same hash, plus the move made by the second player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span> <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>
</pre></div>
</div>
<p>The, the move must happen before the play deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>
</pre></div>
</div>
<p>And finally, the NFT must be passed on in the output UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second situation is where both players have moved, and the second player discovers that they have won. In order to prove that and get the winnings, they have
to reveal their nonce.</p>
<p>So, the transaction must be signed by the first player, the nonce must indeed agree with the hash submitted earlier, it must be done before the reveal deadline,
the input must contain both players’ stakes and, finally, the NFT must go back to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="n">nonce</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;commit mismatch&quot;</span>               <span class="p">(</span><span class="n">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">c</span><span class="p">)</span>                                            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>       <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>Next we have the case where the second player doesn’t move within the deadline, and the first player is reclaiming their stake. Here, the first player must have signed
the transaction, the play deadline must have passed, their stake must be present, and the NFT must go back to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>Finally, the case where both players have moved and the first player has either lost or not revealed in time, so the second player is claiming the winnings. This time, the
transaction must be signed by the second player, the reveal deadline must have passed, both players’ stakes must be present, and the NFT must, as usual, go back
to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>These four cases are all the legitimate cases that we can have, so in all other cases we fail validation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
</pre></div>
</div>
<p>So now let’s look at the rest of the on-chain code.</p>
<p>As usual, we define a data type that holds the information about the types the datum and redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Gaming</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Gaming</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameDatum</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>And we define the <em>ByteStrings</em> that will be used to represent the two choices. These values are completely arbitrary - they just can’t be the same as each other.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bsZero</span><span class="p">,</span> <span class="n">bsOne</span> <span class="ow">::</span> <span class="kt">ByteString</span>
<span class="nf">bsZero</span> <span class="ow">=</span> <span class="s">&quot;0&quot;</span>
<span class="nf">bsOne</span>  <span class="ow">=</span> <span class="s">&quot;1&quot;</span>
</pre></div>
</div>
<p>Boilerplate to compile our parameterized <em>mkGameValidator</em> to Plutus code. We apply the three parameters, <em>Game</em> and the two <em>ByteStrings</em>s. Remember that, we need
to pass in these <em>ByteString</em> parameters because we can’t refer to <em>ByteString</em>s as string literals within Plutus.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameInst</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Gaming</span>
<span class="nf">gameInst</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Gaming</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkGameValidator</span> <span class="o">||</span><span class="p">])</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">game</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">bsZero</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">bsOne</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">GameDatum</span> <span class="o">@</span><span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>The usual boilerplate for validator and address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">gameValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">gameInst</span>

<span class="nf">gameAddress</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">gameAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">gameValidator</span>
</pre></div>
</div>
<p>Now, as preparation for the off-chain code, we will need to be able to find the right UTxO - the one that carries the NFT. To do this we will write a helper function
called <em>findGameOutput</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findGameOutput</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">GameDatum</span><span class="p">))</span>
<span class="nf">findGameOutput</span> <span class="n">game</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">gameAddress</span> <span class="n">game</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">find</span> <span class="n">f</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
        <span class="n">dat</span>       <span class="ow">&lt;-</span> <span class="n">gameDatum</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(`</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span><span class="p">`</span> <span class="n">txData</span> <span class="p">(</span><span class="n">txOutTxTx</span> <span class="n">o</span><span class="p">))</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The <em>findGameOutput</em> function takes the <em>Game</em>, then uses the <em>Contract</em> monad to try to find the UTxO with the NFT. It returns a <em>Maybe</em>, because it may not find one.
If we find it, we return a <em>Just</em> of a triple containing the transaction reference, the transaction itself, and the <em>GameDatum</em>.</p>
<p>First we get a list of all the UTxOs at the game address, then we use the <em>find</em> function, passing in a helper function <em>f</em>, which checks whether the output contains the
NFT.</p>
<p>The <em>find</em> function is found in module <em>Data.List</em> and is defined as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">find</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>This works for more general containers than just lists, but you can think of lists in this example. It gets a predicate for an element of the <em>Foldable</em> type - the list in
this case, and also takes a container of <em>a</em>s - again a list in this example, and returns a <em>Maybe a</em>.</p>
<p>The logic is that if it finds an element that satisfies the predicate, it will return it as a <em>Just</em>, otherwise it will return <em>Nothing</em>. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">EvenOdd</span><span class="o">&gt;</span> <span class="n">find</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">8</span>

<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">EvenOdd</span><span class="o">&gt;</span> <span class="n">find</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>We have two contracts, one for each of the players.</p>
<p>Each contract has its own params type. For the <em>firstGame</em> contract, we call this type <em>FirstParams</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">FirstParams</span> <span class="ow">=</span> <span class="kt">FirstParams</span>
    <span class="p">{</span> <span class="n">fpSecond</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">fpStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">fpPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">fpRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">fpNonce</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">ByteString</span>
    <span class="p">,</span> <span class="n">fpCurrency</span>       <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">fpTokenName</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">fpChoice</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">GameChoice</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>We don’t need a <em>fpFirst</em> field here, as the first player is the owner of the wallet, so we know their public key hash. But we need <em>fpSecond</em> and also the familiar
fields for stake, play deadline and reveal deadline.</p>
<p>Then we need the nonce, the NFT (split into <em>fpCurrency</em> and <em>fpTokenName</em>), and finally the move that the player wants to make.</p>
<p>Now, for the contract</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">firstGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">FirstParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">firstGame</span> <span class="n">fp</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first thing we do is to get our own public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
</pre></div>
</div>
<p>Then we populate the fields of the game.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Game</span>
        <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">pkh</span>
        <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">fpSecond</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">fpStake</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">fpCurrency</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fpTokenName</span> <span class="n">fp</span><span class="p">)</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>The <em>v</em> value is our stake plus the NFT, which must both go into the UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">v</span>    <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">fpStake</span> <span class="n">fp</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We then calculate the hash that we need to send as our disguised move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">c</span>    <span class="ow">=</span> <span class="n">fpChoice</span> <span class="n">fp</span>
    <span class="n">bs</span>   <span class="ow">=</span> <span class="n">sha2_256</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="kr">then</span> <span class="n">bsZero</span> <span class="kr">else</span> <span class="n">bsOne</span>
</pre></div>
</div>
<p>We then submit the transaction and wait as usual. The constraints are very simple. We just need to create a UTxI with the datum of our move (nothing yet for the second player), and the value <em>v</em> we defined above.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">tx</span>   <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">v</span>
<span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span> <span class="n">tx</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">fpChoice</span> <span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<p>And we wait for the play deadline slot, at which point the winner can be determined.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
</pre></div>
</div>
<p>Once the deadline passed, we get hold of the UTxO. If, at this point, the UTxO is not found, something has gone very wrong. We know that we have produced the UTxO, and the
only thing that the second player should be able to do is create a new one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
<span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>             <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="s">&quot;game output not found&quot;</span>
</pre></div>
</div>
<p>So, assuming we find it, the first case we define is the one where the second player hasn’t moved. So we can use the <em>ClaimFirst</em> redeemer to get the stake back.</p>
<p>As lookups we need to provide the UTxO and the validator of the game.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">dat</span> <span class="kr">of</span>
    <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player did not play&quot;</span>
        <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                      <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
            <span class="n">tx&#39;</span>     <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">ClaimFirst</span><span class="p">)</span>
        <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx&#39;</span>
        <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;reclaimed stake&quot;</span>
</pre></div>
</div>
<p>The second case is that the second player did move, and they lost. In which case we must now reveal our nonce, which we do using the <em>Reveal</em> redeemer.</p>
<p>We must put an additional constraint that the transaction must be submitted before the reveal deadline has passed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">c&#39;</span> <span class="o">==</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and lost&quot;</span>
    <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>                                         <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
        <span class="n">tx&#39;</span>     <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">Reveal</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span><span class="p">)</span>
    <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;victory&quot;</span>
</pre></div>
</div>
<p>If the second player moved and won, there is nothing for use to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and won&quot;</span>
</pre></div>
</div>
<p>The params for the second player are similar to those of the first player. This time we don’t need the second player’s public key hash, because that is ours, and we already
know what it is. Instead we need the first player’s public key hash. Also, we don’t need the nonce.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">SecondParams</span> <span class="ow">=</span> <span class="kt">SecondParams</span>
    <span class="p">{</span> <span class="n">spFirst</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">spStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">spPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">spRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">spCurrency</span>       <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">spTokenName</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">spChoice</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">GameChoice</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>First we get our own public key hash then we set up the game values, in a similar way as we did for the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">secondGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">SecondParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">secondGame</span> <span class="n">sp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Game</span>
            <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">spFirst</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">spStake</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">spCurrency</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spTokenName</span> <span class="n">sp</span><span class="p">)</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>Now, we try to find the UTxO that contains the NFT</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
</pre></div>
</div>
<p>If we don’t find it, then there is nothing to do, but if we do find it…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;running game found&quot;</span>
</pre></div>
</div>
<p>Then we want to call the script with the <em>Play</em> redeemer.</p>
<p>We assign the NFT to <em>token</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">token</span>   <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We now calculate the value that we must put in the new output. Remember, if we decide to play, we must consume the existing UTxO and create a new one at the same address. The
first will contain the stake that the first player added, and now we must add our own stake, and we must keep the NFT in there.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">spStake</span> <span class="n">sp</span><span class="p">)</span> <span class="kr">in</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">token</span>
</pre></div>
</div>
<p>Next, our choice.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">spChoice</span> <span class="n">sp</span>
</pre></div>
</div>
<p>Then the constraints and their required lookups.</p>
<p>We must consume the existing UTxO using the Play redeemer with our choice</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
</pre></div>
</div>
<p>And create a new UTxO with the updated datum (the same <em>bs</em>, but with our choice), and with the <em>v</em> that we computed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">c</span><span class="p">)</span> <span class="n">v</span> <span class="o">&lt;&gt;</span>
</pre></div>
</div>
<p>And it must be done before the deadline passes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>For lookups, we need the UTxO, the validator, and, because we are producing a UTxO for the script, we need the script instance.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>                            <span class="o">&lt;&gt;</span>
              <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>                                 <span class="o">&lt;&gt;</span>
              <span class="kt">Constraints</span><span class="o">.</span><span class="n">scriptInstanceLookups</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we do the usual thing, we submit, we wait for confirmation and we log.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx</span>
<span class="kr">let</span> <span class="n">tid</span> <span class="ow">=</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="n">tid</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">spChoice</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we wait until the reveal deadline has passed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
</pre></div>
</div>
<p>And we again try to find the UTxO, which could now be a different one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
</pre></div>
</div>
<p>If <em>m’</em> is <em>Nothing</em> - in other words, if we did not find a UTxO, then that means that while we were waiting, the first player revealed and won. So there is nothing
for us to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m&#39;</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>             <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player won&quot;</span>
</pre></div>
</div>
<p>However, if we do find the UTxO, it means the first player didn’t reveal, which means that either they decided not to play, probably because they lost. In any case, we
can now claim the winnings.</p>
<p>Our constraints are that we must spend the UTxO that we found after the deadline has passed, and we must hand back the NFT to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
    <span class="kr">let</span> <span class="n">lookups&#39;</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref&#39;</span> <span class="n">o&#39;</span><span class="p">)</span>                              <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
        <span class="n">tx&#39;</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref&#39;</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span><span class="p">)</span>                      <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">spFirst</span> <span class="n">sp</span><span class="p">)</span> <span class="n">token</span>
    <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups&#39;</span> <span class="n">tx&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player won&quot;</span>
</pre></div>
</div>
<p>If we didn’t find the NFT, then there is nothing for use to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no running game found&quot;</span>
</pre></div>
</div>
<p>That is all the code we need for the two on-chain contracts.</p>
<p>To make them more accessible, we define two <em>Endpoint</em>s, one for the first player, and one for the second. And then we define a contract
called <em>endpoints</em> which offers a choice between these two <em>Endpoint</em>s, and recursively calls itself.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">GameSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;first&quot;</span> <span class="kt">FirstParams</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;second&quot;</span> <span class="kt">SecondParams</span>

<span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">GameSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">first</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">second</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">first</span>  <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;first&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">firstGame</span>
    <span class="n">second</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;second&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">secondGame</span>
</pre></div>
</div>
<p>So this concludes the first version of the game - the version that does not use state machines.</p>
<p>Now, let’s test it using the <em>EmulatorTrace</em> monad.</p>
<p>The <em>test</em> function tests each of the four combinations by calling the <em>test’</em> function which takes the first and second players’ choices respectively.</p>
<p>The <em>test’</em> function uses the <em>runEmulatorTraceIO’</em> variant which allows us to set up the initial wallet distributions using an <em>EmulatorConfig</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">test&#39;</span> <span class="kt">Zero</span> <span class="kt">Zero</span>
    <span class="n">test&#39;</span> <span class="kt">Zero</span> <span class="kt">One</span>
    <span class="n">test&#39;</span> <span class="kt">One</span> <span class="kt">Zero</span>
    <span class="n">test&#39;</span> <span class="kt">One</span> <span class="kt">One</span>

<span class="nf">test&#39;</span> <span class="ow">::</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test&#39;</span> <span class="n">c1</span> <span class="n">c2</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">emCfg</span> <span class="o">$</span> <span class="n">myTrace</span> <span class="n">c1</span> <span class="n">c2</span>
  <span class="kr">where</span>
    <span class="n">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
    <span class="n">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
        <span class="p">[</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="kt">AssetClass</span> <span class="p">(</span><span class="n">gameTokenCurrency</span><span class="p">,</span> <span class="n">gameTokenName</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">,</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="n">v</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="mi">1000_000_000</span>
</pre></div>
</div>
<p>As NFTs are not the focus of this lecture, we have conjured a test NFT out of thin air. In a real world scenario, we would need to mint a real NFT, using one of the methods we have seen before.</p>
<p>Now the trace. We pass the two game choices into the <em>myTrace</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="n">c1</span> <span class="n">c2</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c1</span> <span class="o">++</span> <span class="s">&quot;, second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c2</span>
</pre></div>
</div>
<p>Then we start two instances of the contract, one for wallet 1 and one for wallet 2.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
<span class="nf">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
</pre></div>
</div>
<p>We look up the two public key hashes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">pkh1</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">1</span>
    <span class="n">pkh2</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Then we define the parameters that we are going to use for the contracts. In reality <em>fpNonce</em> would be some random string, but here we just hardcode as “SECRETNONCE”.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fp</span> <span class="ow">=</span> <span class="kt">FirstParams</span>
        <span class="p">{</span> <span class="n">fpSecond</span>         <span class="ow">=</span> <span class="n">pkh2</span>
        <span class="p">,</span> <span class="n">fpStake</span>          <span class="ow">=</span> <span class="mi">5000000</span>
        <span class="p">,</span> <span class="n">fpPlayDeadline</span>   <span class="ow">=</span> <span class="mi">5</span>
        <span class="p">,</span> <span class="n">fpRevealDeadline</span> <span class="ow">=</span> <span class="mi">10</span>
        <span class="p">,</span> <span class="n">fpNonce</span>          <span class="ow">=</span> <span class="s">&quot;SECRETNONCE&quot;</span>
        <span class="p">,</span> <span class="n">fpCurrency</span>       <span class="ow">=</span> <span class="n">gameTokenCurrency</span>
        <span class="p">,</span> <span class="n">fpTokenName</span>      <span class="ow">=</span> <span class="n">gameTokenName</span>
        <span class="p">,</span> <span class="n">fpChoice</span>         <span class="ow">=</span> <span class="n">c1</span>
        <span class="p">}</span>
<span class="nf">sp</span> <span class="ow">=</span> <span class="kt">SecondParams</span>
        <span class="p">{</span> <span class="n">spFirst</span>          <span class="ow">=</span> <span class="n">pkh1</span>
        <span class="p">,</span> <span class="n">spStake</span>          <span class="ow">=</span> <span class="mi">5000000</span>
        <span class="p">,</span> <span class="n">spPlayDeadline</span>   <span class="ow">=</span> <span class="mi">5</span>
        <span class="p">,</span> <span class="n">spRevealDeadline</span> <span class="ow">=</span> <span class="mi">10</span>
        <span class="p">,</span> <span class="n">spCurrency</span>       <span class="ow">=</span> <span class="n">gameTokenCurrency</span>
        <span class="p">,</span> <span class="n">spTokenName</span>      <span class="ow">=</span> <span class="n">gameTokenName</span>
        <span class="p">,</span> <span class="n">spChoice</span>         <span class="ow">=</span> <span class="n">c2</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>And then we call the endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;first&quot;</span> <span class="n">h1</span> <span class="n">fp</span>

<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;second&quot;</span> <span class="n">h2</span> <span class="n">sp</span>

<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Now, we can run this test from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cabal</span> <span class="n">repl</span>
<span class="kt">Prelude</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">StateMachine</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">Test</span>
<span class="kt">Prelude</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">Test</span><span class="o">&gt;</span> <span class="n">test</span>
</pre></div>
</div>
<p>The first scenario is that both play zero, so the first wallet should win.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">fbe753823edc9d69538ae9a03702708ccac2b9ae58b8426bcfcf99e274dd552</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">USER</span> <span class="kt">LOG:</span> <span class="n">first</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span><span class="p">,</span> <span class="n">second</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
</pre></div>
</div>
<p>The first wallet creates the initial UTxO with its stake, and logs a message that it made the move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;first&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;fpChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;fpCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpNonce&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;5345435245544e4f4e4345&quot;</span><span class="p">),(</span><span class="s">&quot;fpPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;fpRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;fpSecond&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;fpTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made first move: Zero&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Slot</span> <span class="mi">00003</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">4</span>
</pre></div>
</div>
<p>While the first wallet is waiting, the second wallet kicks in and finds the UTxO, sees that it can make a move, and does so.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;second&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;spChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;spCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;spFirst&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9&quot;</span><span class="p">)])),(</span><span class="s">&quot;spPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;spRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;spStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;spTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;running game found&quot;</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="mi">9</span><span class="n">ff5cf1ce61c0395b653a57449c39ed14f06bb75600057ea0e32a8d1588d048e</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">ff5cf1ce61c0395b653a57449c39ed14f06bb75600057ea0e32a8d1588d048e</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">5</span>
<span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made second move: Zero&quot;</span>
</pre></div>
</div>
<p>The first player realizes that they have won, and so must reveal. And we see in the final balances that Wallet 1 does indeed have the NFT back and it also has
almost 5 ada more than it started with. The difference is, of course, due to transaction fees. And the second wallet has a little more than 5 ada less.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">6</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player played and lost&quot;</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="n">ea946a524a7a3959743fc4c5dbc3982bf1510a84d973fecbb660a328bb58c0b5</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">ea946a524a7a3959743fc4c5dbc3982bf1510a84d973fecbb660a328bb58c0b5</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">7</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;victory&quot;</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">8</span>
<span class="kt">Slot</span> <span class="mi">00008</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">9</span>
<span class="kt">Slot</span> <span class="mi">00009</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">10</span>
<span class="kt">Slot</span> <span class="mi">00010</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">11</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;first player won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">12</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">13</span>
<span class="kt">Slot</span> <span class="mi">00013</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">14</span>
<span class="kt">Slot</span> <span class="mi">00014</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">15</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1004999980</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">994999990</span>
</pre></div>
</div>
<p>In the second case, Wallet 1 again plays Zero, but this time Wallet 2 plays One.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">fbe753823edc9d69538ae9a03702708ccac2b9ae58b8426bcfcf99e274dd552</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">USER</span> <span class="kt">LOG:</span> <span class="n">first</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span><span class="p">,</span> <span class="n">second</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">One</span>
</pre></div>
</div>
<p>The beginning is the same.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;first&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;fpChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;fpCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpNonce&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;5345435245544e4f4e4345&quot;</span><span class="p">),(</span><span class="s">&quot;fpPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;fpRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;fpSecond&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;fpTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made first move: Zero&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Slot</span> <span class="mi">00003</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Now the second wallet finds the game, and makes its move, but now the move is One.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;second&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;spChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;One&quot;</span><span class="p">),(</span><span class="s">&quot;spCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;spFirst&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9&quot;</span><span class="p">)])),(</span><span class="s">&quot;spPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;spRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;spStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;spTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;running game found&quot;</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="mi">3200</span><span class="n">aab18d986869a7e9aa65ff45a635e0bc2dff9b04df26a0864355990f9c10</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">3200</span><span class="n">aab18d986869a7e9aa65ff45a635e0bc2dff9b04df26a0864355990f9c10</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">5</span>
<span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made second move: One&quot;</span>
</pre></div>
</div>
<p>Now the first wallet realizes it has lost and does nothing.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">6</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player played and won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">7</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">8</span>
<span class="kt">Slot</span> <span class="mi">00008</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">9</span>
<span class="kt">Slot</span> <span class="mi">00009</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">10</span>
<span class="kt">Slot</span> <span class="mi">00010</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">11</span>
</pre></div>
</div>
<p>The second wallet detects that the deadline has passed without a reveal, and invokes the <em>ClaimSecond</em> endpoint to get the money. When we look at the final balances,
Wallet 1 again has the NFT back, but the Ada balance situation is reversed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="n">a66744d7b4692db9457d9c3a5d832db7d1471299bd36ffe27827f41ec3e999f1</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">a66744d7b4692db9457d9c3a5d832db7d1471299bd36ffe27827f41ec3e999f1</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">12</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">13</span>
<span class="kt">Slot</span> <span class="mi">00013</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">14</span>
<span class="kt">Slot</span> <span class="mi">00014</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">15</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">994999990</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1004999980</span>
</pre></div>
</div>
<p>The remaining two cases are very similar, so we won’t post the logs here.</p>
<p>So, this all seems to work as expected.</p>
</div>
</div>
<div class="section" id="code-example-2">
<h3><span class="section-number">1.7.3. </span>Code Example 2<a class="headerlink" href="#code-example-2" title="Permalink to this headline">¶</a></h3>
<p>Now we will rewrite this code using state machines.</p>
<div class="section" id="what-is-a-state-machine">
<h4><span class="section-number">1.7.3.1. </span>What is a state machine?<a class="headerlink" href="#what-is-a-state-machine" title="Permalink to this headline">¶</a></h4>
<p>A state machine has nothing in particular to do with blockchain. It is a system that starts with some sort of state, there are one or more transitions to other states,
and from those states there are further transitions, and so on, like a directed graph. Some states can be <em>final</em> states, from which there can be no further
transitions.</p>
<div class="figure align-default">
<img alt="_images/week07__00014.png" src="_images/week07__00014.png" />
</div>
<p>If we look again at how our games works, then we can consider it to be a state machine.</p>
<div class="figure align-default">
<img alt="_images/week07__00016.png" src="_images/week07__00016.png" />
</div>
<p>The initial state would be [Hash], where the first player has made the move.</p>
<p>From the initial state, there are two possible transitions. One where Bob plays, and the other where Bob does not player and Alice can reclaim.</p>
<p>In the diagram, all the nodes correspond to states, and all the arrows correspond to transitions.</p>
<p>In the blockchain, the state machine will be represented by a UTxO sitting at the state machine address. The state of the machine will be the datum of that UTxO.
A transition will be a transaction that consumes the current state, using a redeemer that characterizes the transition, and then produces a new UTxO at the same
address, where the datum now reflects the new state.</p>
<p>This pattern fits a lot of situations very nicely, and there is special support in the Plutus libraries to implement such state machines. We will see that when we use
this approach, our code will be much shorter.</p>
<p>The support for state machines is in the package <em>plutus-contract</em>, in module <a class="reference external" href="https://playground.plutus.iohkdev.io/tutorial/haddock/plutus-contract/html/Language-Plutus-Contract-StateMachine.html">Language.Plutus.Contract.StateMachine</a></p>
<p>A StateMachine has two type parameters, <em>s</em> and <em>i</em>, which stand for state and input. These correspond to datum and redeemer, respectively.</p>
<div class="figure align-default">
<img alt="_images/week07__00017.png" src="_images/week07__00017.png" />
</div>
<p>It is a record type with four fields. Probably the most important one is <em>smTransition</em>, which defines which transitions can move which states which other states.</p>
<p>The <em>State s</em> type is basically the datum. It consists of the state itself and a value. Remember that the state of the state machine is represented by a UTxO, which has
a datum and a value.</p>
<div class="figure align-default">
<img alt="_images/week07__00019.png" src="_images/week07__00019.png" />
</div>
<p>Given the state type <em>s</em>, and a transaction that tries to consume this UTxO with a redeemer <em>i</em>, we can indicate that this transition is not allowed by returning <em>Nothing</em>.
If it is allowed, we return a tuple.</p>
<p>The second component of the tuple is the new state (the new datum and value), which is the new UTxO sitting at the same address, with the
first UTxO having been consumed.</p>
<p>The first component of the tuple specifies additional constraints that the transaction that does this must satisfy. Until now, we have only seen constraints in off-chain
code.</p>
<p>We then have a function <em>setFinal</em> which is predicated on the state which tells us whether it is a final state or not. Final states are special in that the resulting
<em>State</em> from the <em>setTransition</em> function must have no value attached to it, and the output does not get produced. The machine ends there.</p>
<p>The function <em>smCheck</em> is very similar to the <em>setTransition</em> function. It gets the datum, the redeemer and the context and returns a bool.
It provides additional checks that can’t be expressed by the <em>TxConstraints</em> in <em>setTransition</em>.</p>
<p>Finally, <em>smThreadToken</em> allows us to identify the UTxO which represents the current state. This is in the even that there us more than one UTxO sitting at the address
of the state machine. It uses the same trick that we have seen before of using an NFT sitting in the value of the correct UTxO. You could, however, always return <em>Nothing</em>
from <em>smThreadToken</em> and use some other mechanism to identify the correct UTxO.</p>
<p>The same game from example 1 has been implemented using a state machine, in the following module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week07.StateMachine</span>
</pre></div>
</div>
<p>The first parts of the code are the same - we have the same <em>Game</em> type and the same <em>GameChoice</em>. The first change we notice is with <em>GameDatum</em>.</p>
<p>We have added a second constructor to <em>GameDatum</em> called <em>Finished</em>. This will represent the final state of the state machine. It won’t correspond to a UTxO, but we
need it for the state machine mechanism to work.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameDatum</span> <span class="ow">=</span> <span class="kt">GameDatum</span> <span class="kt">ByteString</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">GameChoice</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Finished</span>
<span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>And this adds a little more complexity to the definition of equality.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameDatum</span> <span class="kr">where</span>
<span class="cm">{-# INLINABLE (==) #-}</span>
<span class="kt">GameDatum</span> <span class="n">bs</span> <span class="n">mc</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs&#39;</span> <span class="n">mc&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">bs</span> <span class="o">==</span> <span class="n">bs&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mc</span> <span class="o">==</span> <span class="n">mc&#39;</span><span class="p">)</span>
<span class="kt">Finished</span>        <span class="o">==</span> <span class="kt">Finished</span>          <span class="ow">=</span> <span class="kt">True</span>
<span class="kr">_</span>               <span class="o">==</span> <span class="kr">_</span>                 <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>The redeemer is exactly the same as before. The <em>lovelaces</em> and <em>gameDatum</em> helper functions are also exactly the same as before.</p>
<p>Now we get to the <em>transition</em> function, which sort of corresponds to the <em>mkGameValidator</em> function that we used in the previous example. It is basically the core
business logic.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">GameDatum</span><span class="p">)</span>
</pre></div>
</div>
<p>The <em>transition</em> function takes the <em>Game</em>, then a <em>State GameDatum</em>, which, as we saw in the definition of <em>StateMachine</em>, is a pair consisting of the datum and the value.
Thirdly, it takes the redeemer, and then returns a <em>Maybe</em> of the new state and constraints on the transaction.</p>
<p>Let’s compare the <em>transition</em> function of the state machine with the <em>mkGameValidator</em> function from our first game version.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">GameDatum</span><span class="p">)</span>
<span class="nf">transition</span> <span class="n">game</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span>         <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>
                                                     <span class="p">)</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="kr">_</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span>       <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                     <span class="p">)</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span>         <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>   <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                     <span class="p">)</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                                       <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                     <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                     <span class="p">)</span>
    <span class="kr">_</span>                                        <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
  <span class="kr">where</span>
    <span class="n">token</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">token</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The first thing to notice is that, in the <em>transition</em> function we do not need to do our initial check for the presence of the NFT. This is because the state machine
takes care of that, so long as we set the last field of the <em>StateMachine</em> to some NFT asset class.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- we no longer need something like this for our state machine version</span>
<span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</pre></div>
</div>
<p>Let’s remind ourselves how we defined the first case where the first player had moved, the second player had not yet moved, and now the second player wants to make a move.
We had six conditions.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span>            <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>                             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>         <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span>     <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s see how these conditions are reflected in the state machine version.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="n">game</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>
                                             <span class="p">,</span> <span class="kt">State</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">lovelaceValueOf</span> <span class="o">$</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>
                                             <span class="p">)</span>
</pre></div>
</div>
<p>We can access the value and datum components of our <em>State</em> parameter using <em>stateValue</em> and <em>stateData</em>, which gives us the triple for our <em>case</em> statement of
value, datum and redeemer.</p>
<p>Our matching case is now</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>First we check that the number of lovelaces in the value matches the stake of the game, which was our second condition in our code for this case from example 1. If this
condition is satisfied, we return a <em>Just</em> pair. The first component of the pair is the constraints on the transaction (formulated from the <em>Constraints</em> module that we know from off-chain code). The
two constraints that comprise this part of the pair correspond to the first and fifth conditions in our old code.</p>
<p>The second component of the pair is the new state - the resulting UTxO - which again is given by datum and value. So here we are specifying that the datum of the new
UTxO will contain both players’ choices, and the value of the UTxO will contain both players’ stakes. We leave the NFT out of this condition, even though it will be
present in the UTxO, and that is again because the state machine implicitly takes care of this for us.</p>
<p>This second component corresponds with the third and fourth conditions from our old code.</p>
<p>The sixth condition from our old code related to the NFT which, as we have seen, we do not need to worry about.</p>
<p>Now let’s compare the code from the second interesting case, where the second player has played and the first player sees that they have won.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- old version</span>
<span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="n">nonce</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;commit mismatch&quot;</span>               <span class="p">(</span><span class="n">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">c</span><span class="p">)</span>                                            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>       <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- new version</span>
<span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="kr">_</span><span class="p">)</span>
<span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span>       <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                             <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                             <span class="p">)</span>
</pre></div>
</div>
<p>Again, we see that the first thing we do is to check that the correct stake exists, and if it does, we again return a <em>Just</em>. So, this takes care of
condition four from the old code. Condition one from the old code is taken care of by the <em>Constraints.mustBeSignedBy</em> constraint in the new code.</p>
<p>Note that we do not check the nonce in the new code. The reason for this is that this check cannot be expressed in terms of a constraint. And this is exactly what
the <em>smCheck</em> function is for, and we will see how this is used for this in a moment.</p>
<p>We can also match up the deadline check from each code sample, with it being defined using <em>Constraints.mustValidateIn</em> in the new code.</p>
<p>In the old code, when the game was over, we returned the NFT to the first player. In the new code, we also make sure the NFT goes back to the first player, but
we also specify the <em>Finished</em> state and say that there is no money left in the contract using <em>mempty</em>.</p>
<p>Now we compare the old and the new code for the third case where the first player reclaims their stake when the second player does not play by the deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- old version</span>
<span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- new version</span>

<span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span>
<span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span>         <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span>                     <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span>   <span class="o">&lt;&gt;</span>
                                               <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                             <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                             <span class="p">)</span>
</pre></div>
</div>
<p>These two match up fairly easily, with the lovelaces being the condition on the left in the new code, and the remaining conditions on the right in the new code matching up with
corresponding conditions in the old code. Again we add the <em>Finished</em> state in the new code.</p>
<p>The last case, where the second player has played and the first player does not reveal by the deadline, probably because they lost.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">lovelaces</span> <span class="n">v</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">)</span>                    <span class="o">&lt;&gt;</span>
                                                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="n">token</span>
                                                 <span class="p">,</span> <span class="kt">State</span> <span class="kt">Finished</span> <span class="n">mempty</span>
                                                 <span class="p">)</span>
</pre></div>
</div>
<p>The conditions in the old and the new code for this last case can be matched up in a very similar way to those for the third case.</p>
<p>All other states with arbitrary transitions are invalid, and we indicate that by returning <em>Nothing</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>In the end we see that while the conditions themselves may not be much shorter in the new version than those in the old version, we also see that we only need one helper
function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">token</span> <span class="ow">::</span> <span class="kt">Value</span>
<span class="nf">token</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>But we are not yet finished defining the state machine. There are some other fields in the <em>StateMachine</em> record.</p>
<p>One is <em>smFinal</em>, which lets us define what the final states are. For us, it is just the <em>Finished</em> state. We define a helper function that we can use for this field.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">final</span> <span class="ow">::</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">final</span> <span class="kt">Finished</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">final</span> <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Another field to define is <em>smCheck</em>. Recall that this is where we can put conditions that cannot be expressed as <em>Constraint</em>s. So this is where we can put our nonce check.</p>
<p>We define another helper function <em>check</em>, with two auxiliary <em>ByteString</em> parameters to represent the zero and one choices, for reasons that we have seen before. We also
pass it the datum, redeemer and context, and it will return us a boolean.</p>
<p>We don’t need the script context, but we need the datum to get the second player’s choice (which the first player is claiming is the same as theirs), and the redeemer
to get the nonce that the first player is claiming to have used. We can then check that the hash of the choice and the nonce match the original hash from the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">check</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">check</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span> <span class="p">(</span><span class="kt">Reveal</span> <span class="n">nonce</span><span class="p">)</span> <span class="kr">_</span> <span class="ow">=</span>
    <span class="n">sha2_256</span> <span class="p">(</span><span class="n">nonce</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="kr">then</span> <span class="n">bsZero&#39;</span> <span class="kr">else</span> <span class="n">bsOne&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">bs</span>
</pre></div>
</div>
<p>In all other situations, those that are not checking the revealed nonce, we don’t need to perform any checks.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">check</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Now we can define our state machine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameStateMachine</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">StateMachine</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
<span class="nf">gameStateMachine</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="ow">=</span> <span class="kt">StateMachine</span>
    <span class="p">{</span> <span class="n">smTransition</span>  <span class="ow">=</span> <span class="n">transition</span> <span class="n">game</span>
    <span class="p">,</span> <span class="n">smFinal</span>       <span class="ow">=</span> <span class="n">final</span>
    <span class="p">,</span> <span class="n">smCheck</span>       <span class="ow">=</span> <span class="n">check</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span>
    <span class="p">,</span> <span class="n">smThreadToken</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">gToken</span> <span class="n">game</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Our old <em>mkGameValidator</em> can now be replaced by using machinery provided by the state machine. There is a <em>mkValidator</em> function which will take our
state machine, generated by the <em>gameStateMachine</em> function and turn it into a validator with exactly the same type as we had in the old code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkGameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkGameValidator</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="ow">=</span> <span class="n">mkValidator</span> <span class="o">$</span> <span class="n">gameStateMachine</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span>
</pre></div>
</div>
<p>In the old code we had this mechanism to bundle datum and redeemer into a <em>Gaming</em> type.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- old code</span>
<span class="kr">data</span> <span class="kt">Gaming</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Gaming</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameDatum</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>But now we can define this as.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">StateMachine</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>We also provide an alternate version of <em>gameStateMachine</em>, which doesn’t take the two auxiliary <em>ByteString</em>s. This won’t work for on-chain code, but for off-chain
code it works just fine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameStateMachine&#39;</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">StateMachine</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
<span class="nf">gameStateMachine&#39;</span> <span class="n">game</span> <span class="ow">=</span> <span class="n">gameStateMachine</span> <span class="n">game</span> <span class="n">bsZero</span> <span class="n">bsOne</span>
</pre></div>
</div>
<p>We have the same boilerplate as before for <em>gameInst</em>, <em>gameValidator</em> and <em>gameAddress</em>, which we won’t copy again here.</p>
<p>The function <em>gameClient</em> is new. It is a <em>StateMachineClient</em>, and this is what we need to interact with our state machine from our wallet in the <em>Contract</em> monad.</p>
<div class="figure align-default">
<img alt="_images/week07__00018.png" src="_images/week07__00018.png" />
</div>
<p>As you can see from the definition, it contains a <em>StateMachineInstance</em>. And the <em>StateMachineInstance</em> in turn is just a <em>StateMachine</em> and the corresponding script
instance.</p>
<div class="figure align-default">
<img alt="_images/week07__00020.png" src="_images/week07__00020.png" />
</div>
<p>Once we have that, the <em>StateMachineClient</em> still needs to be bundled with a so called <em>chooser</em>, which is the mechanism, from the off-chain code, for finding the UTxO that represents our
state machine. In general there will be a list of UTxOs at the address of the state machine, and <em>scChooser</em> is a function that specifies which to pick.</p>
<p>We don’t have to worry about that, because we are using the NFT approach, which means that the choosing is taken care of for us automatically.</p>
<p>There is a function <em>mkStateMachineClient</em> that takes a <em>StateMachineInstance</em> and returns a <em>StateMachineClient</em>, and this uses the default implementation of the chooser.
And this will do the right thing and pick the UTxO that contains our NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameClient</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">StateMachineClient</span> <span class="kt">GameDatum</span> <span class="kt">GameRedeemer</span>
<span class="nf">gameClient</span> <span class="n">game</span> <span class="ow">=</span> <span class="n">mkStateMachineClient</span> <span class="o">$</span> <span class="kt">StateMachineInstance</span> <span class="p">(</span><span class="n">gameStateMachine&#39;</span> <span class="n">game</span><span class="p">)</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, <em>gameClient</em> can be used to interact with the state machine from off-chain code.</p>
<p><em>FirstParams</em> is exactly the same, so we won’t repeat it here.</p>
<p>There is one small nuisance. The state machine contracts provided by the state machine module have a specific constraint on the error type. One error type that works
is <em>SMContractError</em>.</p>
<p>But we want to do what we did in the last lectures and always use <em>Text</em> as the error type. To achieve this we will use a helper function to convert the <em>SMContractError</em>
type into a <em>Text</em> type. Recall that <em>show</em> will return a <em>String</em> and <em>pack</em> will convert a <em>String</em> into a <em>Text</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapError&#39;</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">SMContractError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapError&#39;</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>
</pre></div>
</div>
<p>So now the first player contract becomes much shorter and more compact.</p>
<p>The beginning is the same.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">firstGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">FirstParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">firstGame</span> <span class="n">fp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">game</span>   <span class="ow">=</span> <span class="kt">Game</span>
            <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">fpSecond</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">fpStake</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span>
            <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">fpCurrency</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fpTokenName</span> <span class="n">fp</span><span class="p">)</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>Now, we take the client along with some values that we get as before.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">client</span> <span class="ow">=</span> <span class="n">gameClient</span> <span class="n">game</span>
<span class="nf">v</span>      <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">fpStake</span> <span class="n">fp</span><span class="p">)</span>
<span class="nf">c</span>      <span class="ow">=</span> <span class="n">fpChoice</span> <span class="n">fp</span>
<span class="nf">bs</span>     <span class="ow">=</span> <span class="n">sha2_256</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="kr">then</span> <span class="n">bsZero</span> <span class="kr">else</span> <span class="n">bsOne</span>
</pre></div>
</div>
<p>There is a function <em>runIntialise</em> that starts a state machine and creates a UTxO at the state machine address. It takes the client as its first argument and then
it needs the initial datum and the initial value for the UTxO sitting at that address. And it will automatically put the NFT there as well.</p>
<div class="highlight-Haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runInitialise</span> <span class="n">client</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">v</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">fpChoice</span> <span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, the state machine is setup and the first player has made their move.</p>
<p>We wait until the play deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
</pre></div>
</div>
<p>In our first example, we defined a helper function <em>findGameOutput</em> to get the current <em>UTxO</em>, but this can now be done in a simpler way using <em>getOnChainState</em>.</p>
<div class="figure align-default">
<img alt="_images/week07__00021.png" src="_images/week07__00021.png" />
</div>
<p>The function <em>getOnChainState</em> will return a <em>Just OnChainState</em> if it finds the state machine, or a <em>Nothing</em> if it does not find it.</p>
<div class="figure align-default">
<img alt="_images/week07__00022.png" src="_images/week07__00022.png" />
</div>
<p>So what is <em>OnChainState</em>? It is a tuple consisting of <em>TypedScriptTxOut</em> and <em>TypedScriptTxOutRef</em>. This is similar to what <em>utxoAt</em> gives us, which was a map of
<em>TxOutRefs</em>s to <em>TxOuts</em>s. This is similar in that it is a output and its reference, but it is this <em>Typed</em> version that we haven’t seen before.</p>
<p>All that does is bundle what we know from before, <em>TxOut</em>, but additionally it provides the datum. You’ll recall that in our off-chain code we always have to scramble
and write helper functions to access the datum once we had found the UTxO. We had to look up the datum hash, which could fail, and so on. <em>TypedScriptTxOut</em> hides all
this from us.</p>
<div class="figure align-default">
<img alt="_images/week07__00023.png" src="_images/week07__00023.png" />
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">getOnChainState</span> <span class="n">client</span>
</pre></div>
</div>
<p>As before, we should never get <em>Nothing</em> for <em>m</em>.</p>
<blockquote>
<div><dl class="simple">
<dt>case m of</dt><dd><p>Nothing             -&gt; throwError “game output not found”</p>
</dd>
</dl>
</div></blockquote>
<p>Now, we are only interested in the <em>TypedScriptTxOut</em> parameter, which we assign to <em>o</em>, and use it to lookup the datum using <em>tyTxOutData</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">),</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">tyTxOutData</span> <span class="n">o</span> <span class="kr">of</span>
</pre></div>
</div>
<p>As before we have the two cases. Either the second player has moved, or they haven’t moved.</p>
<p>If they haven’t moved, we must reclaim. Earlier we had lots of code to setup the lookups and constraints that we needed. How we only need one line, and the important
function here is <em>runStep</em>, which creates and submits a transaction that will transition the state machine.</p>
<p>It takes as input the client and the redeemer. It then returns a <em>TransitionResult</em>, which we are not using in this example, but basically encodes whether it succeeded
or failed.</p>
<div class="figure align-default">
<img alt="_images/week07__00024.png" src="_images/week07__00024.png" />
</div>
<p>Which means, that we can use <em>runStep</em> with just the client and redeemer to replace all the lookups, the constraints, the transaction submissions and the waiting.</p>
<p>The way it works it that the <em>transition</em> function is that all the necessary constraints have been defined as part of the state machine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player did not play&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="kt">ClaimFirst</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player reclaimed stake&quot;</span>
</pre></div>
</div>
<p>The second case is that the first player did reveal, and we again use the <em>runStep</em> function to transition the state machine.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">c&#39;</span> <span class="o">==</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and lost&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="o">$</span> <span class="kt">Reveal</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player revealed and won&quot;</span>
</pre></div>
</div>
<p>And in all other situations, the second player wins.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and won&quot;</span>
</pre></div>
</div>
<p>The second player’s contract is very similar, and just as simple.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">secondGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">SecondParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">secondGame</span> <span class="n">sp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">game</span>   <span class="ow">=</span> <span class="kt">Game</span>
            <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">spFirst</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">spStake</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">spCurrency</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spTokenName</span> <span class="n">sp</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="n">client</span> <span class="ow">=</span> <span class="n">gameClient</span> <span class="n">game</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">getOnChainState</span> <span class="n">client</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>          <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no running game found&quot;</span>
        <span class="kt">Just</span> <span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="kr">_</span><span class="p">),</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">tyTxOutData</span> <span class="n">o</span> <span class="kr">of</span>
</pre></div>
</div>
<p>The only case we need to address is where we haven’t played yet, and so should play. And, in order to play, we again use the <em>runStep</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;running game found&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="o">$</span> <span class="kt">Play</span> <span class="o">$</span> <span class="n">spChoice</span> <span class="n">sp</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">spChoice</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>We then wait until the reveal deadline has passed, then get the new state.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
<span class="nf">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">getOnChainState</span> <span class="n">client</span>
<span class="kr">case</span> <span class="n">m&#39;</span> <span class="kr">of</span>
</pre></div>
</div>
<p>If there is no state, the first player has won and claimed their winnings.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player won&quot;</span>
</pre></div>
</div>
<p>Otherwise, we have won, and we claim our winnings using the <em>runStep</em> function, giving the <em>ClaimSecond</em> redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="kr">_</span>  <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">mapError&#39;</span> <span class="o">$</span> <span class="n">runStep</span> <span class="n">client</span> <span class="kt">ClaimSecond</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player won&quot;</span>
</pre></div>
</div>
<p>And a final catch all.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="s">&quot;unexpected datum&quot;</span>
</pre></div>
</div>
<p>That concludes the state machine version of the code.</p>
<p>What is particularly nice about this approach is that we don’t need to replicate logic anymore. We have discussed how off-chain code is used for construction and
on-chain code is used for checking. When we use the state machine approach, we define logic that can be used for both, so we do not need to write it explicitly for the
off-chain part and the on-chain part of the code.</p>
<p>In order to test this, there is a module called <em>Week07.TestStateMachine</em> in the example code. It is exactly the same as the test for the old code, with one exception,
and that is just that instead of importing <em>Week07.EvenOdd</em>, it imports <em>Week07.StateMachine</em>. This is a quick and dirty way of doing things - we could, of course,
have written a script that was parameterized over the contract we want to use.</p>
<p>If you load <em>Week07.TestStateMachine</em> in the REPL and run <em>test</em>, you should get exactly the same results as before.</p>
</div>
</div>
<div class="section" id="conclusion">
<h3><span class="section-number">1.7.4. </span>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h3>
<p>State machines are not always appropriate, but when they are, you should definitely use them. They dramatically reduce the amount of code you have to write, and also
reduce sources of errors.</p>
<p>The state machine mechanism automatically ensures that you have on-chain and off-chain code that are working correctly together. Until now, we have always had to take care of that ourselves.</p>
</div>
</div>
<div class="section" id="week-08-property-based-testing">
<h2><span class="section-number">1.8. </span>Week 08 - Property Based Testing<a class="headerlink" href="#week-08-property-based-testing" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://youtu.be/JMRwkMgaBOg">Lecture
#8</a>.</p>
<p>In this lecture we cover another state machine example, automatic testing using emulator traces, optics, and property-based testing.</p>
<p>This week we were using Plutus commit ae35c4b8fe66dd626679bd2951bd72190e09a123, the same commit as we used in the last lecture.</p>
</div>
<div class="section" id="token-sale">
<h3><span class="section-number">1.8.1. </span>Token Sale<a class="headerlink" href="#token-sale" title="Permalink to this headline">¶</a></h3>
<p>In the last lecture we looked at state machines, and saw how they often allow us to write much less code to express the logic of a smart contract, partly because
there is a lot of sharing between on-chain and off-chain code and partly because a lot of boilerplate is encapsulated in the state machine machinery.</p>
<p>In this lecture we will see another example using a state machine, because the concept is very important. We will also take a look at testing.
First we will look at the code, then we will explore various ways to go about testing.</p>
<p>The example we will use is a contract that allows somebody to sell tokens. The idea is that someone call lock some tokens in a contract, set a price, and then
other people can buy them.</p>
<p>To begin, the seller starts with an NFT. It can be an arbitrary NFT and it will just be used, as before, to identify the correct UTxO that contains the contract state.</p>
<p>The first step is to lock the NFT at the script address of the smart contract that we are about to write. We’ll call that contract <em>TS</em> for Token Sale. As a datum, we will
use a simple integer, which will represent the price of the token we are selling, and this will start off as zero.</p>
<div class="figure align-default">
<img alt="_images/week08__00001.png" src="_images/week08__00001.png" />
</div>
<p>There will be several operations that the seller can do. One of those will be setting the price to a different value. In order to do that the seller will submit
a transaction which has the current UTxO as input and the updated UTxO as output, where the datum has been changed to a different price per token.</p>
<div class="figure align-default">
<img alt="_images/week08__00002.png" src="_images/week08__00002.png" />
</div>
<p>Another thing that the seller can do is to lock some tokens in the contract. In order to do that they have to create another transaction which has as input the UTxO of
the contract and a UTxO containing some tokens and, as output, the updated UTxO at the contract address which now contains the provided tokens.</p>
<div class="figure align-default">
<img alt="_images/week08__00003.png" src="_images/week08__00003.png" />
</div>
<p>In this example, the seller provides five tokens to the contract.</p>
<p>In order to buy tokens, there needs to be a transaction created by the buyer. This transaction has as input the UTxO sitting at the TS script address,
and the buying price in Ada.</p>
<p>So, if a buyer wants to buy two tokens, they will create a transaction that has, as input, 12 Ada, and the UTxO at the script address. Then, two outputs. One
the updated contract state where now the tokens are taken out and the Ada has been added, and one output going to the buyer with the tokens that they have just
bought.</p>
<div class="figure align-default">
<img alt="_images/week08__00004.png" src="_images/week08__00004.png" />
</div>
<p>Finally, there must be a way for the seller to retrieve tokens and Ada. In this example if, after the sale, the seller wants to retrieve all the Ada and one token, they
would create a transaction that, again, has the script UTxO as input, and, as output, the updated script UTxO with the reduced balances, and one to themselves with the
retrieved funds.</p>
<p>The diagram just shows one scenario, but these operations can be performed in any order - tokens can be added, the price can be changed, tokens can be bought, and so on,
in an arbitrary order.</p>
<div class="section" id="on-chain-code">
<h4><span class="section-number">1.8.1.1. </span>On-chain code<a class="headerlink" href="#on-chain-code" title="Permalink to this headline">¶</a></h4>
<p>This week’s first example is implemented in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week08.TokenSale</span>
</pre></div>
</div>
<p>Let’s first look at the type that we will use as the parameter that we will use for the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TokenSale</span> <span class="ow">=</span> <span class="kt">TokenSale</span>
    <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>This has three fields - the seller’s public key has, the token being sold, and the NFT used to identify the UTxO.</p>
<p>For the redeemer, we provide exactly the operations we saw in the diagram</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TSRedeemer</span> <span class="ow">=</span>
      <span class="kt">SetPrice</span> <span class="kt">Integer</span>         <span class="c1">-- the price</span>
    <span class="o">|</span> <span class="kt">AddTokens</span> <span class="kt">Integer</span>        <span class="c1">-- the number of tokens to add</span>
    <span class="o">|</span> <span class="kt">BuyTokens</span> <span class="kt">Integer</span>        <span class="c1">-- the number of tokens to buy</span>
    <span class="o">|</span> <span class="kt">Withdraw</span> <span class="kt">Integer</span> <span class="kt">Integer</span> <span class="c1">-- first argument is the number of tokens, the second is the number of lovelace</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Again we have the helper function that we have used in previous examples</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>Now, we get to the <em>transition</em> function of the state machine. We see the <em>TokenSale</em> parameter which holds the state machines configuration values, the <em>State</em>
object with an <em>Integer</em> value to represent the price of the token, then the redeemer <em>TsRedeemer</em>. Again, we return a <em>Maybe</em>, which will be <em>Nothing</em> if the
corresponding transition is illegal, or, if it is legal, a <em>Just</em> containing constraints and the new state.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TSRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="nf">transition</span> <span class="n">ts</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
</pre></div>
</div>
<p>If the <em>SetPrice</em> redeemer is provided, then we only consider it to be legal if the price is not negative. We then return a <em>Just</em> with the constraint that the
transaction must be signed by the token seller, and with the new state. The new state will be the new price <em>p</em>, and the <em>Value</em> in the contract
remains the same, except for one thing.</p>
<p>It is a little unfortunate, but there is a discrepancy between the <em>v</em> on the left and the <em>v</em> on the right. On the left it does not contain the NFT, but
on the right it does not. So, even though we want to say that we don’t want the value changed, in fact we have to remove the NFT, because the Plutus libraries will
add it again. This is perhaps not an ideal design, but that is how it currently is.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kt">SetPrice</span> <span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">tsSeller</span> <span class="n">ts</span><span class="p">)</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span> <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>We use a helper function to reference the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nft</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
<span class="nf">nft</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsNFT</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
<p>When adding tokens, we could check that the seller has signed the transaction, but this contract would be provided by the seller, and the seller doesn’t mind if someone
wants to give them a free gift! Therefore, once we have the <em>AddTokens</em> redeemer and <em>n</em> is greater than zero, we are happy to return the
new state without constraints.</p>
<p>The state that we return is untouched, except for the unfortunate trick we need to do with the NFT, and the addition of the new tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">AddTokens</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                      <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="n">n</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>For the <em>BuyTokens</em> redeemer, again we check the number of tokens is positive, and again we don’t need any constraints, because anybody can buy tokens.</p>
<p>For the new state, we don’t touch the price. We again correct for the NFT. Then we subtract the tokens that were bought, and we add the lovelace that were paid for them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">BuyTokens</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                      <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">negate</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                      <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>Finally, for <em>WithDraw</em>, we insist that the token amount and the lovelace amount are both nonnegative. This time we again add a constraint that the seller must sign
the transaction. We modify the state in a similar way to the way we did for the <em>BuyTokens</em> redeemer, but this time we adjust the token and lovelace amounts according
to how much has been withdrawn.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">Withdraw</span> <span class="n">n</span> <span class="n">l</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">tsSeller</span> <span class="n">ts</span><span class="p">)</span>
                                                <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                                  <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                                  <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                                  <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">negate</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                                  <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">negate</span> <span class="n">l</span><span class="p">)</span>
                                                <span class="p">)</span>
</pre></div>
</div>
<p>All other state transitions are illegal.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>In this example we are able to construct our state machine more simply that we could in the previous lecture. This is because, in the previous lecture we had one
condition that could not be expressed in the regular constraints.</p>
<p>In these situations, there is a helper function called <em>mkStateMachine</em> that takes three arguments. The first one is the state token, the second is the transition
function. The last one is to indicate which states are final. In this case, there is no final state. Once this token sale has been setup, it will always be there.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tsStateMachine</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">StateMachine</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>
<span class="nf">tsStateMachine</span> <span class="n">ts</span> <span class="ow">=</span> <span class="n">mkStateMachine</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">$</span> <span class="n">tsNFT</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">transition</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">const</span> <span class="kt">False</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now use the usual boilerplate to turn it into a Plutus smart contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TS</span> <span class="ow">=</span> <span class="kt">StateMachine</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>

<span class="nf">tsInst</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">TS</span>
<span class="nf">tsInst</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">TS</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkTSValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">ts</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">Integer</span> <span class="o">@</span><span class="kt">TSRedeemer</span>

<span class="nf">tsValidator</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">tsValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">tsInst</span>

<span class="nf">tsAddress</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">tsAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">tsValidator</span>

<span class="nf">tsClient</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">StateMachineClient</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>
<span class="nf">tsClient</span> <span class="n">ts</span> <span class="ow">=</span> <span class="n">mkStateMachineClient</span> <span class="o">$</span> <span class="kt">StateMachineInstance</span> <span class="p">(</span><span class="n">tsStateMachine</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">tsInst</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two helper functions to convert specialised error types to <em>Text</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapErrorC</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">C</span><span class="o">.</span><span class="kt">CurrencyError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapErrorC</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>

<span class="nf">mapErrorSM</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">SMContractError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapErrorSM</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>
</pre></div>
</div>
</div>
<div class="section" id="off-chain-code">
<h4><span class="section-number">1.8.1.2. </span>Off-chain code<a class="headerlink" href="#off-chain-code" title="Permalink to this headline">¶</a></h4>
<p>For the off-chain code, we start by defining a constant for the token name of the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nftName</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">nftName</span> <span class="ow">=</span> <span class="s">&quot;NFT&quot;</span>
</pre></div>
</div>
<p>The first contract we define is to start the token sale. This contract is designed to be invoked by the seller.</p>
<p>This first argument is a <em>Maybe CurrencySymbol</em>. The idea here is that if you pass in <em>Nothing</em>, the contract will mint a new NFT. Alternatively, you can provide a
<em>Just CurrencySymbol</em> if the token already exists. We have done it this way mainly to make testing easier.</p>
<p>The <em>AssetClass</em> argument is the token the seller wants to trade.</p>
<p>For the return type, we are using the writer monad type with the <em>Last</em> type. The ideas is that once the token sale has been setup, it will get written here so that other
contracts are able to discover it. In addition, we return the created token sale.</p>
<p>To begin, we lookup the seller’s public key hash. We then need to get hold of the NFT. So, we determine if we need to mint the NFT, and, if we do, we mint it, otherwise we just use the one that was
passed into the function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startTS</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">AssetClass</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">TokenSale</span>
<span class="nf">startTS</span> <span class="n">mcs</span> <span class="n">token</span> <span class="ow">=</span> <span class="kr">do</span>

    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">cs</span>  <span class="ow">&lt;-</span> <span class="kr">case</span> <span class="n">mcs</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>  <span class="ow">-&gt;</span> <span class="kt">C</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="o">&lt;$&gt;</span> <span class="n">mapErrorC</span> <span class="p">(</span><span class="kt">C</span><span class="o">.</span><span class="n">forgeContract</span> <span class="n">pkh</span> <span class="p">[(</span><span class="n">nftName</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="kt">Just</span> <span class="n">cs&#39;</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">cs&#39;</span>
</pre></div>
</div>
<p>And now we can define the <em>TokenSale</em> and create the state machine client.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kt">TokenSale</span>
        <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">=</span> <span class="n">pkh</span>
        <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">=</span> <span class="n">token</span>
        <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">nftName</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="n">client</span> <span class="ow">=</span> <span class="n">tsClient</span> <span class="n">ts</span>
</pre></div>
</div>
<p>We then use the <em>runInitialise</em> function that we discussed in the last lecture, using the client, an initial price of zero, and no initial funds, except for the NFT
which will be automatically added.</p>
<p>We write the <em>ts</em> into the log, then log a message, and return the <em>ts</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runInitialise</span> <span class="n">client</span> <span class="mi">0</span> <span class="n">mempty</span>
<span class="nf">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">ts</span>
<span class="nf">logInfo</span> <span class="o">$</span> <span class="s">&quot;started token sale &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">ts</span>
<span class="nf">return</span> <span class="n">ts</span>
</pre></div>
</div>
<p>The functions for all the other operations are extremely short. This example is ideal for the state machine approach.</p>
<p>They are all very similar. They all invoke <em>runStep</em> and then invoke the correct transition from the state machine.</p>
<p>For example, for <em>setPrice</em>, we need the <em>TokenSale</em> argument to identify the correct contract and the new value of the price. Then we use <em>runStep</em> using the client and
<em>SetPrice</em> as the redeemer. We wrap that using <em>mapErrorSM</em> to convert to <em>Text</em> error messages, and we ignore the result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">setPrice</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">setPrice</span> <span class="n">ts</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">SetPrice</span> <span class="n">p</span>
</pre></div>
</div>
<p>The remaining three follow the same pattern.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">addTokens</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">addTokens</span> <span class="n">ts</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">void</span> <span class="p">(</span><span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">AddTokens</span> <span class="n">n</span><span class="p">)</span>

<span class="nf">buyTokens</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">buyTokens</span> <span class="n">ts</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">BuyTokens</span> <span class="n">n</span>

<span class="nf">withdraw</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">withdraw</span> <span class="n">ts</span> <span class="n">n</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Withdraw</span> <span class="n">n</span> <span class="n">l</span>
</pre></div>
</div>
<p>Now we define three schemas.</p>
<p>One for the seller which just has one endpoint which takes the <em>CurrencySymbol</em> and the <em>TokenName</em> of the asset to be traded.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSStartSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
    <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>For testing purposes, we create <em>TSStartSchema’</em> which additionally takes the <em>CurrencySymbol</em> of the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSStartSchema&#39;</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
    <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>Lastly we have a <em>use</em> schema, with endpoints for the four operations - set price, add tokens, buy tokens and withdraw.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSUseSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;set price&quot;</span>  <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;add tokens&quot;</span> <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;buy tokens&quot;</span> <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;withdraw&quot;</span>   <span class="p">(</span><span class="kt">Integer</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)</span>
</pre></div>
</div>
<p>Now to implement the start endpoint. It simply calls <em>startTs’</em> and recurses. <em>startTs’</em> blocks until the parameters are provided and then calls <em>startTs</em> with
<em>Nothing</em>, indicating that the NFT has to be minted. We wrap it in <em>handleError</em> and if there is an error, we simply log that error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startEndpoint</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">startEndpoint</span> <span class="ow">=</span> <span class="n">startTS&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">startEndpoint</span>
  <span class="kr">where</span>
    <span class="n">startTS&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">void</span> <span class="o">.</span> <span class="n">startTS</span> <span class="kt">Nothing</span> <span class="o">.</span> <span class="kt">AssetClass</span>
</pre></div>
</div>
<p>The <em>startEndpoint’</em> function is very similar, but we add the NFT parameter, as per <em>TSStartSchema’</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startEndpoint&#39;</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema&#39;</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">startEndpoint&#39;</span> <span class="ow">=</span> <span class="n">startTS&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">startEndpoint&#39;</span>
  <span class="kr">where</span>
    <span class="n">startTS&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="p">(</span><span class="n">cs1</span><span class="p">,</span> <span class="n">cs2</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span> <span class="ow">-&gt;</span>  <span class="n">void</span> <span class="o">$</span> <span class="n">startTS</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">cs1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">cs2</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</pre></div>
</div>
<p>No surprises in the <em>use</em> endpoints. We give a choice between the four endpoints and just call the functions we defined earlier with the arguments fed in
from the endpoint call, and with everything wrapped inside an error handler so that the contract won’t crash in the event of an error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">useEndpoints</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">TSUseSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">useEndpoints</span> <span class="n">ts</span> <span class="ow">=</span> <span class="p">(</span><span class="n">setPrice&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">addTokens&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">buyTokens&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">withdraw&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
  <span class="kr">where</span>
    <span class="n">setPrice&#39;</span>  <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;set price&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">setPrice</span> <span class="n">ts</span>
    <span class="n">addTokens&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;add tokens&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">addTokens</span> <span class="n">ts</span>
    <span class="n">buyTokens&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">buyTokens</span> <span class="n">ts</span>
    <span class="n">withdraw&#39;</span>  <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;withdraw&quot;</span>   <span class="o">&gt;&gt;=</span> <span class="n">uncurry</span> <span class="p">(</span><span class="n">withdraw</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h4><span class="section-number">1.8.1.3. </span>Testing<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<p>In order to try it out, let’s run it in the emulator.</p>
<p>We define a <em>runMyTrace</em> function which uses <em>runEmulatorTraceIO’</em> with a custom emulator configuration and a <em>myTrace</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">runMyTrace</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">runMyTrace</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">emCfg</span> <span class="n">myTrace</span>
</pre></div>
</div>
<p>Let’s first look at the <em>emCfg</em> function. Recall that this is where we can give custom initial distributions to wallets. Here we give 1000 Ada and 1000 of a custom
token to three wallets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ability to use underscores in large numbers such as 1000_000_000 is provided by a GHC extension <em>NumericUnderscores</em></p>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
<span class="nf">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="kt">Wallet</span> <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">3</span><span class="p">]]</span>
  <span class="kr">where</span>
    <span class="n">v</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="mi">1000_000_000</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="mi">1000</span>

<span class="nf">currency</span> <span class="ow">::</span> <span class="kt">CurrencySymbol</span>
<span class="nf">currency</span> <span class="ow">=</span> <span class="s">&quot;aa&quot;</span>

<span class="nf">name</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">name</span> <span class="ow">=</span> <span class="s">&quot;A&quot;</span>

<span class="nf">token</span> <span class="ow">::</span> <span class="kt">AssetClass</span>
<span class="nf">token</span> <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">currency</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>For the trace, first we activate Wallet 1 using the non-primed <em>startEndpoint</em> function which mints the NFT is minted automatically. Then, we call the start endpoint, giving it
the symbol and name of the token we want to sell, and then wait for five slots, although two would be enough in this case.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">h</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">startEndpoint</span>
    <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span> <span class="n">h</span> <span class="p">(</span><span class="n">currency</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
    <span class="kt">Last</span> <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">observableState</span> <span class="n">h</span>
</pre></div>
</div>
<p>We then read the state, which we wrote using <em>tell</em>, and check to see if it is valid. If it is not, we log an error. If it is, we proceed with the test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
  <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Extras</span><span class="o">.</span><span class="n">logError</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;error starting token sale&quot;</span>
  <span class="kt">Just</span> <span class="n">ts</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;started token sale &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">ts</span>
</pre></div>
</div>
<p>We can now activate the endpoints for the three wallets. Recall that the <em>useEndpoints</em> function is parameterised by the <em>TokenSale</em> data, which is why we needed to
get that value.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
<span class="nf">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
<span class="nf">h3</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
</pre></div>
</div>
<p>Wallet 1 sets the price to 1 Ada and we again wait for a generous amount of time.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;set price&quot;</span> <span class="n">h1</span> <span class="mi">1_000_000</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Wallet 1 adds 100 tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;add tokens&quot;</span> <span class="n">h1</span> <span class="mi">100</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Wallet 2 buys 20 tokens. So now the contract should contain 80 tokens and 20 Ada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="n">h2</span> <span class="mi">20</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Wallet 3 buys 5 tokens. Now there should be 75 tokens in the contract and 25 Ada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="n">h3</span> <span class="mi">5</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Finally, Wallet 1 calls the withdraw endpoint, taking out 40 tokens and 10 Ada. At this point, there should be 35 tokens and 10 Ada in the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;withdraw&quot;</span> <span class="n">h1</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">10_000_000</span><span class="p">)</span>
<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">5</span>
</pre></div>
</div>
<p>Let’s run this in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">repl</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span>
<span class="n">Ok</span><span class="p">,</span> <span class="n">five</span> <span class="n">modules</span> <span class="n">loaded</span><span class="o">.</span>
<span class="n">Prelude</span> <span class="n">Main</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">l</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span>
<span class="n">Ok</span><span class="p">,</span> <span class="n">one</span> <span class="n">module</span> <span class="n">loaded</span><span class="o">.</span>
<span class="n">Prelude</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="n">runMyTrace</span>

<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">2125</span><span class="n">c8770581c6140c3c71276889f6353830744191de0184b6aa00b185004500</span>
<span class="n">Slot</span> <span class="mi">00000</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">1</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
</pre></div>
</div>
<p>The first endpoint call is to <em>start</em>. This creates three transaction. Two of these are from the forge contract to create the NFT, and the third one is to set up our
initial UTxO for the token sale.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;start&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;aa&quot;</span><span class="p">)]),</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;A&quot;</span><span class="p">)])])]))])</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">cccba8b2abc3e82a735735c2346aa3fcac58152f17854b1745306e5b63a0b965</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">cccba8b2abc3e82a735735c2346aa3fcac58152f17854b1745306e5b63a0b965</span>
<span class="n">Slot</span> <span class="mi">00001</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">2</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">e23e19192aea3304a989ab98f05e70bc01fe43f3ea940da78a92ab7cebec9bbb</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">e23e19192aea3304a989ab98f05e70bc01fe43f3ea940da78a92ab7cebec9bbb</span>
<span class="n">Slot</span> <span class="mi">00002</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">3</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">4</span><span class="n">cae1c5115eb4128243ce029dcd4d6c23d6497d3ab5e71a79f4dc34e9b8cd763</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">4</span><span class="n">cae1c5115eb4128243ce029dcd4d6c23d6497d3ab5e71a79f4dc34e9b8cd763</span>
<span class="n">Slot</span> <span class="mi">00003</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">4</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="o">***</span> <span class="n">CONTRACT</span> <span class="n">LOG</span><span class="p">:</span> <span class="s2">&quot;started token sale TokenSale {tsSeller = 21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9, tsToken = (aa,</span><span class="se">\&quot;</span><span class="s2">A</span><span class="se">\&quot;</span><span class="s2">), tsNFT = (65b4199f7d025bfb3b065b0fb88a77d694ffd849ff740b1a4cc453bfaab30f55,</span><span class="se">\&quot;</span><span class="s2">NFT</span><span class="se">\&quot;</span><span class="s2">)}&quot;</span>
<span class="n">Slot</span> <span class="mi">00004</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">5</span>
<span class="n">Slot</span> <span class="mi">00005</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">6</span>
</pre></div>
</div>
<p>We successfully read the <em>TokenSale</em> value from the observable state, and start the three contract instances for the use contract.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Sending</span> <span class="n">contract</span> <span class="n">state</span> <span class="n">to</span> <span class="n">Thread</span> <span class="mi">0</span>
<span class="n">Slot</span> <span class="mi">00006</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">7</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="o">***</span> <span class="n">USER</span> <span class="n">LOG</span><span class="p">:</span> <span class="n">started</span> <span class="n">token</span> <span class="n">sale</span> <span class="n">TokenSale</span> <span class="p">{</span><span class="n">tsSeller</span> <span class="o">=</span> <span class="mi">21</span><span class="n">fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9</span><span class="p">,</span> <span class="n">tsToken</span> <span class="o">=</span> <span class="p">(</span><span class="n">aa</span><span class="p">,</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">tsNFT</span> <span class="o">=</span> <span class="p">(</span><span class="mi">65</span><span class="n">b4199f7d025bfb3b065b0fb88a77d694ffd849ff740b1a4cc453bfaab30f55</span><span class="p">,</span><span class="s2">&quot;NFT&quot;</span><span class="p">)}</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000003</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
</pre></div>
</div>
<p>Then we set the price.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;set price&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1000000.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">2</span><span class="n">de6dd820e6939b4b1f9e162c0e2cc878cc38ea1231a9be610315da4eda06714</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">2</span><span class="n">de6dd820e6939b4b1f9e162c0e2cc878cc38ea1231a9be610315da4eda06714</span>
<span class="n">Slot</span> <span class="mi">00007</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">8</span>
<span class="n">Slot</span> <span class="mi">00008</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">9</span>
<span class="n">Slot</span> <span class="mi">00009</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">10</span>
<span class="n">Slot</span> <span class="mi">00010</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">11</span>
<span class="n">Slot</span> <span class="mi">00011</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">12</span>
</pre></div>
</div>
<p>Then add some tokens.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;add tokens&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">100.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">42</span><span class="n">f1bebe285d1ea23bd90683d110866bb438eede8ef62eaf5e9e3d65eec18e90</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">42</span><span class="n">f1bebe285d1ea23bd90683d110866bb438eede8ef62eaf5e9e3d65eec18e90</span>
<span class="n">Slot</span> <span class="mi">00012</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">13</span>
<span class="n">Slot</span> <span class="mi">00013</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">14</span>
<span class="n">Slot</span> <span class="mi">00014</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">15</span>
<span class="n">Slot</span> <span class="mi">00015</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">16</span>
<span class="n">Slot</span> <span class="mi">00016</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">17</span>
</pre></div>
</div>
<p>Then the two buys by Wallets 2 and 3.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000002</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;buy tokens&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">20.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">W2</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">30</span><span class="n">d28ca855a14accbb11deee682b174adffb548922e1d4257242880f28328f8e</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">30</span><span class="n">d28ca855a14accbb11deee682b174adffb548922e1d4257242880f28328f8e</span>
<span class="n">Slot</span> <span class="mi">00017</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">18</span>
<span class="n">Slot</span> <span class="mi">00018</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">19</span>
<span class="n">Slot</span> <span class="mi">00019</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">20</span>
<span class="n">Slot</span> <span class="mi">00020</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">21</span>
<span class="n">Slot</span> <span class="mi">00021</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">22</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000003</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">3</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;buy tokens&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Number</span> <span class="mf">5.0</span><span class="p">)]))])</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="n">W3</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="mi">708</span><span class="n">b0c4117ad3b38b69254a714e4695c574af404c3fff0eda859b571218b003c</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">708</span><span class="n">b0c4117ad3b38b69254a714e4695c574af404c3fff0eda859b571218b003c</span>
<span class="n">Slot</span> <span class="mi">00022</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">23</span>
<span class="n">Slot</span> <span class="mi">00023</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">24</span>
<span class="n">Slot</span> <span class="mi">00024</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">25</span>
<span class="n">Slot</span> <span class="mi">00025</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">26</span>
<span class="n">Slot</span> <span class="mi">00026</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">27</span>
</pre></div>
</div>
<p>And finally, the withdraw by Wallet 1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
  <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;withdraw&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[</span><span class="n">Number</span> <span class="mf">40.0</span><span class="p">,</span><span class="n">Number</span> <span class="mf">1.0e7</span><span class="p">])]))])</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
<span class="n">Slot</span> <span class="mi">00027</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">28</span>
<span class="n">Slot</span> <span class="mi">00028</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">29</span>
<span class="n">Slot</span> <span class="mi">00029</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">30</span>
<span class="n">Slot</span> <span class="mi">00030</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">31</span>
<span class="n">Slot</span> <span class="mi">00031</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">32</span>
<span class="n">Slot</span> <span class="mi">00032</span><span class="p">:</span> <span class="n">SlotAdd</span> <span class="n">Slot</span> <span class="mi">33</span>
</pre></div>
</div>
<p>All wallets initially owned 1000 tokens and 1000 Ada. Wallet 1 added 100 tokens to the contract, but then in the last step retrieved 40 tokens and 10 Ada,
and so we see its final balance as 940 tokens and 1010 Ada minus transaction fees.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Final</span> <span class="n">balances</span>
<span class="n">Wallet</span> <span class="mi">1</span><span class="p">:</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">940</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">1009942570</span>
</pre></div>
</div>
<p>Wallet 2 bought 20 tokens and paid 20 Ada for them, plus some transaction fees.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Wallet</span> <span class="mi">2</span><span class="p">:</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">1020</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">979985260</span>
</pre></div>
</div>
<p>Wallet 3 bought 5 tokens for 5 Ada.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Wallet</span> <span class="mi">3</span><span class="p">:</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">1005</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">994985211</span>
</pre></div>
</div>
<p>Finally, the script still contains the NFT, which will forever stay there, plus 35 tokens and 15 Ada. There were, at one point, 75 tokens and 25 Ada, before Wallet 1
made a withdrawal.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Script</span> <span class="n">fb3eca878d177b6d9264c7c36845fb1e28935553812ed2b56e39c9c4564b85ad</span><span class="p">:</span>
    <span class="p">{</span><span class="mi">65</span><span class="n">b4199f7d025bfb3b065b0fb88a77d694ffd849ff740b1a4cc453bfaab30f55</span><span class="p">,</span> <span class="s2">&quot;NFT&quot;</span><span class="p">}:</span> <span class="mi">1</span>
    <span class="p">{</span><span class="n">aa</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">}:</span> <span class="mi">35</span>
    <span class="p">{,</span> <span class="s2">&quot;&quot;</span><span class="p">}:</span> <span class="mi">15000000</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="unit-testing">
<h3><span class="section-number">1.8.2. </span>Unit Testing<a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h3>
<div class="section" id="tasty">
<h4><span class="section-number">1.8.2.1. </span>Tasty<a class="headerlink" href="#tasty" title="Permalink to this headline">¶</a></h4>
<p>You can find <em>tasty</em> on Hackage.</p>
<div class="figure align-default">
<img alt="_images/pic__000011.png" src="_images/pic__000011.png" />
</div>
<p>There is also some example code on the same page.</p>
<p>Basically you have a main program that references some <em>tests</em> of type <em>TestTree</em>. As the name suggests, this allows for a tree of tests,
where you can have sub groups and sub-sub groups and so on.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="n">defaultMain</span> <span class="n">tests</span>

<span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">testGroup</span> <span class="s">&quot;Tests&quot;</span> <span class="p">[</span><span class="n">properties</span><span class="p">,</span> <span class="n">unitTests</span><span class="p">]</span>
</pre></div>
</div>
<p>There is special support for tests in Plutus in the <em>plutus-contract</em> package in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Plutus.Contract.Test</span>
</pre></div>
</div>
<p>There are various types of tests that are supported, but here we will only look at two of those. One that works with emulator traces, and one which is much more
sophisticated and uses so-called property-based testing.</p>
<p>This module gives us functions for checking predicates, for example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkPredicate</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">TestTree</span>
</pre></div>
</div>
<p>Here we see the connection with Tasty. It takes, as arguments, the descriptive name of the test, then a <em>TracePredicate</em> which we will get to in a moment, and an
<em>EmulatorTrace</em> like the one we have used to test our contracts previously. And the result is a <em>TestTree</em> which, as we have seen, is the type of tests that Tasty
uses. So, using this <em>checkPredicate</em> function we can produce something that the Tasty framework can understand.</p>
<p>There’s also a variant with one additional argument of <em>CheckOptions</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkPredicateOptions</span> <span class="ow">::</span> <span class="kt">CheckOptions</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span> <span class="ow">-&gt;</span> <span class="kt">TestTree</span>
</pre></div>
</div>
<p><em>CheckOptions</em> has no constructors. This is a bit unfortunate, as we are forced to interact with it via three operations that take a type <em>Lens’</em>. <em>Lens’</em> is related to something called <em>optics</em> in Haskell. Optics is a huge topic
in itself, with whole books haven been written about it, so we will just touch on it for now and just learn how to use the emulator trace.</p>
<p>One of its operations is <em>emulatorConfig</em> which allows us to specify initial distributions of funds, in a way similar to that which we have done in previous testing examples.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">emulatorConfig</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="kt">CheckOptions</span> <span class="kt">EmulatorConfig</span>
</pre></div>
</div>
<p>Now let’s look at <em>TracePredicate</em>. This specifies some condition that the emulator trace should satisfy. This is what will be tested when we run the test.</p>
<p>First of all we see some logical combinators - a logical <em>not</em> and a logical <em>and</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">not</span> <span class="ow">::</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">.&amp;&amp;.</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<p>There are lots of functions for producing <em>TracePredicate</em>s. A few example are</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">endpointAvailable</span> <span class="ow">::</span> <span class="n">forall</span> <span class="p">(</span><span class="n">l</span> <span class="ow">::</span> <span class="kt">Symbol</span><span class="p">)</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span> <span class="kt">HasType</span> <span class="n">l</span> <span class="kt">Endpoints</span><span class="o">.</span><span class="kt">ActiveEndpoint</span> <span class="p">(</span><span class="kt">Output</span> <span class="n">s</span><span class="p">),</span> <span class="kt">KnownSymbol</span> <span class="n">l</span><span class="p">,</span> <span class="kt">ContractConstraints</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span> <span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceTag</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">queryingUtxoAt</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span> <span class="kt">UtxoAt</span><span class="o">.</span><span class="kt">HasUtxoAt</span> <span class="n">s</span><span class="p">,</span> <span class="kt">ContractConstraints</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span> <span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceTag</span> <span class="ow">-&gt;</span> <span class="kt">Address</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">assertDone</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span> <span class="kt">ContractConstraints</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Monoid</span> <span class="n">w</span> <span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceTag</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<p>For our example, we will only use one of the available checks, <em>walletFundsChange</em>, which checks funds.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- | Check that the funds in the wallet have changed by the given amount, exluding fees.</span>
<span class="nf">walletFundsChange</span> <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">TracePredicate</span>
</pre></div>
</div>
<p>The <em>walletFundsChange</em> creates a <em>TracePredicate</em> that checks whether the funds in a <em>Wallet</em> have changed by a given <em>Value</em>. Interestingly, here, fees are ignored.
We would have a hard time writing precise tests if this were not the case - we would find ourselves needing to approximate the costs of fees without knowing exactly what
they would be.</p>
<p>There is a variation <em>walletFundsExactChange</em>, which <em>does</em> take fees into account.</p>
<p>If we go back to our test module <em>Spec.Trace</em> there is a function that we have not looked at yet, <em>tests</em>, and it uses this <em>checkPredicateOptions</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">checkPredicateOptions</span>
    <span class="p">(</span><span class="n">defaultCheckOptions</span> <span class="o">&amp;</span> <span class="n">emulatorConfig</span> <span class="o">.~</span> <span class="n">emCfg</span><span class="p">)</span>
    <span class="s">&quot;token sale trace&quot;</span>
    <span class="p">(</span>     <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>   <span class="mi">10_000_000</span>  <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="p">(</span><span class="o">-</span><span class="mi">60</span><span class="p">))</span>
    <span class="o">.&amp;&amp;.</span> <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="o">-</span><span class="mi">20_000_000</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span>   <span class="mi">20</span><span class="p">)</span>
    <span class="o">.&amp;&amp;.</span> <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="o">-</span> <span class="mi">5_000_000</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span>    <span class="mi">5</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">myTrace</span>
</pre></div>
</div>
<p>The first argument, as we have seen is of type <em>CheckOptions</em>. This is where we have to use optics, but we won’t go into the details of that here. It is sufficient for now
to note that we use the same <em>EmulatorConfig</em> as we used for <em>runMyTrace</em>.</p>
<p>The second argument is the descriptive name of the trace.</p>
<p>For the third argument, we use the (.&amp;&amp;.) combinator to chain together three different trace predicates, each of which uses the <em>walletFundsChange</em> function we saw above. Here
we specify the changes that we expect to see in each of the wallets at the end of the trace - for example, we expect Wallet 1 to have gained 10 Ada and
lost 60 Tokens.</p>
<p>We can now run this in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="kn">import</span> <span class="nn">Test.Tasty</span>
<span class="n">Prelude</span> <span class="n">Test</span><span class="o">.</span><span class="n">Tasty</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="n">defaultMain</span> <span class="n">tests</span>
<span class="n">token</span> <span class="n">sale</span> <span class="n">trace</span><span class="p">:</span> <span class="n">OK</span> <span class="p">(</span><span class="mf">1.22</span><span class="n">s</span><span class="p">)</span>

<span class="n">All</span> <span class="mi">1</span> <span class="n">tests</span> <span class="n">passed</span> <span class="p">(</span><span class="mf">1.22</span><span class="n">s</span><span class="p">)</span>
<span class="o">***</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">ExitSuccess</span>
</pre></div>
</div>
<p>This passes. Let’s see what happens if it doesn’t pass. We can change one of the values.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span> <span class="n">walletFundsChange</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span>   <span class="mi">10_000_000</span>  <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Test</span><span class="o">.</span><span class="n">Tasty</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">l</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span>
<span class="p">[</span><span class="mi">1</span> <span class="n">of</span> <span class="mi">1</span><span class="p">]</span> <span class="n">Compiling</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span>       <span class="p">(</span> <span class="n">test</span><span class="o">/</span><span class="n">Spec</span><span class="o">/</span><span class="n">Trace</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">chris</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">ada</span><span class="o">/</span><span class="n">pioneer</span><span class="o">-</span><span class="n">fork</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">week08</span><span class="o">/</span><span class="n">dist</span><span class="o">-</span><span class="n">newstyle</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">/</span><span class="n">ghc</span><span class="o">-</span><span class="mf">8.10</span><span class="o">.</span><span class="mf">4.20210212</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="o">/</span><span class="n">t</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span><span class="o">-</span><span class="n">tmp</span><span class="o">/</span><span class="n">Spec</span><span class="o">/</span><span class="n">Trace</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="n">Ok</span><span class="p">,</span> <span class="n">one</span> <span class="n">module</span> <span class="n">loaded</span><span class="o">.</span>
<span class="n">Prelude</span> <span class="n">Test</span><span class="o">.</span><span class="n">Tasty</span> <span class="n">Spec</span><span class="o">.</span><span class="n">Trace</span><span class="o">&gt;</span> <span class="n">defaultMain</span> <span class="n">tests</span>
<span class="n">token</span> <span class="n">sale</span> <span class="n">trace</span><span class="p">:</span> <span class="n">FAIL</span> <span class="p">(</span><span class="mf">1.32</span><span class="n">s</span><span class="p">)</span>
  <span class="n">Expected</span> <span class="n">funds</span> <span class="n">of</span> <span class="n">W1</span> <span class="n">to</span> <span class="n">change</span> <span class="n">by</span>
    <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10000000</span><span class="p">)]),(</span><span class="n">aa</span><span class="p">,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">50</span><span class="p">)])])</span>
    <span class="p">(</span><span class="n">excluding</span> <span class="mi">57430</span> <span class="n">lovelace</span> <span class="ow">in</span> <span class="n">fees</span><span class="p">)</span>
  <span class="n">but</span> <span class="n">they</span> <span class="n">changed</span> <span class="n">by</span>
    <span class="n">Value</span> <span class="p">(</span><span class="n">Map</span> <span class="p">[(,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">10000000</span><span class="p">)]),(</span><span class="n">aa</span><span class="p">,</span><span class="n">Map</span> <span class="p">[(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">60</span><span class="p">)])])</span>
  <span class="n">Test</span> <span class="n">failed</span><span class="o">.</span>
  <span class="n">Emulator</span> <span class="n">log</span><span class="p">:</span>

  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">0</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="mi">2125</span><span class="n">c8770581c6140c3c71276889f6353830744191de0184b6aa00b185004500</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
                   <span class="n">Contract</span> <span class="n">instance</span> <span class="n">started</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="n">Contract</span> <span class="n">instance</span> <span class="k">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}:</span>
                   <span class="n">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="p">:</span> <span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;start&quot;</span><span class="p">),(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="n">Array</span> <span class="p">[</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;aa&quot;</span><span class="p">)]),</span><span class="n">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s2">&quot;unTokenName&quot;</span><span class="p">,</span><span class="n">String</span> <span class="s2">&quot;A&quot;</span><span class="p">)])])]))])</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">1</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">Balancing</span> <span class="n">an</span> <span class="n">unbalanced</span> <span class="n">transaction</span><span class="p">:</span>
  <span class="o">...</span>
  <span class="o">...</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">27</span><span class="p">:</span> <span class="n">W1</span><span class="p">:</span> <span class="n">TxSubmit</span><span class="p">:</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
  <span class="p">[</span><span class="n">INFO</span><span class="p">]</span> <span class="n">Slot</span> <span class="mi">27</span><span class="p">:</span> <span class="n">TxnValidate</span> <span class="n">a42a06cc3e3b1653ec4aba5ab8304484d778adcbddac2ceb9f639f7e4bd1dfd2</span>
    <span class="n">src</span><span class="o">/</span><span class="n">Plutus</span><span class="o">/</span><span class="n">Contract</span><span class="o">/</span><span class="n">Test</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">245</span><span class="p">:</span>
    <span class="n">token</span> <span class="n">sale</span> <span class="n">trace</span>

<span class="mi">1</span> <span class="n">out</span> <span class="n">of</span> <span class="mi">1</span> <span class="n">tests</span> <span class="n">failed</span> <span class="p">(</span><span class="mf">1.32</span><span class="n">s</span><span class="p">)</span>
<span class="o">***</span> <span class="ne">Exception</span><span class="p">:</span> <span class="n">ExitFailure</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We see a nice error message, followed by the emulator log, which we didn’t get when the tests passed.</p>
<p>This is probably the simplest way to write automated tests for Plutus contracts. You simply write one or more emulator traces, and then use <em>checkPredicate</em> in association
with the appropriate test predicates, to check that the trace leads to the desired result. This lets us write more or less traditional unit tests.</p>
</div>
</div>
<div class="section" id="optics-and-lenses">
<h3><span class="section-number">1.8.3. </span>Optics and Lenses<a class="headerlink" href="#optics-and-lenses" title="Permalink to this headline">¶</a></h3>
<p>Before we get to the second way of testing Plutus contracts, we will take a brief look at optics and lenses.</p>
<p>There are various competing optics libraries on Hackage, but the most prominent, and the most infamous one, and the one that the Plutus team decided to use is called <em>Lens</em>.</p>
<p><em>Lens</em> is authored by Edward Kmett, who is probably the most prolific contributor to Haskell libraries.</p>
<div class="figure align-default">
<img alt="_images/pic__000021.png" src="_images/pic__000021.png" />
</div>
<p>You can see on the Hackage page there is a scary diagram. There is a whole zoo of optics. There are lenses and prisms and traversals and isos and whatnot. This diagram
shows some of the operations that the library provides.</p>
<div class="figure align-default">
<img alt="_images/pic__00003.png" src="_images/pic__00003.png" />
</div>
<p>Optics are all about reaching deeply into hierarchical data types to inspect parts that are hidden deeply in the data type and to manipulate them.</p>
<p>Let’s look at a very simple example in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week08.Lens</span>
</pre></div>
</div>
<p>We have a type <em>Company</em> which is a wrapper around a list of <em>Person</em>. There is a field <em>_staff</em>. When dealing with lenses, it is convention to start field names with underscores.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Company</span> <span class="ow">=</span> <span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Person</span><span class="p">]}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">data</span> <span class="kt">Person</span>  <span class="ow">=</span> <span class="kt">Person</span>
    <span class="p">{</span> <span class="n">_name</span>    <span class="ow">::</span> <span class="kt">String</span>
    <span class="p">,</span> <span class="n">_address</span> <span class="ow">::</span> <span class="kt">Address</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">newtype</span> <span class="kt">Address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>And we define two <em>Person</em>s and a <em>Company</em> with which these <em>Person</em>s are associated.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">alejandro</span><span class="p">,</span> <span class="n">lars</span> <span class="ow">::</span> <span class="kt">Person</span>
<span class="nf">alejandro</span> <span class="ow">=</span> <span class="kt">Person</span>
  <span class="p">{</span>  <span class="n">_name</span>    <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span>
  <span class="p">,</span>  <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Zacateca&quot;</span><span class="p">}</span>
  <span class="p">}</span>
<span class="nf">lars</span> <span class="ow">=</span> <span class="kt">Person</span>
  <span class="p">{</span>  <span class="n">_name</span>    <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span>
  <span class="p">,</span>  <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Regensburg&quot;</span><span class="p">}</span>
  <span class="p">}</span>

<span class="nf">iohk</span> <span class="ow">::</span> <span class="kt">Company</span>
<span class="nf">iohk</span> <span class="ow">=</span> <span class="kt">Company</span> <span class="p">{</span> <span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="n">alejandro</span><span class="p">,</span> <span class="n">lars</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>The task is to write a simple function, <em>goTo</em>, that gets a <em>String</em> as argument along with a <em>Company</em>. The function should create a new company which it gets by
changing all the cities of all the staff of the company with the given string.</p>
<p>If we apply that to <em>iohk</em> with a string argument of “Athens*, then we should get a <em>Company</em> with the same two <em>Person</em>s, but now both of those <em>Person</em>s have
a city of “Athens”.</p>
<p>You don’t need any advanced Haskell to achieve this, but it’s a bit messy, even in this simple example. The function below uses record syntax to modify specific fields
of records, while leaving the other fields the same.</p>
<p>The helper function <em>movePerson</em> updates the <em>_address</em> field of the <em>Person</em> <em>p</em>, and the <em>_city</em> field of that <em>Address</em>, and the main part of the function maps the
<em>movePerson</em> function over each member of <em>_staff</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">goTo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Company</span> <span class="ow">-&gt;</span> <span class="kt">Company</span>
<span class="nf">goTo</span> <span class="n">there</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">c</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">movePerson</span> <span class="p">(</span><span class="n">_staff</span> <span class="n">c</span><span class="p">)}</span>
  <span class="kr">where</span>
    <span class="n">movePerson</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">p</span> <span class="p">{</span><span class="n">_address</span> <span class="ow">=</span> <span class="p">(</span><span class="n">_address</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="n">there</span><span class="p">}}</span>
</pre></div>
</div>
<p>We can look at the original company in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">iohk</span>
<span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Zacateca&quot;</span><span class="p">}},</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Regensburg&quot;</span><span class="p">}}]}</span>
</pre></div>
</div>
<p>Now, let’s apply the <em>goTo</em> function to it, and see the changes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">goTo</span> <span class="s">&quot;Athens&quot;</span> <span class="n">iohk</span>
<span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}},</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}}]}</span>
</pre></div>
</div>
<p>So, dealing with nested record types, even though it is quite simple conceptually, can be quite messy.</p>
<p>This is what optics try to make easier with the idea of providing first-class field accessors. In the end it’s very similar to dealing with such data types in an imperative
language such as C# or Java.</p>
<p>We saw in lecture four how monads can be viewed as a programmable semi-colon, where the semi-colon is the statement separator in many imperative languages. In a similar way, optics can be thought of as providing a programmable dot,
where a dot is the accessor dot as in Python or Java.</p>
<p>You could implement lenses by hand, but the <em>lens</em> library provides some Template Haskell magic to do it automatically, so long as we follow the underscore convention mentioned above.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">makeLenses</span> <span class="kt">&#39;&#39;Company</span>
<span class="nf">makeLenses</span> <span class="kt">&#39;&#39;Person</span>
<span class="nf">makeLenses</span> <span class="kt">&#39;&#39;Address</span>
</pre></div>
</div>
<p>The names of the lenses will be the names of the original fields without the underscore.</p>
<p>There is a way, within the REPL, to inspect what code Template Haskell writes at compile time.</p>
<p>First, enable the following flag</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="p">:</span><span class="nb">set</span> <span class="o">-</span><span class="n">ddump</span><span class="o">-</span><span class="n">splices</span>
</pre></div>
</div>
<p>Then, reload the module. If nothing happens, you’ll need to make a minor change to the code, perhaps by adding some whitespace, before reloading.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">r</span>
<span class="p">[</span><span class="mi">4</span> <span class="n">of</span> <span class="mi">4</span><span class="p">]</span> <span class="n">Compiling</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span>      <span class="p">(</span> <span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">chris</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">ada</span><span class="o">/</span><span class="n">pioneer</span><span class="o">-</span><span class="n">fork</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">week08</span><span class="o">/</span><span class="n">dist</span><span class="o">-</span><span class="n">newstyle</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">x86_64</span><span class="o">-</span><span class="n">linux</span><span class="o">/</span><span class="n">ghc</span><span class="o">-</span><span class="mf">8.10</span><span class="o">.</span><span class="mf">4.20210212</span><span class="o">/</span><span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">o</span> <span class="p">)</span>
<span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">35</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">20</span><span class="p">:</span> <span class="n">Splicing</span> <span class="n">declarations</span>
    <span class="n">makeLenses</span> <span class="s1">&#39;&#39;</span><span class="n">Company</span>
  <span class="o">======&gt;</span>
    <span class="n">staff</span> <span class="p">::</span> <span class="n">Iso</span><span class="s1">&#39; Company [Person]</span>
    <span class="n">staff</span> <span class="o">=</span> <span class="p">(</span><span class="n">iso</span> <span class="p">(</span>\ <span class="p">(</span><span class="n">Company</span> <span class="n">x_abBO</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x_abBO</span><span class="p">))</span> <span class="n">Company</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE staff #-}</span>
<span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">36</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">19</span><span class="p">:</span> <span class="n">Splicing</span> <span class="n">declarations</span>
    <span class="n">makeLenses</span> <span class="s1">&#39;&#39;</span><span class="n">Person</span>
  <span class="o">======&gt;</span>
    <span class="n">address</span> <span class="p">::</span> <span class="n">Lens</span><span class="s1">&#39; Person Address</span>
    <span class="n">address</span> <span class="n">f_abEJ</span> <span class="p">(</span><span class="n">Person</span> <span class="n">x1_abEK</span> <span class="n">x2_abEL</span><span class="p">)</span>
      <span class="o">=</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span>\ <span class="n">y1_abEM</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Person</span> <span class="n">x1_abEK</span><span class="p">)</span> <span class="n">y1_abEM</span><span class="p">))</span> <span class="p">(</span><span class="n">f_abEJ</span> <span class="n">x2_abEL</span><span class="p">)</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE address #-}</span>
    <span class="n">name</span> <span class="p">::</span> <span class="n">Lens</span><span class="s1">&#39; Person String</span>
    <span class="n">name</span> <span class="n">f_abEN</span> <span class="p">(</span><span class="n">Person</span> <span class="n">x1_abEO</span> <span class="n">x2_abEP</span><span class="p">)</span>
      <span class="o">=</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span>\ <span class="n">y1_abEQ</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Person</span> <span class="n">y1_abEQ</span><span class="p">)</span> <span class="n">x2_abEP</span><span class="p">))</span> <span class="p">(</span><span class="n">f_abEN</span> <span class="n">x1_abEO</span><span class="p">)</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE name #-}</span>
<span class="n">src</span><span class="o">/</span><span class="n">Week08</span><span class="o">/</span><span class="n">Lens</span><span class="o">.</span><span class="n">hs</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">1</span><span class="o">-</span><span class="mi">20</span><span class="p">:</span> <span class="n">Splicing</span> <span class="n">declarations</span>
    <span class="n">makeLenses</span> <span class="s1">&#39;&#39;</span><span class="n">Address</span>
  <span class="o">======&gt;</span>
    <span class="n">city</span> <span class="p">::</span> <span class="n">Iso</span><span class="s1">&#39; Address String</span>
    <span class="n">city</span> <span class="o">=</span> <span class="p">(</span><span class="n">iso</span> <span class="p">(</span>\ <span class="p">(</span><span class="n">Address</span> <span class="n">x_abFw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">x_abFw</span><span class="p">))</span> <span class="n">Address</span>
    <span class="p">{</span><span class="o">-</span><span class="c1"># INLINE city #-}</span>
</pre></div>
</div>
<p>This now shows us what Template Haskell does.</p>
<p>We see that <em>makeLenses</em> for <em>Company</em> creates a function <em>staff</em>, which returns an <em>Iso’</em> - a type of optic - from <em>Company</em> to <em>[Person]</em>.</p>
<p>For <em>makeLenses Person</em> we get an <em>address</em> function which returns a <em>Lens’</em> from <em>Person</em> to <em>Address</em>, and we also get a <em>name</em> lens from <em>Person</em> to <em>String</em>.</p>
<p>For <em>makeLenses Address</em> we get a <em>city</em> function which returns an <em>Iso’</em> from <em>Address</em> to <em>String</em>.</p>
<p><em>Iso</em> and <em>Lens</em> are two different types of optics but the order of type arguments is always the same.
You always have two type arguments, at least for these primed versions (there are more general optics which take four type parameters). The first argument is always the
big data type and the second parameter is the part you are zooming into. The name optics relates to the mental image of zooming into a datatype.</p>
<p>Let’s try them out in the REPL.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span>
<span class="n">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="o">=</span> <span class="n">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="o">=</span> <span class="s2">&quot;Regensburg&quot;</span><span class="p">}}</span>

<span class="n">Prelude</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="kn">import</span> <span class="nn">Control.Lens</span>

<span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">^.</span> <span class="n">name</span>
<span class="s2">&quot;Lars&quot;</span>

<span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">^.</span> <span class="n">address</span>
<span class="n">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="o">=</span> <span class="s2">&quot;Regensburg&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>A very powerful feature of lenses is that you can compose them.</p>
<p>Where we have, above, something going from <em>Person</em> to <em>Address</em> and we have something else going from <em>Address</em> to <em>String</em>, then we can combine them using the
function composition dot. There is some advanced type-level machinery going on behind the scenes to make that work, but it works.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">^.</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span>
<span class="s2">&quot;Regensburg&quot;</span>
</pre></div>
</div>
<p>Not only can you view the contents of record types like this, but you can also manipulate them.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Week08</span><span class="o">.</span><span class="n">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">&amp;</span> <span class="n">name</span> <span class="o">.~</span> <span class="s2">&quot;LARS&quot;</span>
<span class="n">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;LARS&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="o">=</span> <span class="n">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="o">=</span> <span class="s2">&quot;Regensburg&quot;</span><span class="p">}}</span>
</pre></div>
</div>
<p>The <em>&amp;</em> symbol here is function application, but the other way around - the argument comes first and then the function.</p>
<p>Again, we can compose.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">lars</span> <span class="o">&amp;</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span> <span class="o">.~</span> <span class="s">&quot;Munich&quot;</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Munich&quot;</span><span class="p">}}</span>
</pre></div>
</div>
<p>There is another type of optics called <em>Traversables</em>, that zooms not only into one field, but into many simultaneously. If you had a list it would zoom into each
element. So, for example, we could use a list of integers, with the <em>each</em> traversable that works with many container types, including lists, and set every element to 42.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">each</span> <span class="o">.~</span> <span class="mi">42</span>
<span class="p">[</span><span class="mi">42</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
</pre></div>
</div>
<p>You may see a <em>type-defaults</em> warning when you run the above, but it is removed here.</p>
<p>A cool thing is that various types of lenses can be combined, again with the dot operator. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">Lens</span><span class="o">&gt;</span> <span class="n">iohk</span> <span class="o">&amp;</span> <span class="n">staff</span> <span class="o">.</span> <span class="n">each</span> <span class="o">.</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span> <span class="o">.~</span> <span class="s">&quot;Athens&quot;</span>
<span class="kt">Company</span> <span class="p">{</span><span class="n">_staff</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Alejandro&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}},</span><span class="kt">Person</span> <span class="p">{</span><span class="n">_name</span> <span class="ow">=</span> <span class="s">&quot;Lars&quot;</span><span class="p">,</span> <span class="n">_address</span> <span class="ow">=</span> <span class="kt">Address</span> <span class="p">{</span><span class="n">_city</span> <span class="ow">=</span> <span class="s">&quot;Athens&quot;</span><span class="p">}}]}</span>
</pre></div>
</div>
<p>And this is exactly what our <em>goTo</em> function achieved, so we can write <em>goTo’</em> as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">goTo&#39;</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Company</span> <span class="ow">-&gt;</span> <span class="kt">Company</span>
<span class="nf">goTo&#39;</span> <span class="n">there</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">staff</span> <span class="o">.</span> <span class="n">each</span> <span class="o">.</span> <span class="n">address</span> <span class="o">.</span> <span class="n">city</span> <span class="o">.~</span> <span class="n">there</span>
</pre></div>
</div>
<p>And this is actually what we did when we configured our test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">checkPredicateOptions</span>
    <span class="p">(</span><span class="n">defaultCheckOptions</span> <span class="o">&amp;</span> <span class="n">emulatorConfig</span> <span class="o">.~</span> <span class="n">emCfg</span><span class="p">)</span>
</pre></div>
</div>
<p>The function <em>defaultCheckOptions</em> is of type <em>CheckOptions</em> and there is a lens from <em>CheckOptions</em> to <em>EmulatorConfig</em>, and this is the part that we wanted to change.</p>
<p>And that concludes our brief excursion into optics and lenses.</p>
</div>
<div class="section" id="property-based-testing">
<h3><span class="section-number">1.8.4. </span>Property Based Testing<a class="headerlink" href="#property-based-testing" title="Permalink to this headline">¶</a></h3>
<p>Property Based Testing is quite a revolutionary approach to testing that is much more powerful than simple unit testing. It originated from Haskell, which, with its
pureness and immutable data structures is particularly suited to this approach. It has now been copied by almost all other programming languages.</p>
<div class="section" id="quickcheck">
<h4><span class="section-number">1.8.4.1. </span>QuickCheck<a class="headerlink" href="#quickcheck" title="Permalink to this headline">¶</a></h4>
<p>One of the inventors of <em>QuickCheck</em>, which is the most prominent and was the first library using this approach, is John Hughes, who is also one of the original inventors
of Haskell. He and his company work with IOHK to provide special support of this approach to testing Plutus contracts.</p>
<p>Before we look at using QuickCheck for Plutus contracts, let’s first look at its use for pur Haskell programs.</p>
<p>Property based testing subsumes unit tests. Let’s write a very simple and silly unit test.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_simple</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">prop_simple</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>This function is available in the module.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week08.QuickCheck</span>
</pre></div>
</div>
<p>After loading this module, and the <em>Test.QuickCheck</em> module, we can test our unit test in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_simple</span>
<span class="o">+++</span> <span class="kt">OK</span><span class="p">,</span> <span class="n">passed</span> <span class="mi">1</span> <span class="n">test</span><span class="o">.</span>
</pre></div>
</div>
<p>This is not very exciting. For a more interesting example, the same module contains a buggy implementation of an insertion sort.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">sort</span> <span class="kt">[]</span>     <span class="ow">=</span>  <span class="kt">[]</span>
<span class="nf">sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>  <span class="n">insert</span> <span class="n">x</span> <span class="n">xs</span>

<span class="nf">insert</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="kt">[]</span>                     <span class="ow">=</span>  <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>       <span class="ow">=</span>  <span class="n">x</span> <span class="kt">:</span> <span class="n">ys</span>
                 <span class="o">|</span> <span class="n">otherwise</span>    <span class="ow">=</span>  <span class="n">y</span> <span class="kt">:</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>
</pre></div>
</div>
<p>To test it, a property that would could test would be that after applying sort to a list of integers, the resulting list is sorted.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isSorted</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isSorted</span> <span class="kt">[]</span>           <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isSorted</span> <span class="p">[</span><span class="kr">_</span><span class="p">]</span>          <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isSorted</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">isSorted</span> <span class="p">(</span><span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>Using this, we can now provide a QuickCheck property that is not just simply of type <em>Bool</em>, but instead is a function from a list of <em>Int</em>s to <em>Bool</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_sort_sorts</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">prop_sort_sorts</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">isSorted</span> <span class="o">$</span> <span class="n">sort</span> <span class="n">xs</span>
</pre></div>
</div>
<p>You can read that like a specification, which says “for all the lists of integers <em>xs</em>, if you apply <em>sort</em> to it, then the result should be sorted.”</p>
<p>QuickCheck can deal with such properties.</p>
<p>In the REPL</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_sort_sorts</span>
<span class="o">***</span> <span class="kt">Failed</span><span class="o">!</span> <span class="kt">Falsified</span> <span class="p">(</span><span class="n">after</span> <span class="mi">8</span> <span class="n">tests</span> <span class="n">and</span> <span class="mi">4</span> <span class="n">shrinks</span><span class="p">)</span><span class="kt">:</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>It fails, and gives us an example where the property does not hold. We can test that example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>And can see that, indeed, it is not correct.</p>
<p>How does QuickCheck do this? If you provide a function with one or more arguments, it will generate random arguments for the function. In our example, QuickCheck
has generated 100 random lists of integers and, for each of those lists, has checked whether the property holds, until it hit a failure.</p>
<p>Note that the failure was reported as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>*** Failed! Falsified (after 8 tests and 4 shrinks):
</pre></div>
</div>
<p>This means that after 8 tests the property was falsified, but at this point, rather than just report the failure, it has tried to shrink it - to simplify it.</p>
<p>This is a powerful feature of QuickCheck, because the random counter examples that QuickCheck finds are very complicated - long lists with long numbers. But once a counter
example has been found, QuickCheck tries to simplify it, perhaps by dropping some elements from the list, or by making some of the numbers smaller, until it doesn’t
find a way to get an even simpler example.</p>
<p>It is this combination of random test generation and shrinking that makes QuickCheck so tremendously useful.</p>
<p>We can see what type of random lists QuickCheck generates.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">(</span><span class="n">arbitrary</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
<span class="kt">[]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">14</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">17</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">19</span><span class="p">]</span>
</pre></div>
</div>
<p>The way QuickCheck does this random generation is by using a type class called <em>Arbitrary</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Prelude</span> <span class="n">Control</span><span class="o">.</span><span class="n">Lens</span> <span class="n">Test</span><span class="o">.</span><span class="n">QuickCheck</span> <span class="n">Week08</span><span class="o">.</span><span class="n">QuickCheck</span><span class="o">&gt;</span> <span class="p">:</span><span class="n">i</span> <span class="n">Arbitrary</span>
<span class="nb">type</span> <span class="n">Arbitrary</span> <span class="p">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="n">Constraint</span>
<span class="k">class</span> <span class="nc">Arbitrary</span> <span class="n">a</span> <span class="n">where</span>
  <span class="n">arbitrary</span> <span class="p">::</span> <span class="n">Gen</span> <span class="n">a</span>
  <span class="n">shrink</span> <span class="p">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>There are many more lines to the above output, but the important ones are shown. We can see that it has two methods. One is called <em>arbitrary</em> and one is called <em>shrink</em>.</p>
<p><em>Gen</em> is yet another monad. The monad provides various methods that allow for random number generation for values of type <em>a</em>.</p>
<p>The second method is <em>shrink</em>, which, when given an <em>a</em> will provide a list of simpler versions of <em>a</em>. This, of course, depends on the type of <em>a</em>.</p>
<p>If we look at the output above that provides some random integer lists, we see something interesting. The further we go down the list, the more complicated the list becomes. The
first is just the empty list, then we get single-element lists, then some longer lists, and it tends towards greater complexity over time.</p>
<p>In addition to just providing random generation in the <em>Gen</em> monad, there is also a concept of complexity. If you implement an instance of <em>Gen</em> you are expected not only
to generate a random <em>a</em> but also a random <em>a</em> of some given complexity.</p>
<p>When <em>QuickCheck</em> checks a property, it starts with simple, random arguments, then makes them more complex over time. By default it tests 100 random arguments, but this
can be configured.</p>
<p>Now that we know that our code fails, let’s try to fix it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">sort</span> <span class="kt">[]</span>     <span class="ow">=</span>  <span class="kt">[]</span>
<span class="nf">sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>  <span class="n">insert</span> <span class="n">x</span> <span class="n">xs</span>
</pre></div>
</div>
<p>The problem is that all we do for a non-empty list is to insert the first element into the tail, but we don’t recursively sort the tail.</p>
<p>Our first attempt to fix…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sort</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">sort</span> <span class="kt">[]</span>     <span class="ow">=</span>  <span class="kt">[]</span>
<span class="nf">sort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>  <span class="n">insert</span> <span class="n">x</span> <span class="o">$</span> <span class="n">sort</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Now, when we test this…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude Control.Lens Test.QuickCheck&gt; :r
[1 of 1] Compiling Week08.QuickCheck ( src/Week08/QuickCheck.hs, /home/chris/git/ada/pioneer-fork/code/week08/dist-newstyle/build/x86_64-linux/ghc-8.10.4.20210212/plutus-pioneer-program-week08-0.1.0.0/build/Week08/QuickCheck.o )
Ok, one module loaded.
Prelude Control.Lens Test.QuickCheck Week08.QuickCheck&gt; quickCheck prop_sort_sorts
+++ OK, passed 100 tests.
</pre></div>
</div>
<p>It passes. However, if we test specifically for the case that failed previously…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>It is clearly not correct. Even though the list has been sorted, the length of the list has changed. This leads to an important point. QuickCheck can’t do magic - its results are only
as good as the properties we provide. What we see here is that our property <em>prop_sort_sorts</em> is not strong enough to test if the function is correct.</p>
<p>We can add a second property that checks the length.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_sort_preserves_length</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">prop_sort_preserves_length</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">sort</span> <span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="n">length</span> <span class="n">xs</span>
</pre></div>
</div>
<p>And we find that this property is not satisfied by our code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_sort_preserves_length</span>
<span class="o">***</span> <span class="kt">Failed</span><span class="o">!</span> <span class="kt">Falsified</span> <span class="p">(</span><span class="n">after</span> <span class="mi">4</span> <span class="n">tests</span> <span class="n">and</span> <span class="mi">3</span> <span class="n">shrinks</span><span class="p">)</span><span class="kt">:</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The bug in our code is in the <em>insert</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="c1">-- not correct</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="kt">[]</span>                     <span class="ow">=</span>  <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>       <span class="ow">=</span>  <span class="n">x</span> <span class="kt">:</span> <span class="n">ys</span>
                 <span class="o">|</span> <span class="n">otherwise</span>    <span class="ow">=</span>  <span class="n">y</span> <span class="kt">:</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">ys</span>
</pre></div>
</div>
<p>We say here that, if <em>x</em> is less or equal to <em>y</em>, then we append <em>x</em> to <em>ys</em>, but we have forgotten about the <em>y</em>. It should read:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">insert</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span>       <span class="ow">=</span>  <span class="n">x</span> <span class="kt">:</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span>
</pre></div>
</div>
<p>This should fix it.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">r</span>
<span class="kt">Prelude</span> <span class="kt">Control</span><span class="o">.</span><span class="kt">Lens</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Week08</span><span class="o">.</span><span class="kt">QuickCheck</span><span class="o">&gt;</span> <span class="n">quickCheck</span> <span class="n">prop_sort_preserves_length</span>
<span class="o">+++</span> <span class="kt">OK</span><span class="p">,</span> <span class="n">passed</span> <span class="mi">100</span> <span class="n">tests</span><span class="o">.</span>
</pre></div>
</div>
<p>Of course, this is still not proof that our function is correct, because these two properties are still not enough to specify a sorting function fully. For example,
the sorting function could return a list of the same length containing only zeroes. This would pass all tests. It is quite an art to find properties to guarantee that,
if they are all satisfied, there is no bug.</p>
<p>Even so, this approach to testing is often more effective than unit testing as it can test a huge number of random cases and can find examples of
failure which a programmer writing a unit test may not have thought of.</p>
<p>Now that we have seen what QuickCheck can do, we will turn our attention to using it to test Plutus contracts.</p>
<p>Here we hit a problem - how do you use QuickCheck to test side-effected code? This problem does not only arise with blockchain, it arises with all systems
that use IO.</p>
<p>John Hughes always uses the example of the file system. How would you test file system operations, i.e. reading, writing, opening and closing files, using QuickCheck.</p>
<p>The approach to use is very similar to the one you can use with Plutus. The idea is that you start with a model.</p>
<div class="figure align-default">
<img alt="_images/pic__00004.png" src="_images/pic__00004.png" />
</div>
<p>The model is basically an idealised model of how the real world system should work. There must be some sort of relation between the model and the real system.</p>
<p>If the real system is a file system, then you could, in the model, have an idealised version of how you think files should work. And then, what QuickCheck does, in its
random generation, is to generate a random sequence of actions that you can perform on the system. In the example of a file system, it would randomly generate a
sequence of opening files, closing files, writing to files, reading files and so on. Now you can basically step this model and the system in parallel.</p>
<p>You have some sort of action that you perform in the real world, and you apply the same type of action to your model. Then your real system has progressed into a new state,
and your model has also been updated. After this step, you can compare the two and check that they are still in sync. You can then continue this for several steps.</p>
<div class="figure align-default">
<img alt="_images/pic__000091.png" src="_images/pic__000091.png" />
</div>
<p>While our first QuickCheck example generated a random list of <em>Int</em>s, the idea for testing a real world system is to generate random lists of actions and then to
apply those actions both to a model and to the real system and to check that the model and the real system stay in sync.</p>
<p>Shrinking in this example would be that, if you have a list of actions that show that there is a bug, then you can, for example, drop some of the actions and see
whether the problem still arises. This can be repeated until you cannot drop any further actions from the list and still reproduce the bug.</p>
<p>This is exactly how the QuickCheck support for Plutus works. In order to test a Plutus contract, we have to come up with a model and define our expectations of how
the various endpoints, for example, would change the model. We would then need to provide a link between the model and the real system (the emulator), and then apply the
QuickCheck machinery.</p>
<p>The code to do this is in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Spec.Model</span>
</pre></div>
</div>
<p>We notice that we import two Plutus test modules, with the QuickCheck support being provided by the <em>ContractModel</em>, which has all the machinery to define a model and to link
it to a real contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span>           <span class="nn">Plutus.Contract.Test</span>
<span class="kr">import</span>           <span class="nn">Plutus.Contract.Test.ContractModel</span>
</pre></div>
</div>
<p>And we import three more test modules. One for Tasty, one for QuickCheck, and one that allows for using QuickCheck properties in Tasty test suites.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span>           <span class="nn">Test.QuickCheck</span>
<span class="kr">import</span>           <span class="nn">Test.Tasty</span>
<span class="kr">import</span>           <span class="nn">Test.Tasty.QuickCheck</span>
</pre></div>
</div>
<p>To define a model, we first define a datatype that represents the state of one <em>TokenSale</em> instance.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TSState</span> <span class="ow">=</span> <span class="kt">TSState</span>
  <span class="p">{</span> <span class="n">_tssPrice</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
  <span class="p">,</span> <span class="n">_tssLovelace</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
  <span class="p">,</span> <span class="n">_tssToken</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>It has three fields - the current price, the current supply of lovelace in the contract, and the current supply of tokens in the contract.</p>
<p>Then our model <em>TSModel</em> is a map from wallets to <em>TokenSale</em> states.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">TSModel</span> <span class="ow">=</span> <span class="kt">TSModel</span> <span class="p">{</span><span class="n">_tsModel</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">TSState</span><span class="p">}</span>
<span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>The idea in this test is that we have two wallets and each wallet runs its own <em>TokenSale</em> contract, and the two wallets will trade different tokens.</p>
<p>We create lenses for the model. We need optics to interact with the <em>ContactModel</em> library.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">makeLenses</span> <span class="kt">&#39;&#39;TSModel</span>
</pre></div>
</div>
<p>All the logic that defines how our model should behave, and how it is linked to the real contract is in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">ContractModel</span> <span class="kt">TSModel</span> <span class="kr">where</span>
</pre></div>
</div>
<p>First we have an associated datatype. This is quite an advanced Haskell feature. In type classes, as well as methods, you can have data types. We have seen this
before in validators where we define a dummy type that provides a link between the datum type and the redeemer type.</p>
<p>Here, we associate an <em>Action</em> type, which represents the actions that QuickCheck will generate. In principal, we just have one constructor in the <em>Action</em> type for
each of the endpoints we saw earlier. We have additional arguments because now there are additional wallets at play and we must keep track of which wallet performs an
action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Action</span> <span class="kt">TSModel</span> <span class="ow">=</span>
    <span class="kt">Start</span> <span class="kt">Wallet</span>
  <span class="o">|</span> <span class="kt">SetPrice</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">AddTokens</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">Withdraw</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span> <span class="kt">Integer</span>
  <span class="o">|</span> <span class="kt">BuyTokens</span> <span class="kt">Wallet</span> <span class="kt">Wallet</span> <span class="kt">Integer</span>
<span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Start Wallet</em> means that this wallet starts the token sale contract.</p>
<p><em>SetPrice Wallet Wallet Integer</em> means that the second wallet sets the price for the token sale contract operated by the first wallet. We know from the contract logic that
this should only work if both the wallets are the same, because only the owner of the contract can set the price.</p>
<p><em>AddTokens</em> is very similar to <em>SetPrice</em>.</p>
<p>For <em>Withdraw</em>, the second wallet attempts to withdraw a certain number of lovelace and a certain number tokens (respectively) from the token sale run by the first wallet. Again, this should
fail if the two wallets are not the same.</p>
<p>In <em>BuyTokens</em>, the second wallet will try to buy a certain number of tokens from the token sale run by the first wallet.</p>
<p>So, the <em>Action</em> type is the first ingredient.</p>
<p>The second ingredient is another associated datatype. For each instance of a contract that we are running, we want a key that identifies the instance.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="n">w</span> <span class="n">s</span> <span class="n">e</span> <span class="kr">where</span>
  <span class="kt">StartKey</span> <span class="ow">::</span> <span class="kt">Wallet</span>           <span class="ow">-&gt;</span> <span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema&#39;</span> <span class="kt">Text</span>
  <span class="kt">UseKey</span>   <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="nb">()</span>               <span class="kt">TSUseSchema</span>    <span class="kt">Text</span>
</pre></div>
</div>
<p>This is a generalised, algebraic datatype (GADT), so it’s a little different to usual data declarations in Haskell. Instead of just providing the constructors, you provide the
constructors with a type signature.</p>
<p>In <em>ContractInstanceKey</em>, we have a constructor <em>StartKey</em> that takes a <em>Wallet</em> as an argument and then produces something of type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">ContractInstanceKey</span> <span class="kt">TSModel</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema&#39;</span> <span class="kt">Text</span>
</pre></div>
</div>
<p>The point of GADTs is that with normal datatypes, the type parameters are the same for all constructors, for example, <em>Action TSModel</em> has five constructors, but the type
is always <em>TSModel</em>. But with GADTs, we are able to provide a more generalised type parameter - in this case <em>TSModel w s e</em>.</p>
<p>We need this feature in this case because our contracts can have different type parameters.</p>
<p>There are two types of instances. Recall we have the <em>start</em> contract and the <em>use</em> contract, which have different type signatures.</p>
<p><em>StartKey</em> returns a type that consists of our model and then the parameters that come from the contract itself - the state type, the schema, and the error type. We used the primed
version of <em>TSStartSchema</em> - <em>TSStartSchema’</em> because we don’t want to create the NFT, we want to pass it in ourselves because it makes it easier to write the test if
we know what NFT we will be using in advance.</p>
<p>We also provide a key for the use contract which takes two <em>Wallet</em>s as parameters. The first is the one that owns the token sale that we are interacting with and the second
is the one that actually runs the contract. As for the type parameters, there is no state parameter, and it uses a different schema - <em>TSUseSchema</em>, but the error type is
the same.</p>
<p>Next we need to provide the <em>instanceTag</em> method which, given an instance key and a wallet, will provide a so-called contract instance tag. As we already know the
wallet that runs the instance, because that was one of the arguments to the instance key constructor we can ignore it as an argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">instanceTag</span> <span class="n">key</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">fromString</span> <span class="o">$</span> <span class="s">&quot;instance tag for: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">key</span>
</pre></div>
</div>
<p>The <em>instanceTag</em> function doesn’t have an accessible constructor, but it implements the <em>IsString</em> class. We haven’t seen the <em>IsString</em> class explicitly but we have
used it when we used the <em>OverloadedStrings</em> GHC extension - it allows a type class that implements it to be represented by a string literal. In particular, it has a
method <em>fromString</em> which, given a string, will create an instance of the type.</p>
<p>The “instance tag for: ” literal in the function above isn’t necessary - all that is necessary is for the whole string to be unique for each instance that we will
ever run in our tests.</p>
<p>There is a default implementation for the <em>instanceTag</em> method of the <em>ContractModel</em> class, so you normally don’t have to implement it yourself. However, it only
works if you have at most one contract instance per wallet. This is not the case for us, as we will have three instances per wallet - one <em>start</em> instance and two
<em>use</em> instances (one for the own wallet’s token sale, and one for the other wallet’s token sale).</p>
<p>The next method that we need to implement is <em>arbitraryAction</em> which is how we tell the system how to generate a random action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">arbitraryAction</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">oneof</span> <span class="o">$</span>
   <span class="p">(</span><span class="kt">Start</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span><span class="p">)</span> <span class="kt">:</span>
  <span class="p">[</span> <span class="kt">SetPrice</span>  <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>               <span class="o">++</span>
  <span class="p">[</span> <span class="kt">AddTokens</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>               <span class="o">++</span>
  <span class="p">[</span> <span class="kt">BuyTokens</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>               <span class="o">++</span>
  <span class="p">[</span> <span class="kt">Withdraw</span>  <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span> <span class="p">]</span>
</pre></div>
</div>
<p>As an argument it gets the model state. We will come to this later, but we don’t need it here and so ignore it in the method declaration.</p>
<p>The function <em>oneof</em> is one of the combinators provided by QuickCheck. Given a list of arbitrary actions, it randomly picks one of those.</p>
<p>Here we are using something else that we have not seen before - the applicative style. Recall that when we looked at monads, we saw that <em>Monad</em> has <em>Applicative</em> as
a superclass. <em>Applicative</em> is often useful to write more compact monadic code.</p>
<p>First let’s look at the <em>genWallet</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">genWallet</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="kt">Wallet</span>
<span class="nf">genWallet</span> <span class="ow">=</span> <span class="n">elements</span> <span class="n">wallets</span>
</pre></div>
</div>
<p>In the random generation monad <em>Gen</em>, it generates a random wallet. It uses another combinator provided by QuickCheck, <em>elements</em>, which simply takes a list of the type
that we wish to generate, and randomly picks one of those elements.</p>
<p>This is using another helper function <em>wallets</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">wallets</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Wallet</span><span class="p">]</span>
<span class="nf">wallets</span> <span class="ow">=</span> <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">]</span>
</pre></div>
</div>
<p>Which, in turn, uses</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="ow">::</span> <span class="kt">Wallet</span>
<span class="nf">w1</span> <span class="ow">=</span> <span class="kt">Wallet</span> <span class="mi">1</span>
<span class="nf">w2</span> <span class="ow">=</span> <span class="kt">Wallet</span> <span class="mi">2</span>
</pre></div>
</div>
<p>So <em>genWallet</em> will randomly pick either Wallet 1 or Wallet 2.</p>
<p>Getting back to the <em>arbitraryAction</em> code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Start</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span>
</pre></div>
</div>
<p>What this means is that we first use <em>genWallet</em> to generate a random wallet and then return <em>Action Start w</em>, where <em>w</em> is the wallet we have just picked.</p>
<p>The right-hand side is of type <em>Gen Wallet</em> and <em>Start</em> takes a <em>Wallet</em> and returns an action. If we <em>fmap</em> (&lt;$&gt;) this, we get a type of <em>Gen Wallet -&gt; Gen Action</em>, which
is what we want.</p>
<p>For the other four actions, we use an additional helper function <em>genNonNeg</em> which generates a nonnegative number.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">genNonNeg</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="kt">Integer</span>
<span class="nf">genNonNeg</span> <span class="ow">=</span> <span class="n">getNonNegative</span> <span class="o">&lt;$&gt;</span> <span class="n">arbitrary</span>
</pre></div>
</div>
<p>Now, when we want to generate a random action for <em>SetPrice</em>, this is where the applicative style really shines.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">SetPrice</span> <span class="o">&lt;$&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genWallet</span> <span class="o">&lt;*&gt;</span> <span class="n">genNonNeg</span>
</pre></div>
</div>
<p>If we wanted to write this in a <em>do</em> block, we would do something like</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">w1</span> <span class="ow">&lt;-</span> <span class="n">genWallet</span>
<span class="nf">w2</span> <span class="ow">&lt;-</span> <span class="n">genWallet</span>
<span class="nf">p</span>  <span class="ow">&lt;-</span> <span class="n">genNonNeg</span>
<span class="nf">return</span> <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">w1</span> <span class="n">w2</span> <span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>You can use the applicative style if the actions in the monad you are invoking don’t depend on the result of previous actions. In a <em>do</em> block, you could do inspect the
the result in <em>w1</em> and make some choice based upon it. This is not possible in <em>Applicative</em>, but often monadic code doesn’t make use of this power, and in these
situations, we have this more compact way of writing it.</p>
<p>We can try out the <em>arbitraryAction</em> function in the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">(</span><span class="n">arbitraryAction</span> <span class="n">undefined</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="p">(</span><span class="kt">Action</span> <span class="kt">TSModel</span><span class="p">))</span>
<span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">3</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">12</span>
<span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">14</span> <span class="mi">3</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">9</span>
<span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">18</span>
<span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">17</span>
</pre></div>
</div>
<p>We see that is generates a sample of random actions with random arguments.</p>
<p>The next method to implement is <em>initialState</em> which, as the name suggests, is the initial state of our model.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">initialState</span> <span class="ow">=</span> <span class="kt">TSModel</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
</pre></div>
</div>
<p>Now comes the most complex function that we must implement to set this up. You will recall from when we looked at the diagram that we
must know what effect performing and action will have on the model. This is exactly what the <em>nextState</em> function does.</p>
<p>If we look at the type of <em>nextState</em>, we see that it takes an action and returns something in yet another monad, this time the <em>Spec</em> monad. The <em>Spec</em> monad
allows us to inspect the current state of our model, and also to transfer funds within our model.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span> <span class="kt">Action</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Spec</span> <span class="n">state</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Let’s look an example for <em>Start</em>. This should tell us the effect on our model if wallet <em>w</em> starts a token sale.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">nfts</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
    <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">at</span> <span class="n">w</span><span class="p">)</span> <span class="o">$=</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">TSState</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Here we see a function from the Spec monad called <em>withdraw</em>. Using <em>withdraw</em> means that some funds go from a wallet to a contract - it doesn’t matter which contract. So,
this says that the effect of <em>Start</em> will be that Wallet <em>w</em> loses the NFT.</p>
<p>The NFT is again something that is defined in a helper function. Let’s quickly look at the helper functions that define the NFTs and tradable tokens.</p>
<p>Each wallet will trade its own token and each wallet will have its own NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tokenCurrencies</span><span class="p">,</span> <span class="n">nftCurrencies</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">CurrencySymbol</span>
<span class="nf">tokenCurrencies</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">[</span><span class="s">&quot;aa&quot;</span><span class="p">,</span> <span class="s">&quot;bb&quot;</span><span class="p">]</span>
<span class="nf">nftCurrencies</span>   <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">[</span><span class="s">&quot;01&quot;</span><span class="p">,</span> <span class="s">&quot;02&quot;</span><span class="p">]</span>

<span class="nf">tokenNames</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">TokenName</span>
<span class="nf">tokenNames</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="n">zip</span> <span class="n">wallets</span> <span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;B&quot;</span><span class="p">]</span>

<span class="nf">tokens</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">AssetClass</span>
<span class="nf">tokens</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">tokenCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">tokenNames</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">))</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>

<span class="nf">nftAssets</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">AssetClass</span>
<span class="nf">nftAssets</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">nftCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">nftName</span><span class="p">))</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>

<span class="nf">nfts</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">Value</span>
<span class="nf">nfts</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">nftAssets</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>
</pre></div>
</div>
<p>Wallet 1 will trade the A token and Wallet 2 will trade the B token. Wallet one will have the 01 NFT and Wallet two will have the 02 NFT.</p>
<p>While we are here, we can look at the <em>tss</em> helper which exists alongside the above helper functions and maps the wallets to their <em>TokenSale</em> parameters.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tss</span> <span class="ow">::</span> <span class="kt">Map</span> <span class="kt">Wallet</span> <span class="kt">TokenSale</span>
<span class="nf">tss</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
    <span class="p">[</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="kt">TokenSale</span> <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">=</span>  <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="n">w</span>
                    <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">=</span>  <span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
                    <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">=</span>  <span class="n">nftAssets</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
                    <span class="p">})</span>
    <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Now, back to the <em>nextState</em> function. The first line of the <em>do</em> block says that the effect of calling Start will be that the wallet will loses the NFT to the contract. Remember that the NFT is locked in the
contract when we start the token sale.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">nfts</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span>
    <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">at</span> <span class="n">w</span><span class="p">)</span> <span class="o">$=</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">TSState</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Secondly, there will be an effect on the model state. Remember that the model state is a map from <em>Wallet</em> to <em>TSState</em>, where <em>TSState</em> is a triple of price, tokens and Ada.</p>
<p>The second line of the <em>do</em> block says that after the contract has started, there will be an entry in the map at key <em>w</em> with 0 price, 0 tokens and 0 Ada.</p>
<p>The left hand side of the expression is another example of an optic, this time allowing us to access the map <em>_tsModel</em> from <em>TSModel</em>. The <em>at</em> lens allows us to
reference a map entry at a given key. The type returned by this optic is a <em>Maybe</em> as the key may or may not be there.</p>
<p>The $= comes from the Spec monad and it takes a lens on the left-hand side and then a new value on the right-hand side.</p>
<p>The <em>wait</em> function comes from the Spec monad and says here that the <em>Start</em> will take one slot.</p>
<p>Now we do something similar for all the other operations. Firstly, <em>SetPrice</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">v</span> <span class="n">w</span> <span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">when</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">w</span><span class="p">)</span> <span class="o">$</span>
      <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssPrice</span><span class="p">)</span> <span class="o">$=</span> <span class="n">p</span>
  <span class="n">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>In this function, we only do something if the wallet that invokes <em>SetPrice</em> is the same as the wallet that is running the token sale. If it is then the funds
don’t move, but we must update the model.</p>
<p>We use a different optic - instead of <em>at</em> we use <em>ix</em> which is a <em>Traversal</em>. It is similar to <em>at</em>, but whereas <em>at</em> returned a <em>Maybe</em>, <em>ix</em> does not. It also uses the <em>tssPrice</em> lens to access the first element of the <em>TSState</em> triple, which it sets to the price.
In the event that <em>ix</em> does not find an entry, the line will have no effect.</p>
<p>Whether or not the wallets match, and whether or not the price update succeeds, we wait one slot.</p>
<p>The model state change for <em>AddTokens</em> is more complex.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">started</span> <span class="ow">&lt;-</span> <span class="n">hasStarted</span> <span class="n">v</span>                                     <span class="c1">-- has the token sale started?</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>First we check the the token sale for wallet <em>v</em> has actually started, and this is yet another helper function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getTSState&#39;</span> <span class="ow">::</span> <span class="kt">ModelState</span> <span class="kt">TSModel</span> <span class="ow">-&gt;</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">TSState</span>
<span class="nf">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">s</span> <span class="o">^.</span> <span class="n">contractState</span> <span class="o">.</span> <span class="n">tsModel</span> <span class="o">.</span> <span class="n">at</span> <span class="n">v</span>
</pre></div>
</div>
<p>Given a <em>ModelState</em> (which is of type <em>TSModel</em> but with additional information such as current funds and current time) and given a <em>Wallet</em>, we want to extract the
<em>TSState</em> which is the state of the token sale contract for that wallet, which may or may not have started yet.</p>
<p>This is again performed using optics. There is a lens called <em>contractState</em> which, here is the <em>TSModel</em> type. We then zoom into the map and use the <em>at</em> lens, which
will return <em>Nothing</em> if the wallet key <em>v</em> does not exist, or a <em>Just TSState</em> if it is there.</p>
<p>Using this, we can write a slight variety of this function which doesn’t have the first argument. Instead it takes just the <em>Wallet</em> argument, but then returns the
<em>Maybe TSState</em> in the Spec monad. In order to do that, we use a feature of the Spec monad, a function called <em>getModelState</em>, which will return the model state, which
we then pass to the primed version of the function along with the <em>Wallet</em> argument.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getTSState</span> <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Spec</span> <span class="kt">TSModel</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">TSState</span><span class="p">)</span>
<span class="nf">getTSState</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="ow">&lt;-</span> <span class="n">getModelState</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
</pre></div>
</div>
<p>And then another variation, this time called <em>hasStarted</em>, which will tells us, within the Spec monad, whether the token sale has stared or not.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hasStarted</span> <span class="ow">::</span> <span class="kt">Wallet</span> <span class="ow">-&gt;</span> <span class="kt">Spec</span> <span class="kt">TSModel</span> <span class="kt">Bool</span>
<span class="nf">hasStarted</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">isJust</span> <span class="o">&lt;$&gt;</span> <span class="n">getTSState</span> <span class="n">v</span>
</pre></div>
</div>
<p>This just checks whether the return value from <em>getTSState v</em> is a <em>Just</em> or a <em>Nothing</em>. The <em>isJust</em> function returns True if it is a <em>Just</em>, and we need to use <em>fmap</em>
to lift it into the Spec monad.</p>
<p>Continuing the <em>nextState</em> function for <em>AddTokens</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">started</span> <span class="ow">&lt;-</span> <span class="n">hasStarted</span> <span class="n">v</span>
  <span class="n">when</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">started</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">bc</span> <span class="ow">&lt;-</span> <span class="n">askModelState</span> <span class="o">$</span> <span class="n">view</span> <span class="o">$</span> <span class="n">balanceChange</span> <span class="n">w</span>
</pre></div>
</div>
<p>If the token sale has not started, we don’t do anything because <em>AddTokens</em> shouldn’t have any effect in that case.</p>
<p>We also check that the number of tokens to be added is greater than zero. If not, again we do nothing. Otherwise, we continue.</p>
<p>We now see another function from the Spec monad called <em>askModelState</em>, which is similar to <em>getModelState</em> but it doesn’t return the complete model state but instead
takes a function and applies it to the the model state. The function <em>view</em> comes from the <em>lens</em> library and is just another name for the <em>^.</em> operator for viewing the
result of zooming into a lens.</p>
<p>And there is a <em>balanceChange w</em> lens which is a lens to the balance change of wallet <em>w</em>. The balance change refers to how much the funds of the wallet have changed
since the start of the simulation.</p>
<p>At this point we have the balance change bound to <em>bc</em>. The reason we are doing this is because we want to make sure that the wallet has enough funds to add the requested
number of tokens, which we now do. First we look up the token.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">token</span> <span class="ow">=</span> <span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span>
</pre></div>
</div>
<p>Then we check whether the wallet has enough of them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">when</span> <span class="p">(</span><span class="n">tokenAmt</span> <span class="o">+</span> <span class="n">assetClassValueOf</span> <span class="n">bc</span> <span class="n">token</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>  <span class="c1">-- does the wallet have the tokens to give?</span>
  <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="n">token</span> <span class="n">n</span>
  <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="n">n</span><span class="p">)</span>
<span class="nf">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The number in <em>tokenAmt</em> is the number of tokens the wallet had at the start, so by adding this to the balance change for the token, we get the number of tokens
currently in the wallet.</p>
<p>If we have enough tokens, then we withdraw the correct number of tokens from the wallet, and we update the model to show that the tokens should now be in the contract. Note that
instead of using $= to set the value, we use the $~ function which applies a function to a value.</p>
<p>Again, we wait one slot.</p>
<p>Next, we write a <em>nextState</em> function for <em>BuyTokens</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">BuyTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">when</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">getTSState</span> <span class="n">v</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="n">t</span>
            <span class="o">|</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssToken</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                <span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssPrice</span>
                    <span class="n">l</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n</span>
                <span class="n">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">lovelaceValueOf</span> <span class="n">l</span>
                <span class="n">deposit</span> <span class="n">w</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span><span class="p">)</span> <span class="n">n</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssLovelace</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="n">l</span><span class="p">)</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span>    <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span><span class="p">))</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>First we check the the number of tokens we are attempting to buy is positive.  If so, then we get the state of the token sale.</p>
<p>If the state is a <em>Just</em> then we know that the token sale has started.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">getTSState</span> <span class="n">v</span>
<span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="n">t</span>
</pre></div>
</div>
<p>If so, then we use optics to check that the number of tokens available in the contract is at least enough for us to buy what we are asking for.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">t</span> <span class="o">^.</span> <span class="n">tssToken</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
</pre></div>
</div>
<p>If we are still going, we then lookup the current price and calculate how much the requested number of tokens will cost.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssPrice</span>
<span class="nf">l</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n</span>
</pre></div>
</div>
<p>The effect should then be that our wallet loses that number of lovelace, and gains the tokens we buy. Here we see the <em>deposit</em> function for the first time. It is the opposite
of the <em>withdraw</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">withdraw</span> <span class="n">w</span> <span class="o">$</span> <span class="n">lovelaceValueOf</span> <span class="n">l</span>
<span class="nf">deposit</span> <span class="n">w</span> <span class="o">$</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span><span class="p">)</span> <span class="n">n</span>
</pre></div>
</div>
<p>Finally we update the model state by adding the lovelace and removing the bought tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssLovelace</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="n">l</span><span class="p">)</span>
<span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span>    <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>And we wait for one slot.</p>
<p>Finally, the <em>Withdraw</em> action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nextState</span> <span class="p">(</span><span class="kt">Withdraw</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="nf">when</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">w</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">getTSState</span> <span class="n">v</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="n">t</span>
            <span class="o">|</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssToken</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">^.</span> <span class="n">tssLovelace</span> <span class="o">&gt;=</span> <span class="n">l</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                <span class="n">deposit</span> <span class="n">w</span> <span class="o">$</span> <span class="n">lovelaceValueOf</span> <span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tokens</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span> <span class="n">n</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssLovelace</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">l</span><span class="p">))</span>
                <span class="p">(</span><span class="n">tsModel</span> <span class="o">.</span> <span class="n">ix</span> <span class="n">v</span> <span class="o">.</span> <span class="n">tssToken</span><span class="p">)</span> <span class="o">$~</span> <span class="p">(</span><span class="o">+</span> <span class="p">(</span><span class="o">-</span> <span class="n">n</span><span class="p">))</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">wait</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This is only possible if the wallet wanting to withdraw is the same as the wallet running the sale. We check this first, then get the contract state.</p>
<p>We check both that there are enough tokens for us to withdraw the tokens that we are requesting, and also that there are enough lovelace for us to withdraw the lovelace that
we are requesting. If this is satisfied, the effect is that we add the lovelace and the tokens to the wallet, and the model is updated to reflect the fact that the
tokens and the lovelace have been removed.</p>
<p>That completes the <em>nextState</em> function declarations.</p>
<p>Right now, the model is just a conceptual model that has nothing to do with the contracts we wrote earlier. The names are suggestive because they have same names as
we used in the redeemer, but there is no link yet between the model and the actual contracts.</p>
<p>The link is provided by yet another method in the <em>ContractModel</em> class that we have to implement, and that’s the <em>perform</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">perform</span>
  <span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span>
    <span class="kt">HandleFun</span> <span class="n">state</span>
    <span class="ow">-&gt;</span> <span class="kt">ModelState</span> <span class="n">state</span>
    <span class="ow">-&gt;</span> <span class="kt">Action</span> <span class="n">state</span>
    <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="kt">Emulator</span><span class="o">.</span><span class="kt">EmulatorTrace</span> <span class="nb">()</span>
</pre></div>
</div>
<p>It takes something called <em>HandleFun</em> and then it takes the <em>ModelState</em> and the <em>Action</em>.</p>
<p>The <em>HandleFun</em> parameter gives us access to the contract handles.</p>
<p>Let’s look at our implementation of this method. We don’t need access to the <em>ModelState</em> for this example.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">perform</span> <span class="n">h</span> <span class="kr">_</span> <span class="n">cmd</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">cmd</span> <span class="kr">of</span>
  <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span>          <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">StartKey</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">nftCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">tokenCurrencies</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">,</span> <span class="n">tokenNames</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">v</span> <span class="n">w</span> <span class="n">p</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;set price&quot;</span>  <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">p</span>                                                                    <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span>  <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;add tokens&quot;</span> <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">n</span>                                                                    <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">BuyTokens</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span><span class="p">)</span>  <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">n</span>                                                                    <span class="o">&gt;&gt;</span> <span class="n">delay</span> <span class="mi">1</span>
  <span class="p">(</span><span class="kt">Withdraw</span> <span class="n">v</span> <span class="n">w</span> <span class="n">n</span> <span class="n">l</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">callEndpoint</span> <span class="o">@</span><span class="s">&quot;withdraw&quot;</span>   <span class="p">(</span><span class="n">h</span> <span class="o">$</span> <span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we are linking actions to contract endpoints. Recall that we wrote functions that create keys that uniquely identify contracts. The functions were called <em>StartKey</em>
and <em>UseKey</em>.</p>
<p>The <em>StartKey</em> function takes one <em>Wallet</em> as an argument, and you can see that we give that argument here in the first line of the body of the function.
Then we apply the function <em>h</em> to it. The function <em>h</em> is the <em>HandleFun</em> parameter and it is the job of this function to get a handle to the contract instance associated with a given key.</p>
<p>We also pass in the parameters. So in the example of the start action, we pass in a pre-computed values for the NFT, the token currencies and the token names.
We will say later how the <em>instanceSpec</em> function links the <em>StartKey</em> to <em>startEndpoint’</em>, the primed version of the function, which takes those three parameters.</p>
<p>The <em>delay</em> function used in <em>perform</em> is another simple helper function to wait for a number of slots.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">delay</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">delay</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">.</span> <span class="n">waitNSlots</span> <span class="o">.</span> <span class="n">fromIntegral</span>
</pre></div>
</div>
<p>All the other actions are very similar, but note that they all use <em>UseKey</em> instead of <em>StartKey</em>.</p>
<p>Finally, the last method we must provide for the <em>ContractModel</em> instance is <em>precondition</em>. This allows us to define the conditions under which it is acceptable
to provide each action.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span> <span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span> <span class="kt">ModelState</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Action</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>The precondition for <em>Start</em> is that the token sale has not yet started. It says that, given a certain state <em>s</em> and the <em>Start w</em> action, check that the return value
of <em>getTSState’ s w</em> is <em>Nothing</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Start</span> <span class="n">w</span><span class="p">)</span>          <span class="ow">=</span> <span class="n">isNothing</span> <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">w</span>
</pre></div>
</div>
<p>And for the others, we do the opposite. They are only possible if the token sale has started.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">SetPrice</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span>   <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
<span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">AddTokens</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
<span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">BuyTokens</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
<span class="nf">precondition</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Withdraw</span> <span class="n">v</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">isJust</span>    <span class="o">$</span> <span class="n">getTSState&#39;</span> <span class="n">s</span> <span class="n">v</span>
</pre></div>
</div>
<p>One last thing, we must link the keys to actual contracts. We do this with the <em>instanceSpec</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">instanceSpec</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="kt">TSModel</span><span class="p">]</span>
<span class="nf">instanceSpec</span> <span class="ow">=</span>
    <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="p">(</span><span class="kt">StartKey</span> <span class="n">w</span><span class="p">)</span> <span class="n">w</span> <span class="n">startEndpoint&#39;</span> <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span> <span class="o">++</span>
    <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="p">(</span><span class="kt">UseKey</span> <span class="n">v</span> <span class="n">w</span><span class="p">)</span> <span class="n">w</span> <span class="o">$</span> <span class="n">useEndpoints</span> <span class="o">$</span> <span class="n">tss</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">v</span> <span class="o">|</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">,</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span><span class="p">]</span>
</pre></div>
</div>
<p>The <em>instanceSpec</em> function returns a list of <em>ContractInstanceSpec</em> types.</p>
<p>A <em>ContractInstanceSpec</em> takes three arguments - the first is the key, the second is the wallet, and the third is the contract that is supposed to be invoked.</p>
<p>For the start endpoint, we generate a <em>ContractInstanceSpec</em> for each wallet.</p>
<p>For the use endpoint, we generate a <em>ContractInstanceSpec</em> for all combinations of two wallets. Note also that the <em>useEndpoints</em> function takes an argument of type
<em>TokenSale</em>, so we need to get this from Wallet <em>v</em> and pass it in.</p>
<p>And finally (honestly), we can define a QuickCheck property.</p>
<p>There’s a function in Plutus.Contract.Test called <em>propRunActionsWithOptions</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">propRunActionsWithOptions</span>
<span class="ow">::</span> <span class="kt">ContractModel</span> <span class="n">state</span> <span class="ow">=&gt;</span>
   <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">CheckOptions</span>
   <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">ContractInstanceSpec</span> <span class="n">state</span><span class="p">]</span>
   <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">ModelState</span> <span class="n">state</span> <span class="ow">-&gt;</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">TracePredicate</span><span class="p">)</span>
   <span class="ow">-&gt;</span> <span class="kt">Actions</span> <span class="n">state</span>
   <span class="ow">-&gt;</span> <span class="kt">Property</span>
</pre></div>
</div>
<p>First it takes the <em>CheckOptions</em> type that we have seen before when we did emulator trace testing. Next it takes the list of <em>ContractInstanceSpec</em>s that we defined above.
Then it takes a function from <em>ModelState</em> to <em>TracePredicate</em>, which allows us to insert additional tests. And finally, it produces a function from a list of <em>Action</em>s to
<em>Property</em>. <em>Property</em> is like a beefed-up <em>Bool</em>, which has additional capabilities, mostly for logging and debugging.</p>
<p>We use this in the <em>prop_TS</em> function. For options we use the same as before which allows us to specify the initial coin distributions. We give each wallet 1,000 Ada, the
wallet’s NFT and 1,000 of both tokens, <em>A</em> and <em>B</em>.</p>
<p>For the second argument we provide the <em>instanceSpec</em> function. For the third argument, we don’t add any additional checks.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">prop_TS</span> <span class="ow">::</span> <span class="kt">Actions</span> <span class="kt">TSModel</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">prop_TS</span> <span class="ow">=</span> <span class="n">withMaxSuccess</span> <span class="mi">100</span> <span class="o">.</span> <span class="n">propRunActionsWithOptions</span>
    <span class="p">(</span><span class="n">defaultCheckOptions</span> <span class="o">&amp;</span> <span class="n">emulatorConfig</span> <span class="o">.~</span> <span class="kt">EmulatorConfig</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">instanceSpec</span>
    <span class="p">(</span><span class="n">const</span> <span class="o">$</span> <span class="n">pure</span> <span class="kt">True</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">d</span> <span class="ow">::</span> <span class="kt">InitialDistribution</span>
    <span class="n">d</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="o">$</span> <span class="p">[</span> <span class="p">(</span> <span class="n">w</span>
                         <span class="p">,</span> <span class="n">lovelaceValueOf</span> <span class="mi">1000_000_000</span> <span class="o">&lt;&gt;</span>
                           <span class="p">(</span><span class="n">nfts</span> <span class="kt">Map</span><span class="o">.!</span> <span class="n">w</span><span class="p">)</span>               <span class="o">&lt;&gt;</span>
                           <span class="n">mconcat</span> <span class="p">[</span><span class="n">assetClassValue</span> <span class="n">t</span> <span class="n">tokenAmt</span> <span class="o">|</span> <span class="n">t</span> <span class="ow">&lt;-</span> <span class="kt">Map</span><span class="o">.</span><span class="n">elems</span> <span class="n">tokens</span><span class="p">])</span>
                       <span class="o">|</span> <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">wallets</span>
                       <span class="p">]</span>
</pre></div>
</div>
<p>This results in a type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Actions</span> <span class="kt">TSModel</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
</pre></div>
</div>
<p>And this is something that QuickCheck can handle.</p>
<p>Let’s look at a sample of <em>Actions TSModel</em></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">(</span><span class="n">arbitrary</span> <span class="ow">::</span> <span class="kt">Gen</span> <span class="p">(</span><span class="kt">Actions</span> <span class="kt">TSModel</span><span class="p">))</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span> <span class="kt">[]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">8</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">1</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">7</span> <span class="mi">2</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">,</span>
  <span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">14</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">11</span> <span class="mi">7</span><span class="p">,</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">12</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">11</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">10</span> <span class="mi">6</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">13</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">8</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">6</span> <span class="mi">14</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">7</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">4</span><span class="p">,</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">10</span><span class="p">]</span>
<span class="kt">Actions</span>
 <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">),</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">14</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">20</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">15</span><span class="p">,</span>
  <span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">14</span> <span class="mi">1</span><span class="p">,</span>
  <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">4</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">21</span> <span class="mi">2</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">8</span><span class="p">,</span>
  <span class="kt">Withdraw</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">15</span> <span class="mi">17</span><span class="p">,</span>
  <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">,</span>
  <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>We notice here a similar pattern to before, where things start quite simply and get more complex as the list goes on.</p>
<p>So what will be tested? As we saw in the diagram back at the beginning, for all these randomly-generated action sequences, it will test that the properties we specified in the model -
how the funds flow - corresponds to what actually happens in the emulator. If there is a discrepancy, the test will fail.</p>
<p>Let’s use it!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">test</span>
<span class="p">(</span><span class="mi">21</span> <span class="n">tests</span><span class="p">)</span>
</pre></div>
</div>
<p>It takes quite a while.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Test</span><span class="o">.</span><span class="kt">QuickCheck</span> <span class="kt">Plutus</span><span class="o">.</span><span class="kt">Contract</span><span class="o">.</span><span class="kt">Test</span><span class="o">.</span><span class="kt">ContractModel</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">&gt;</span> <span class="n">test</span>
<span class="p">(</span><span class="mi">27</span> <span class="n">tests</span><span class="p">)</span>
</pre></div>
</div>
<p>But it will run 100 if you let it complete.</p>
<p>What might be more interesting would be to implement a bug in the code and see if these tests will find it.</p>
<p>In the <em>transition</em> function of our <em>TokenSale</em> code, let’s forget to check that only the seller can change the price.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TSRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="nf">transition</span> <span class="n">ts</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
    <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kt">SetPrice</span> <span class="n">p</span><span class="p">)</span>   <span class="o">|</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span> <span class="c1">-- Just ( Constraints.mustBeSignedBy (tsSeller ts)</span>
    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
      <span class="n">v</span> <span class="o">&lt;&gt;</span>
      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>We need to reload the code.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span>Prelude Test.QuickCheck Plutus.Contract.Test.ContractModel Spec.Model&gt; :l test/Spec/Model.hs
Ok, one module loaded.
Prelude Test.QuickCheck Plutus.Contract.Test.ContractModel Spec.Model&gt; test
*** Failed! Assertion failed (after 13 tests and 2 shrinks)...
</pre></div>
</div>
<p>You will see a whole bunch of output, but at the top, you will see clearly the action sequence that led to the bug.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Actions</span>
  <span class="p">[</span><span class="kt">Start</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">),</span>
   <span class="kt">SetPrice</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">12</span><span class="p">,</span>
   <span class="kt">AddTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">11</span><span class="p">,</span>
   <span class="kt">BuyTokens</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
<span class="kt">Expected</span> <span class="n">funds</span> <span class="kr">of</span> <span class="kt">W2</span> <span class="n">to</span> <span class="n">change</span> <span class="n">by</span>
   <span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(</span><span class="mi">02</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;NFT&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]),(</span><span class="n">bb</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">)])])</span>
   <span class="p">(</span><span class="n">excluding</span> <span class="mi">29466</span> <span class="n">lovelace</span> <span class="kr">in</span> <span class="n">fees</span><span class="p">)</span>
<span class="nf">but</span> <span class="n">they</span> <span class="n">changed</span> <span class="n">to</span>
   <span class="kt">Value</span> <span class="p">(</span><span class="kt">Map</span> <span class="p">[(,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">12</span><span class="p">)]),(</span><span class="mi">02</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;NFT&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]),(</span><span class="n">bb</span><span class="p">,</span><span class="kt">Map</span> <span class="p">[(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="o">-</span><span class="mi">10</span><span class="p">)])])</span>
<span class="kt">Test</span> <span class="n">failed</span><span class="o">.</span>
</pre></div>
</div>
<p>And we see that Wallet 1 has tried to set the price of the token sale that was started by Wallet 2. This should result in no change, because Wallet 1 is not allowed to
do this.</p>
<p>The model believes that the price should still be zero, but in the emulator the price has been set to 12.</p>
<p>Then Wallet 2 adds 11 tokens, and then buys 1 token from itself.</p>
<p>According to the model, the tokens should be free. The model expects that the wallet loses the NFT, that the wallet also loses 10 “B” because it gave 11 and then bought 1 back,
and that there is no change in Ada in the wallet, because the token price is zero.</p>
<p>But in the emulator, setting the price did have an effect, and so it reports that the wallet lost 12 lovelace.</p>
<p>So the discrepancy in the flow of funds has been found, and QuickCheck reports the error.</p>
<p>By default this is all the QuickCheck test do. It only checks the flow of funds, whether the emulator and the model agree at each point. It is, however, possible to
add additional checks. And it is also possible to influence the action sequences so that we can specify certain flows of actions to steer the tests in certain
directions. That is called Dynamic Logic, and that is yet another monad.</p>
<p>Even though this is very powerful, it also has its limitations. For one, it only tests the contracts that we provide. It doesn’t test all possible off-chain code. It is
possible that some party could write their own off-chain code that would allow them to steal funds from our contract, and this QuickCheck model can’t test for that.</p>
<p>The second problem is concurrency. We added this delay of one slot to each action to make sure that everything is nicely sequenced. Of course, in a real blockchain or
in an emulator, wallets can have concurrent submissions of transactions. In principle we could try to do that with this model as well, but then we would need to
somehow specify in the model what should happen in each case and that could get very complicated.</p>
<p>We should quickly look at how this integrates with Tasty.</p>
<p>There is a function in the Tasty library called <em>testProperty</em> that takes, as one its arguments, a QuickCheck property.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">testProperty</span> <span class="s">&quot;token sale model&quot;</span> <span class="n">prop_TS</span>
</pre></div>
</div>
<p>You will see an additional stanza in this week’s cabal file</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="o">-</span><span class="n">suite</span> <span class="n">plutus</span><span class="o">-</span><span class="n">pioneer</span><span class="o">-</span><span class="n">program</span><span class="o">-</span><span class="n">week08</span><span class="o">-</span><span class="n">tests</span>
<span class="nb">type</span><span class="p">:</span> <span class="n">exitcode</span><span class="o">-</span><span class="n">stdio</span><span class="o">-</span><span class="mf">1.0</span>
<span class="n">main</span><span class="o">-</span><span class="ow">is</span><span class="p">:</span> <span class="n">Spec</span><span class="o">.</span><span class="n">hs</span>
<span class="o">...</span>
</pre></div>
</div>
<p>And, if we look at the referenced Spec.hs</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">defaultMain</span> <span class="n">tests</span>

<span class="nf">tests</span> <span class="ow">::</span> <span class="kt">TestTree</span>
<span class="nf">tests</span> <span class="ow">=</span> <span class="n">testGroup</span> <span class="s">&quot;token sale&quot;</span>
    <span class="p">[</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Trace</span><span class="o">.</span><span class="n">tests</span>
    <span class="p">,</span> <span class="kt">Spec</span><span class="o">.</span><span class="kt">Model</span><span class="o">.</span><span class="n">tests</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>We can see that it specifies a list of test modules. And these can be run from the command line with the following command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cabal</span> <span class="n">test</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="week-09-marlowe">
<h2><span class="section-number">1.9. </span>Week 09 - Marlowe<a class="headerlink" href="#week-09-marlowe" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://youtu.be/-RpCqHuxfQQ">Lecture
#9</a>.</p>
<p>In this lecture we cover Marlowe - a special-purpose language for financial contracts on Cardano.</p>
</div>
<div class="section" id="id26">
<h3><span class="section-number">1.9.1. </span>Overview<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>In the previous lectures we have learnt about all the important ingredients for writing a Plutus application.</p>
<p>We have first looked at the extended UTxO model - the accounting model that Cardano uses - and the additions that Plutus brings to it.</p>
<p>Then we have talked about on-chain validation, minting policies, writing off-chain code, we have seen how to deploy smart contracts and also how to test them.</p>
<p>Plutus is a very powerful language. So powerful, in fact, that you can implement other languages on top of it - you can write an interpreter in Plutus for other languages.</p>
<p>One such language is Marlowe. Marlowe is a Domain Specific Language (DSL) for smart contracts.</p>
<p>For this lecture, Professor Simon Thompson, a very prominent figure in the Haskell community who leads the Marlowe team, and his colleague Alex Nemish will give guest lectures to tell us a bit about Marlowe.</p>
<p>Afterwards we will look at the <a class="reference external" href="https://play.marlowe-finance.io/">Marlowe playground</a> and play with a simple smart contract.</p>
</div>
<div class="section" id="lecture-by-prof-simon-thompson">
<h3><span class="section-number">1.9.2. </span>Lecture by Prof. Simon Thompson<a class="headerlink" href="#lecture-by-prof-simon-thompson" title="Permalink to this headline">¶</a></h3>
<p>Marlowe is a special-purpose language for writing financial contracts on Cardano.</p>
<div class="figure align-default">
<img alt="_images/pic__000051.png" src="_images/pic__000051.png" />
</div>
<div class="section" id="why-do-we-build-dsls">
<h4><span class="section-number">1.9.2.1. </span>Why do we build DSLs?<a class="headerlink" href="#why-do-we-build-dsls" title="Permalink to this headline">¶</a></h4>
<p>One reason is that we want to build languages that are closer to the language of the user and not so much the language of the system. They are
designed to be in the specific domain of the application. A financial language will talk about payments, for example.</p>
<p>When we write a DSL, we get some advantages. We can write down things in that domain, but we can’t perhaps write as much as we could in a general purpose language. And,
if we do work in this more specialised context, we have the advantage of being able to give people better feedback and better error messages. We can also give more
guarantees on program behaviour. That’s one of the things that will be stressed in this lecture.</p>
<div class="figure align-default">
<img alt="_images/pic__000061.png" src="_images/pic__000061.png" />
</div>
</div>
<div class="section" id="what-kind-of-assurance-can-we-give">
<h4><span class="section-number">1.9.2.2. </span>What kind of assurance can we give?<a class="headerlink" href="#what-kind-of-assurance-can-we-give" title="Permalink to this headline">¶</a></h4>
<p>We can give two kinds of assurance. We can make sure that contracts do what they are supposed to do, but we can also make sure that they don’t do what they shouldn’t. We
will see both aspects of that as we go along.</p>
<p>We’ve designed the language to be a simple as possible and the implementation reflects that, and we’ll talk a bit about that later on. Contracts are nice and readable, and also
we can easily simulate them, so we can present to users a very clear picture of how their contract in Marlowe will behave.</p>
<p>In fact, we can do more than that. Because they are particularly restricted, we can explore every possible behavior path that a contract can take, before it is executed. So, we
can give complete guarantees about how a contract will behave, not just on one or two tests, but on every possibly execution sequence.</p>
<p>It’s also more straightforward to write mathematical proofs of various kinds of safety, so that is the strongest criteria that we can hit in this kind of world; a mathematical
proof that the system will do certain things and won’t do others.</p>
</div>
<div class="section" id="what-does-a-financial-contract-do">
<h4><span class="section-number">1.9.2.3. </span>What does a financial contract do?<a class="headerlink" href="#what-does-a-financial-contract-do" title="Permalink to this headline">¶</a></h4>
<p>Let’s start by looking at what a financial contract can do.</p>
<p>A contract can accept payments from participants in the contract.</p>
<p>Depending on choices made by one the participants, it can evolve in different directions.</p>
<div class="figure align-default">
<img alt="_images/pic__000111.png" src="_images/pic__000111.png" />
</div>
<p>It can make decisions based on external information such as the information coming from a stock exchange. So, information coming from an oracle can determine the future behaviour
of a contract.</p>
<p>A contract can also make payments out. If money has been deposited in the contract, that money can be deposited out to participants.</p>
<p>So we have flows of money and choices according to external factors.</p>
<p>One final thing that we have is that the roles in a contract are things that themselves can be owned. We represent that in Marlowe by minting tokens that
represent those roles. That means that we can use those tokens as evidence that somebody is meant to be playing a role. They are a form of security that a person
submitting a transaction is allowed to submit that transaction, but also it means that these roles are tradable. A role could be traded by another person or another contract.</p>
</div>
<div class="section" id="language-design">
<h4><span class="section-number">1.9.2.4. </span>Language design<a class="headerlink" href="#language-design" title="Permalink to this headline">¶</a></h4>
<p>Now let’s think about how to design a language based on these ingredients.</p>
<div class="figure align-default">
<img alt="_images/pic__000121.png" src="_images/pic__000121.png" />
</div>
<p>When we design a language of contracts, what we are really doing is designing a programming language. A smart contract is just a program running on a blockchain.</p>
<p>A contract could, in principle, run forever. And also, more subtly, it could get stuck waiting for an input forever.</p>
<p>It could terminate while holding assets, locking them up forever.</p>
<p>So there’s a whole lot of security issues that a program might have.</p>
<p>What we chose to do was to design for safety.</p>
<p>Firstly, contracts are designed to be finite. Their life will be finite, there is no recursion or looping in Marlowe. We will come back to that a bit later on when
we talk about Marlowe being embedded in other languages.</p>
<p>We can be sure that contracts will terminate. We do that by putting timeouts on every external action. Every choice, every deposit of money into the contract comes with
a deadline. Marlowe contracts cannot wait forever for somebody to make a choice or for an action to happen. If you hit the timeout then an alternative course is taken.</p>
<p>We’ve designed the semantics of the language so that when a contract reaches its close, at the end of its lifetime, any money left in the contract will be
refunded to participants.</p>
<p>Conservation of value is something that we get for free from the underlying blockchain. The blockchain guarantees that we can’t double spend and because we are using
the transaction mechanisms of the underlying blockchain, we can be sure that we are getting conservation of value.</p>
<p>So this is giving us a lot of guarantees out of the box. These are not guarantees that you get from Plutus contracts in general. A Plutus contract could go on forever,
it need not terminate and it could terminate while holding a whole collection of assets which then become unreachable.</p>
</div>
<div class="section" id="the-marlowe-language">
<h4><span class="section-number">1.9.2.5. </span>The Marlowe Language<a class="headerlink" href="#the-marlowe-language" title="Permalink to this headline">¶</a></h4>
<p>So what does the language look like? Let’s cut to the chase.</p>
<div class="figure align-default">
<img alt="_images/pic__000131.png" src="_images/pic__000131.png" />
</div>
<p>Marlowe, at heart, is represented as a Haskell datatype.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Contract</span> <span class="ow">=</span> <span class="kt">Close</span>
<span class="o">|</span> <span class="kt">Pay</span> <span class="kt">Party</span> <span class="kt">Payee</span> <span class="kt">Value</span> <span class="kt">Contract</span>
<span class="o">|</span> <span class="kt">If</span> <span class="kt">Observation</span> <span class="kt">Contract</span> <span class="kt">Contract</span>
<span class="o">|</span> <span class="kt">When</span> <span class="p">[</span><span class="kt">Case</span> <span class="kt">Action</span> <span class="kt">Contract</span><span class="p">]</span> <span class="kt">Timeout</span> <span class="kt">Contract</span>
<span class="o">|</span> <span class="kt">Let</span> <span class="kt">ValueId</span> <span class="kt">Value</span> <span class="kt">Contract</span>
<span class="o">|</span> <span class="kt">Assert</span> <span class="kt">Observation</span> <span class="kt">Contract</span>
<span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Ord</span><span class="p">,</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Read</span><span class="p">,</span><span class="kt">Generic</span><span class="p">,</span><span class="kt">Pretty</span><span class="p">)</span>
</pre></div>
</div>
<p>We have a <em>Pay</em> construct. In that a <em>Party</em> in the contract makes a payment to a <em>Payee</em> of a particular <em>Value</em>, and then the contract continues with what we call the
continuation contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Pay</span> <span class="kt">Party</span> <span class="kt">Payee</span> <span class="kt">Value</span> <span class="kt">Contract</span>
</pre></div>
</div>
<p>We can go in two separate directions. We can observe <em>If</em> a particular <em>Observation</em> is true or not. If the observation is true we follow the first <em>Contract</em>, if it is
false we follow the second <em>Contract</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">If</span> <span class="kt">Observation</span> <span class="kt">Contract</span> <span class="kt">Contract</span>
</pre></div>
</div>
<p>The most complex construct in Marlowe is the <em>When</em> construct. It takes three arguments. The first of those is a list of <em>Contract</em>/<em>Action</em> pairs - a list of <em>Case</em>s.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">When</span> <span class="p">[</span><span class="kt">Case</span> <span class="kt">Action</span> <span class="kt">Contract</span><span class="p">]</span> <span class="kt">Timeout</span> <span class="kt">Contract</span>
</pre></div>
</div>
<p>What the <em>When</em> construct does is wait for one of a number of <em>Action</em>s. When one of those <em>Action</em>s happens, it performs the corresponding <em>Contract</em>. For example, it
could be waiting for a deposit. If we have a case where the first part of the pair is a deposit, then we execute the corresponding second part of the pair. Similarly with
making a choice or with getting a value from an oracle.</p>
<p>Here we are waiting for external actions and, of course, the contract can’t make those actions happen. A contract can’t force somebody to make a choice. It can’t force
somebody to make a deposit. But what we can do is say that if none of these actions takes place then we will hit the <em>Timeout</em>, and when we hit the <em>Timeout</em>, we will perform
the <em>Contract</em> represented by the final argument to the <em>When</em> construct.</p>
<p>So, we can guarantee that something will happen in the <em>When</em> construct, either by one of the actions triggering a successive contract, or we hit the timeout and go to that
continuation.</p>
<p>Finally we have the <em>Close</em> construct which has the semantics defined so that nothing is retained when we close.</p>
<p>That is the Marlowe language, and we will see that we can use these to construct Marlowe contracts in a variety of ways.</p>
</div>
<div class="section" id="the-marlowe-product">
<h4><span class="section-number">1.9.2.6. </span>The Marlowe Product<a class="headerlink" href="#the-marlowe-product" title="Permalink to this headline">¶</a></h4>
<p>So that is the language. What is the Marlowe product itself?</p>
<p>We have a suite of things. First we’ll look at the overall vision for Marlowe and then look at where we are in terms of fulfilling that vision.</p>
<div class="figure align-default">
<img alt="_images/pic__000201.png" src="_images/pic__000201.png" />
</div>
<p>We have a prototype for Marlowe Run. That is the system through which an end user will interact with contracts running on the Cardano blockchain. You can think of Marlowe
Run as the Marlowe dApp. It’s the things that allows Marlowe contracts to be executed.</p>
<p>We’re also building a market where contracts can be uploaded, downloaded, and where we can provide various kinds of assurance about those contracts.</p>
<p>We allow contracts to be simulated interactively and we call that Marlowe Play. We allow contracts to be built in various different ways and we call that Marlowe Build. In
fact fact what we’ve done at the moment is bundle those two - Marlowe Play and Build - into what we call the Marlowe Playground.</p>
<p>So as things stand at the moment you can use the Marlowe Playground to simulate and construct Marlowe contracts we’re in the process of redesigning the user experience
based on what we’ve done with Marlowe Run.</p>
<p>What we’re releasing very shortly is the prototype of Marlowe Run and this is the prototype of how end users will interact with Marlowe on the blockchain. Our
intention is that we’ll have all these products available running on the Cardano blockchain when we have the full support for this which will involve having the
Plutus Application Backend and the wallet back end and so on working as they should.</p>
</div>
<div class="section" id="demonstration">
<h4><span class="section-number">1.9.2.7. </span>Demonstration<a class="headerlink" href="#demonstration" title="Permalink to this headline">¶</a></h4>
<p>We’ll now look at a demo of what we have in Marlowe Run to give you a sense of what we can do at the moment in terms of giving users the
experience that they will have when Marlowe is running on blockchain. This will be the app that is going to provide that experience.</p>
<p>At the moment it’s running locally but in a few weeks’ time we will be releasing a version that runs in a distributed fashion on the simulated blockchain.
Then, as we go into the end of the year we expect to have it running for real on the Cardano blockchain itself.</p>
<p>You can find the Marlowe Playground at</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">staging</span><span class="o">.</span><span class="n">marlowe</span><span class="o">-</span><span class="n">dash</span><span class="o">.</span><span class="n">iohkdev</span><span class="o">.</span><span class="n">io</span><span class="o">/</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="_images/pic__00023.png" src="_images/pic__00023.png" />
</div>
<p>Marlowe run runs in the browser and what it does is provide the end user interaction with contracts running on the blockchain.</p>
<p>For the moment we’re simulating that blockchain inside the browser but eventually this will be the tool you’ll use to run contracts for real on Cardano.</p>
<p>To interact with the contract your wallet needs to be involved to control your your signature and to control your assets, so we link up Marlowe to run with
a wallet. Let’s link it up with Shruti’s wallet. You can do this by creating a demo wallet, or by selecting an existing wallet.</p>
<div class="figure align-default">
<img alt="_images/pic__000241.png" src="_images/pic__000241.png" />
</div>
<p>In this window we see the world from Shruti’s perspective. Let’s open up another window and link that window to the world from Charles’s perspective.</p>
<div class="figure align-default">
<img alt="_images/pic__000281.png" src="_images/pic__000281.png" />
</div>
<p>At the moment neither of them has any contracts running. They have a blank space, but let’s start a contract up. Let’s set up a zero coupon bond which is a fancy name
for a loan. You can do this by clicking <em>Create</em> and selecting the <em>Zero Coupon Bond</em> option.</p>
<p>Let’s suppose that Shruti is making a loan to Charles. She’s the investor he’s the issuer of the bond.</p>
<div class="figure align-default">
<img alt="_images/pic__000341.png" src="_images/pic__000341.png" />
</div>
<p>Charles wants to borrow one Ada from Shruti and he’s promised to pay back 1.1 Ada. So we’ve said who the issuer and investor are we said what the price and
the eventual value will be and we’re now going to create the contract. In order to do that we have to make a payment of 30 lovelace to get the contract started.</p>
<div class="figure align-default">
<img alt="_images/pic__000351.png" src="_images/pic__000351.png" />
</div>
<p>So let’s pay. We are asked to approve and the payment goes through. You can see now in Shruti’s Marlowe Run we’ve got the Zero Coupon Bond running, but also,
if you look at Charles’s view of the world, it’s running there too for him.</p>
<div class="figure align-default">
<img alt="_images/pic__000371.png" src="_images/pic__000371.png" />
</div>
<p>We’re at the first step. If we click through on Charles’s contract, it’s saying that it’s waiting for something from the investor, who is Shruti.</p>
<div class="figure align-default">
<img alt="_images/pic__00038.png" src="_images/pic__00038.png" />
</div>
<p>So let’s see what’s happening in her view.</p>
<div class="figure align-default">
<img alt="_images/pic__00039.png" src="_images/pic__00039.png" />
</div>
<p>She’s being asked to make a deposit so let’s click on that to make the deposit.</p>
<div class="figure align-default">
<img alt="_images/pic__00040.png" src="_images/pic__00040.png" />
</div>
<p>And click to confirm with a fee of 10 lovelace.</p>
<p>Then you can see her view has changed now she’s waiting for the issuer to pay her back.</p>
<p>We look in Charles’s view, which is incidentally the mobile view, of Marlowe Run, and he’s asked to pay his 1 Ada.</p>
<div class="figure align-default">
<img alt="_images/pic__00041.png" src="_images/pic__00041.png" />
</div>
<p>Let’s make him do that now. He’ll also have to pay a 10 lovelace transaction fee.</p>
<div class="figure align-default">
<img alt="_images/pic__000431.png" src="_images/pic__000431.png" />
</div>
<p>Let’s make that deposit.</p>
<div class="figure align-default">
<img alt="_images/pic__00045.png" src="_images/pic__00045.png" />
</div>
<p>And you see now from both their perspectives that loan is completed you can see the history of what’s gone on. You can see, at particular points, the
balances that the contract holds.</p>
<p>If we close that and select <em>History</em>, we can see the history of all the contracts that Shruti has taken part in.</p>
<div class="figure align-default">
<img alt="_images/pic__000461.png" src="_images/pic__000461.png" />
</div>
<p>That pretty much covers the basics of what you get from Marlowe Run. It’s an intuitive interface to a contract running on the blockchain.
You see that each participant in the contract gets their view of the contract in real time, updated from what is, in this case in the browser, but
eventually what’s on the blockchain.</p>
</div>
<div class="section" id="engineering">
<h4><span class="section-number">1.9.2.8. </span>Engineering<a class="headerlink" href="#engineering" title="Permalink to this headline">¶</a></h4>
<p>Let’s now take a look under the hood and see how Marlowe will be executed on Cardano.</p>
<p>Here’s a diagram just to give you the context. You’ll understand most parts of this diagram already. We a Cardano root node on which Plutus is running, and as you
know, Plutus is a dialect of haskell, more or less.</p>
<div class="figure align-default">
<img alt="_images/pic__00042.png" src="_images/pic__00042.png" />
</div>
<p>Marlowe is embedded in Haskell and Marlowe is executed using Plutus. So Marlowe sits on top of Plutus, but it’s also linked to Marlowe Run and has
an attachment to a wallet you’ll be able to interact with as an end user with a running Marlowe contract.</p>
<p>Also it gets linked to Oracles and so on sitting out there in the real world.</p>
<p>Now, what does it mean to to execute a Marlowe contract?</p>
<div class="figure align-default">
<img alt="_images/pic__000441.png" src="_images/pic__000441.png" />
</div>
<p>Again this will be familiar to you from Plutus but let’s just talk through precisely how it works.</p>
<p>Executing a Marlowe contract will produce a series of transactions on the blockchain. Obviously Plutus running on Cardano
checks the validity of transactions. We have a validation function.</p>
<p>The validation function for these Marlowe transactions is essentially a Marlowe interpreter. It checks that the transactions indeed conform
to the steps of the Marlowe contract. That’s done using the (E)UTxO model, so we pass the current state of the contract and some other information through as
datum.</p>
<p>The Marlowe interpreter uses that to ensure that the the transactions that are submitted meet the criteria for the particular Marlowe contract.</p>
<p>So that’s the on chain part.</p>
<div class="figure align-default">
<img alt="_images/pic__000471.png" src="_images/pic__000471.png" />
</div>
<p>Obviously off chain there’s a component as well. So we have to have Marlowe Run and we’ll have to build the transactions that meet the
the validation step on chain.</p>
<p>And, if and when the contract requires crypto assets it will have off chain code to ensure that transactions are appropriately signed so that we will have authorization
for spending crypto assets.</p>
<p>Using Marlowe run and an associated wallet, we construct the transactions.</p>
<p>We get a flow of information in both directions. Marlowe run will submit transactions to the blockchain that then can be validated by the Marlowe interpreter, which
is itself a Plutus contract. It’s one of the largest Plutus contracts that exists.</p>
<p>But there’s also information flow another way because suppose that the transaction I’ve submitted is a deposit of money into a running contract, and suppose the
contract also involves Charles Hoskinson, so my instance of Marlowe Run has submitted that transaction, but Charles also has to be notified about that.</p>
<p>The information flows in the other direction using the companion contract to ensure that every instance of Marlowe Run gets informed about activity in that contract.</p>
<p>Alex will talk some more about the details of the implementation but here you’re seeing an outline of how it all how it all works.</p>
<p>Transactions are validated on chain through the interpreter, but they have to be built off chain and in some cases have to be authorized. Essentially the blockchain is
the central synchronization point for the distributed system that is the collection of instances of Marlowe Run that are interacting to execute the contract/</p>
<p>You saw in the demo that, in two separate windows, we were sharing information. That was simulating it locally but in production this will be information that’s stored
on the blockchain.</p>
</div>
<div class="section" id="system-design">
<h4><span class="section-number">1.9.2.9. </span>System Design<a class="headerlink" href="#system-design" title="Permalink to this headline">¶</a></h4>
<p>Let’s talk a little bit about how the system is designed in in a high-level way.</p>
<p>Here’s a piece of the semantics of Marlowe, and as you can see it’s a Haskell function.</p>
<div class="figure align-default">
<img alt="_images/pic__000471.png" src="_images/pic__000471.png" />
</div>
<p>We take an environment, the current state and a contract we executed, and based on what contract that is - a <em>close</em> perhaps, or a <em>pay</em>, we can reduce we can take
some steps of computing the results of that contract.</p>
<p>We do that in a way that uses uses Haskell in a quite straightforward way to advance the contract. This specification in Haskell is
an executable specification of the semantics and this gives us some very nice consequences.</p>
<div class="figure align-default">
<img alt="_images/pic__000481.png" src="_images/pic__000481.png" />
</div>
<p>We’ve got al we’ve got a high level description of what the semantics are, and we’re doing that through something that is effectively an interpreter. So
we’re defining at a high level this interpreter in Haskell for Marlowe contracts.</p>
<p>One really nice thing about writing it in this sort of way is that we can be sure we cover all cases because it’s a it will be obvious if we’re missing some
cases. Writing it as an interpreter ensures that we will hit cases we need to in describing the semantics.</p>
<p>Also it really helps us to understand the semantics. When you’re designing a language you have an abstract idea about what it’s going to mean, but there’s
nothing like having a an implementation of it so you can actually run the semantics.</p>
<p>What would it mean if we were to add this construct? What would it mean if we were to modify the semantics in this way?</p>
<p>If we’d written it in a purely purely logical format, it’s difficult to unscramble just from the rules as they’re laid out what, precisely, a change in rule
might mean.</p>
<div class="figure align-default">
<img alt="_images/pic__000491.png" src="_images/pic__000491.png" />
</div>
<p>What’s even nicer is that we can reuse the semantics in a number of different ways.</p>
<p>In the theorem prover Isabelle, we can use the semantics for reasoning and proof and we use pretty much the same semantics because Isabelle uses a functional
language as is as its subject.</p>
<div class="figure align-default">
<img alt="_images/pic__000501.png" src="_images/pic__000501.png" />
</div>
<p>We can run the semantics in Plutus. Plutus is more or less Haskell, perhaps not with all the libraries, but we can, in principle at least, build our
implementation on blockchain from our semantics, and also we can translate the semantics into PureScript for simulation in the browser.</p>
<div class="figure align-default">
<img alt="_images/pic__000511.png" src="_images/pic__000511.png" />
</div>
<p>Now pure script is not the same exactly the same as Haskell. Isabelle’s language is not exactly the same as Haskell. How can we be sure that all these
versions are the same?</p>
<p>One way of doing it is to extract Haskell code from Isabelle and test the original against um this extracted code. We do that on random contracts and that gives
us a pretty high level of assurance that the two are the same.</p>
<p>Down down the line in our road map we certainly expect to be using a Haskell and Javascript implementation at some point to replace PureScript in the front end
so we don’t have to write a PureScript version of the semantics when we’re doing the off chain interpretation building the transactions to be submitted. We can
use the real haskell implementation by compiling it into Javascript and running that in Marlowe Run in the client code.</p>
<p>So, building the language in Haskell means that though we use various different versions of the semantics, we can get a high level of
assurance that these are the same and indeed we can in some situations replace things like the PureScript by Javascript.</p>
</div>
<div class="section" id="usability">
<h4><span class="section-number">1.9.2.10. </span>Usability<a class="headerlink" href="#usability" title="Permalink to this headline">¶</a></h4>
<p>That gives us a picture about how how the system is put together. Let’s go to another aspect of Marlowe. We we talked about it being a special purpose
language, and that being a DSL promoted usability.</p>
<p>Let’s say a bit more about that.</p>
<div class="figure align-default">
<img alt="_images/pic__000531.png" src="_images/pic__000531.png" />
</div>
<p>One way we we promote usability is that we provide different ways of writing contracts. Another way we promote usability is to allow people to explore interactively
how contracts behave before they’re actually run in the simulation.</p>
<p>So let’s talk about those now.</p>
<div class="figure align-default">
<img alt="_images/pic__000541.png" src="_images/pic__000541.png" />
</div>
<p>We want to write a Marlowe contract, how can we do it? Well, we can write Haskell using the Marlowe data type as text. That’s one way we can do it and
that’s fine. We have an editor for that inside the playground that supports code completion and will make suggestions and and so on.</p>
<p>So we can build the contracts as pure Marlowe, but there are other routes as well.</p>
<p>We have a visual editor for Marlowe so that you can produce Marlowe contracts visually, putting together blocks in a way that doesn’t require you
to be a confident programmer. You can start off by using the visual version as a way of learning to engage with Marlowe if you are a coder.</p>
<p>Marlowe is embedded in Haskell and in Javascript so we can use facilities like recursion to describe Marlowe contracts. We can say, in Haskell, let’s do this particular pattern of
behavior a certain number of times. We can write that in Haskell and then for a particular contract we convert the Haskell into Marlowe, and we can also do that for
Javascript.</p>
<p>Finally, something we’re not going to talk about anymore in this talk is that we can generate contracts from initial conditions. We’ve been
looking at that for the actor standard of financial contracts. On the basis of the contract terms we generate code in Marlowe. We write functions
whose output is Marlowe code.</p>
<p>We provide users with a variety of different approaches, leveraging knowledge of Javascript, for example, or leveraging a non-code-based approach for
describing the contracts</p>
<p>We also allow people to simulate the behavior of contracts. This is something that you can see in the current version of the Marlowe Playground.</p>
<div class="figure align-default">
<img alt="_images/pic__000551.png" src="_images/pic__000551.png" />
</div>
<p>That’s something you can play with yourselves. We are looking at different ways of describing the results of a simulation. So at the moment we have a transaction
log. We are allowed to choose an next action to perform, you can undo the last step to take you back and then try another path so you can step interactively
backwards and forwards through the source code through the application of the contract.</p>
<p>What we’re looking at is changing the user interface Marlowe Playground so that we’ll use something rather more like the Marlowe Run run description of a running contract.</p>
<div class="figure align-default">
<img alt="_images/pic__000561.png" src="_images/pic__000561.png" />
</div>
</div>
<div class="section" id="assurance">
<h4><span class="section-number">1.9.2.11. </span>Assurance<a class="headerlink" href="#assurance" title="Permalink to this headline">¶</a></h4>
<p>We’ve talked about usability. What about the sort of assurance that Marlowe can give users?</p>
<div class="figure align-default">
<img alt="_images/pic__000571.png" src="_images/pic__000571.png" />
</div>
<p>We’ve seen we’ve seen that making the system transparent, that making code readable is itself an advantage. We’ve seen that there’s simulation to
give people to validate their intuition about a contract.</p>
<p>But rather more formally we can use the power of logic to do two things for us. We can do what’s called <em>static analysis</em> so we can automatically verify
properties of individual contracts. That means we can guarantee this contract will behave as it should, checking every route through the contract.</p>
<p>Also we can do machine-supported proof so, not automatic any longer, written by a user, but we can prove properties of the overall system.</p>
<div class="figure align-default">
<img alt="_images/pic__00058.png" src="_images/pic__00058.png" />
</div>
<p>What static analysis allows us to do is check all execution paths through a Marlowe contract. All choices, all choices of slots for a submission of a transaction so
we examine every possible way in which the contract might be executed.</p>
<p>The canonical example here is the example of whether a pay construct might fail. Is it possible a pay construct could fail? The answer is that we
will use what’s called an SMT solver An SMT is an automatic logic tool - the one we use is called Z3, although others are available. The SMT solver effectively
checks all execution parts.</p>
<p>If a property is is satisfied that’s fine, we get get the result. If it’s not satisfied, we get a counter example. We get told that there’s a way
through this contract that leads to a failed payment - a payment that can’t be fulfilled. So it gives an example of how it can go wrong, and that’s really
helpful. It means that if you really want to make sure that a failed payment can’t happen, then this gives you a mechanism to understand
and to debug how that eventuality can happen, and so gives you a chance to think about how to avoid it.</p>
<p>So, very powerful and entirely push button. You push a button and you get the results.</p>
<div class="figure align-default">
<img alt="_images/pic__000591.png" src="_images/pic__000591.png" />
</div>
<p>Here you see a fragment of a Marlowe contract. It’s an escrow contract where the contract starts with a deposit of 450 lovelace.</p>
<p>Checking the analysis in the playground, we’ve got the results. Static analysis could not find any any execution that results in any warning, so that’s saying
that you’re okay - it’s not going to give you a warning whatever you do.</p>
<p>But if we change that deposit of 450 lovelace to a deposit of 40 and analyze we then get this warning.</p>
<div class="figure align-default">
<img alt="_images/pic__000601.png" src="_images/pic__000601.png" />
</div>
<p>We get a transaction partial payment. We’re told that we get to a payment where we’re meant to pay 450 units of lovelace but there are only 40 available, and we
get given a list of transactions that take us there.</p>
<p>So we’re able to see from that how we got to that point, and the problem is that we didn’t put enough money in and then we reached a place where we needed to make a
payment of 450 lovelace.</p>
<p>So it’s easy for us to see that we need to either make the payment smaller or make the initial deposit bigger. As it’s entirely push button, we get that sort of assurance for free, as it were.</p>
<div class="figure align-default">
<img alt="_images/pic__000611.png" src="_images/pic__000611.png" />
</div>
<p>But thinking about verification, we can do rather more than that. We can prove properties of the system once and for all.</p>
<p>So, for example, we can prove from the semantics that accounts inside a Marlowe contract never go negative. You can’t ever overdraw an account in a Marlowe contract.</p>
<p>We can also prove this theorem of money preservation. We can prove that if we look at all the money that’s gone into the contract so far, that’s equal to the sum of
two things - the amount of money that’s held inside the contract plus the amount of money that has been paid out. That gives a clear picture of money preservation.</p>
<p>We’re also able to to prove other more technical things about the system. For example, that a <em>Close</em> construct will never produce any warnings. So, if we’re
analyzing for warnings, we don’t need to worry about <em>Close</em> constructs. That allows us to optimize the static analysis.</p>
<p>We’re also able to prove that the static analysis, which makes a number of simplifications to speed
things up, is sound and complete. That means the static analysis will give us an error warning when the real contract can generate an error warning and
it won’t give us an error warning if the real contract can’t do that.</p>
<p>One thing that we haven’t done but is on our road map is to do these sorts of proofs for individual contracts or individual contract templates. Things that we
can’t necessarily prove with static analysis, we can prove by proving them by hand.</p>
<p>The system is amenable to having these proofs written about it, and they give us the highest level of assurance about how it works.</p>
<p>We’ve said enough for the moment about Marlowe. Where can you go to find out more?</p>
<div class="figure align-default">
<img alt="_images/pic__000621.png" src="_images/pic__000621.png" />
</div>
<p>There’s a Marlowe GitHub repository that has the semantics and the basics about Marlowe.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="nb">input</span><span class="o">-</span><span class="n">output</span><span class="o">-</span><span class="n">hk</span><span class="o">/</span><span class="n">marlowe</span>
</pre></div>
</div>
<p>Quite a lot of the implementation of the tools from Marlowe is in the Plutus repository because it has that repository as a dependency.</p>
<p>If you look in the <a class="reference external" href="https://iohk.io/en/research/library/">IOHK online research library</a> and search for Marlowe you’ll find a number of research papers we’ve written about how the system works.</p>
<p>You’ll also find an online tutorial in the Marlowe Playground.</p>
<p>Finally, Alex is going to give some more information in his presentation coming up next.</p>
</div>
<div class="section" id="id27">
<h4><span class="section-number">1.9.2.12. </span>Summary<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<div class="figure align-default">
<img alt="_images/pic__000631.png" src="_images/pic__000631.png" />
</div>
<p>Just to summarize, what we have in Marlowe is a DSL, a special-purpose language for financial contracts, running on top of Plutus. Because it’s a
DSL it allows us to give assurance that is harder to give for a general purpose language. And we get assurance of they way contracts should and shouldn’t behave.</p>
<p>It also allows us to to orient its design around users as well as developers. The language is simple and therefore we get readability.</p>
<p>We also get simulatability and we get these stronger assurances of static analysis and verification.</p>
</div>
</div>
<div class="section" id="lecture-by-alex-nemish">
<h3><span class="section-number">1.9.3. </span>Lecture by Alex Nemish<a class="headerlink" href="#lecture-by-alex-nemish" title="Permalink to this headline">¶</a></h3>
<p>Alex Nemish is one of the Marlowe developers and in this presentation, he shows us a bit of Marlowe semantics and Marlowe PAB (Plutus Application Backend) contracts.</p>
<p>We’ll start with a brief description of Marlowe Semantics that’s implemented in the <a class="reference external" href="https://github.com/input-output-hk/marlowe/blob/master/semantics-2.0/Semantics.hs">Semantics.hs</a> file.
Then we’ll look at the PAB contracts.</p>
<p>Here are the main data types for Marlowe.</p>
<div class="figure align-default">
<img alt="_images/pic__000651.png" src="_images/pic__000651.png" />
</div>
<p>It’s a contract. Essentially those are six constructors that you can start to model a contract with and here’s the state that is going to be stored on a blockchain.</p>
<div class="figure align-default">
<img alt="_images/pic__00066.png" src="_images/pic__00066.png" />
</div>
<p>So we have a state of balances of accounts by party, we have a map of choices, we have bound values which come from the <em>Let</em> constructor, and a <em>minSlot</em> which is
the first slot that the contract sees.</p>
<div class="figure align-default">
<img alt="_images/pic__00067.png" src="_images/pic__00067.png" />
</div>
<p>The <em>Input</em> data type essentially contains actions for a Marlowe contract. It is either a deposit, a choice, or a notification.</p>
<div class="figure align-default">
<img alt="_images/pic__00068.png" src="_images/pic__00068.png" />
</div>
<p>Here is the <em>TransactionInput</em> datatype. This is what we give as an input. Every transaction has a defined slot interval and a list of inputs.</p>
<div class="figure align-default">
<img alt="_images/pic__00070.png" src="_images/pic__00070.png" />
</div>
<p>And we have <em>TransactionOutput</em> which contains the payments that we expect to happen, the output state and the output contract.</p>
<p>We also see <em>MarloweData</em> which is essentially what is going to be stored on the blockchain. It’s the current state of a contract as well as the actual contract.</p>
<div class="figure align-default">
<img alt="_images/pic__00073.png" src="_images/pic__00073.png" />
</div>
<p>The entrance to the semantics is the <em>computeTransaction</em> function. It gets the transaction input, the current state and the current contract and returns the
transaction output.</p>
<p>First of all we check the slot interval for errors. For example, we do not allow the slot interval to contain any timeouts. If you have a contract with a <em>When</em> construct
of 10, you cannot produce a contract with a slot interval of 5..15 because it will contain a timeout.</p>
<p>Then we apply all inputs and if this is successful we return the transaction output with any warnings we have found, the payments we expect, the new state and the continuation
contract.</p>
<div class="figure align-default">
<img alt="_images/pic__00073.png" src="_images/pic__00073.png" />
</div>
<p>So what happens in <em>applyAllInputs</em>?</p>
<p>First of all, it’s a loop. It uses the <em>reduceContractUntilQuiescent</em> function which reduces the contract until it reaches a quiescent state. Once we reach a quiescent state, we take the first input and try to apply it, and then
continue with the loop, until we get an empty input list. Then we return the current state and the continuation contract.</p>
<div class="figure align-default">
<img alt="_images/pic__00074.png" src="_images/pic__00074.png" />
</div>
<p>The <em>reduceContractUntilQuiescent</em> function goes through a loop and tries to apply <em>reduceContractStep</em> which essentially evaluates a contract.</p>
<div class="figure align-default">
<img alt="_images/pic__00075.png" src="_images/pic__00075.png" />
</div>
<p>If we get a <em>Close</em> then we are in a quiescent state. If we get a payment, then we evaluate it, update the balances and then return the reduced contract.</p>
<div class="figure align-default">
<img alt="_images/pic__00076.png" src="_images/pic__00076.png" />
</div>
<p>We do the same for <em>If</em>, <em>Let</em> and <em>Assert</em>. But for <em>When</em>, we only evaluate it if it’s timed out, otherwise we say that it’s not reduced, and that the contract is
quiescent.</p>
<p>In a nutshell, Marlowe contract evaluation consists of two steps.</p>
<ul class="simple">
<li><p>We reduce the contract until it is quiescent - it’s either closed or we get to a <em>When</em> that’s not timed out yet.</p></li>
<li><p>We try to apply inputs and evaluate the contract further.</p></li>
</ul>
<p>Let’s see how it works from the client side.</p>
<p>As you may have noticed, the Marlowe semantics code is quite abstract and it doesn’t depend on the Cardano system’s actions. So let’s take a look at the actual Marlowe
validator that’s being executed on-chain.</p>
<div class="figure align-default">
<img alt="_images/pic__00078.png" src="_images/pic__00078.png" />
</div>
<p>Here’s the <em>scriptInstance</em> which calls the <em>mkMarloweValidator</em> code, which in turn calls <em>mkValidator</em>, which uses a state machine library function <em>mkStateMachine</em> to
which is provides two functions - a transition function and a finality check.</p>
<p>The finality check is very simple - we just check the the contract contract is constructed with <em>Close</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00079.png" src="_images/pic__00079.png" />
</div>
<p>The transition function is the meat of the validator.</p>
<p>It takes <em>MarloweParams</em> - which we’ll talk about later, it takes the state of the state machine <em>MarloweData</em>, it takes <em>MarloweInput</em> which is essentially transaction
input expressed in Cardano types. It will then return either <em>Nothing</em> in the case of error, or a new state along with zero or more constraints.</p>
<p>We check that the balances are valid - we require balances to be positive.</p>
<p>Then we create input constraints based on the inputs. So, in the case of deposits we expect that money will go into a contract. In the case of choices, we expect witnesses
of the respective parties. We calculate that the contract contains the correct balance.</p>
<div class="figure align-default">
<img alt="_images/pic__00081.png" src="_images/pic__00081.png" />
</div>
<p>We construct a <em>TransactionInput</em> given the slot interval and list of inputs, and we call the <em>computeTransaction</em> function that we saw in <em>semantics.hs</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00082.png" src="_images/pic__00082.png" />
</div>
<p>With the computed result we construct a <em>MarloweData</em> with a new contract continuation and updated state. We produce output constraints that produce payouts to the
respective parties, and we calculate the new balance. Then we combine all the constraints with range validation.</p>
<div class="figure align-default">
<img alt="_images/pic__00083.png" src="_images/pic__00083.png" />
</div>
<p>To validate inputs, we check that the required signatures and role tokens are present.</p>
<div class="figure align-default">
<img alt="_images/pic__00084.png" src="_images/pic__00084.png" />
</div>
<p>Payments to parties go either to a public key, or go to the validator <em>rolePayoutValidatorHash</em>, which simply checks, given a currency, that a transaction spends a role token.</p>
<p>For off-chain execution, we provide three Marlowe PAB contracts.</p>
<ul class="simple">
<li><p>Marlowe Follower Contract</p></li>
<li><p>Marlowe Control Contract</p></li>
<li><p>Marlowe Companion Contract</p></li>
</ul>
<div class="section" id="follower-contract">
<h4><span class="section-number">1.9.3.1. </span>Follower Contract<a class="headerlink" href="#follower-contract" title="Permalink to this headline">¶</a></h4>
<div class="figure align-default">
<img alt="_images/pic__00086.png" src="_images/pic__00086.png" />
</div>
<p>This is a very simple one - it contains only one endpoint called <em>follow</em>. It subscribes to all changes to a Marlowe contract validator address, so that we can store
all the inputs that are applied to a Marlowe contract.</p>
<p>It uses the <em>updateHistoryFromTx</em> function which, in a nutshell, finds a Marlowe input and constructs a <em>TransactionInput</em> data type, and uses <em>tell</em> to update the PAB
contract state.</p>
<p>If you were connected to a web socket for this contract, you would be notified about transition changes.</p>
<div class="figure align-default">
<img alt="_images/pic__00087.png" src="_images/pic__00087.png" />
</div>
<p>The state of the contract is stored in <em>ContractHistory</em>, which stores an initial <em>MarloweParams</em>, an initial <em>MarloweData</em> and a list of all <em>TransactionInput</em>s that
were applied to this contract. You can always restore the current state by applying a list of inputs to an initial state.</p>
<div class="figure align-default">
<img alt="_images/pic__00088.png" src="_images/pic__00088.png" />
</div>
</div>
<div class="section" id="control-contract">
<h4><span class="section-number">1.9.3.2. </span>Control Contract<a class="headerlink" href="#control-contract" title="Permalink to this headline">¶</a></h4>
<div class="figure align-default">
<img alt="_images/pic__00089.png" src="_images/pic__00089.png" />
</div>
<p>The <em>marlowePlutusContract</em> is a control contract. It allows you to create an instance of a Marlowe contract, apply inputs to the instance, to auto-execute the contract,
if possible, to redeem tokens from payments to roles, and to close the contract.</p>
<p>Let’s go through Marlowe contract creation.</p>
<p>When you call the <em>create</em> endpoint, you provide a contract and a map of roles to public keys. We then setup a <em>MarloweParams</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00090.png" src="_images/pic__00090.png" />
</div>
<p><em>MarloweParams</em> is a way to parameterise a Marlowe contract. You can specify your own role payout validator by providing its hash. There is a default one that checks that
the role token is spent within the transaction but you can do whatever you like.</p>
<p>When your contract uses roles, we need to know the currency symbol for the role. When the contract uses roles, we need to create role tokens and distribute them to their
owners.</p>
<p>In the <em>setupMarloweParams</em> function we get the roles that are used within the contract. If we have owners for these roles, we create tokens with role names. By default we
create one token per role. We use the <em>Contract.forgeContract</em> function to create the tokens and then assign them to the creator. Then, in the same transaction, we
distribute the role tokens to their owners.</p>
<p>Next in the control contract, we use the state machine library to create a state machine client and submit the transaction.</p>
<p>The <em>apply</em> endpoint is very simple. We call the <em>applyInputs</em> function.</p>
<div class="figure align-default">
<img alt="_images/pic__00092.png" src="_images/pic__00092.png" />
</div>
<p>We construct a slot range and we use the <em>runStep</em> function which takes a slot range and a list of inputs.</p>
<p>The <em>redeem</em> endpoint allows you to get money that has been paid to a role payout script.</p>
<div class="figure align-default">
<img alt="_images/pic__00093.png" src="_images/pic__00093.png" />
</div>
<p>We get the address of the script and then send all the outputs to the token owner.</p>
<div class="figure align-default">
<img alt="_images/pic__00095.png" src="_images/pic__00095.png" />
</div>
<p>The <em>auto</em> endpoint is quite interesting and quite complicated. There is a set of contracts that can be executed automatically.</p>
<p>Imagine a contract that contains only deposits and payouts. No participant needs to provide choices or any interactive stuff. There are only scheduled payments. Such a
contract can be executed automatically, and the <em>auto</em> endpoint allows exactly that.</p>
<p>So, if a contract can be executed automatically, it calls <em>autoExecuteContract</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00096.png" src="_images/pic__00096.png" />
</div>
<p>This is a state machine that pays a deposit or waits for other parties to do their part.</p>
</div>
<div class="section" id="companion-contract">
<h4><span class="section-number">1.9.3.3. </span>Companion Contract<a class="headerlink" href="#companion-contract" title="Permalink to this headline">¶</a></h4>
<p>The last interesting contract is the Marlowe Companion Contract.</p>
<div class="figure align-default">
<img alt="_images/pic__00097.png" src="_images/pic__00097.png" />
</div>
<p>This is a contract that monitors a participant wallet and notifies when a role token arrives.</p>
<div class="figure align-default">
<img alt="_images/pic__00098.png" src="_images/pic__00098.png" />
</div>
<p>It listens to transactions that go to your own address and if there is a token and this token is generated by Marlowe contract creation, it tries to find the Marlowe
contract and, if it succeeds, it updates the state of the contract. If you are subscribed to the contract’s web socket, you will get a notification about a role
token, and you’ll get a map of <em>MarloweParams</em> to <em>MarloweData</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00099.png" src="_images/pic__00099.png" />
</div>
</div>
</div>
<div class="section" id="playing-in-the-playground">
<h3><span class="section-number">1.9.4. </span>Playing in the Playground<a class="headerlink" href="#playing-in-the-playground" title="Permalink to this headline">¶</a></h3>
<p>Let’s play around a little with Marlowe in the playground.</p>
<p>When you go to the playground, you first get presented with three options for you to choose in which language you want to write your Marlowe contracts.</p>
<div class="figure align-default">
<img alt="_images/pic__00101.png" src="_images/pic__00101.png" />
</div>
<p>You can do it in Haskell, you can do it in Javascript, or you can do it in Blockly or directly in Marlowe.</p>
<p>Blockly is very nice and you don’t need any programming experience to do this.</p>
<div class="section" id="blockly">
<h4><span class="section-number">1.9.4.1. </span>Blockly<a class="headerlink" href="#blockly" title="Permalink to this headline">¶</a></h4>
<p>Let’s start a new project and select <em>Blockly</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00102.png" src="_images/pic__00102.png" />
</div>
<p>This is a graphical editor. We can just click and drop a Marlowe contract together.</p>
<p>As an example let’s write a contract where there are three parties - Alice, Bob and Charlie.</p>
<p>The idea is that Alice and Bob deposit an amount of Ada into the contract, let’s say 10 Ada, and then Charlie decides whether Alice or Bob
gets the total amount. Depending on Charlie’s decision either Alice gets 20 or Bob gets 20.</p>
<p>There’s always the possibility that one of the three doesn’t play along; Alice doesn’t make her deposit, Bob doesn’t make his deposit, or Charlie doesn’t make his
choice. In this case everybody should just get reimbursed.</p>
<p>When we start with Blockly, there is a contract and it’s just a <em>Close</em> contract, which in this case doesn’t do anything. If there was money in internal accounts
it would pay back the money to the owners of the accounts.</p>
<p>We want to do something else, so let’s first wait for a deposit by Alice.</p>
<p>Because that’s an external action that’s triggered by one of the parties, in this case Alice, we need the <em>When</em> construct that Simon mentioned.</p>
<div class="figure align-default">
<img alt="_images/pic__00103.png" src="_images/pic__00103.png" />
</div>
<p>We can remove the <em>Close</em> contract, slide the <em>When</em> one into its place.</p>
<div class="figure align-default">
<img alt="_images/pic__00104.png" src="_images/pic__00104.png" />
</div>
<p>Here we see all the slots where other things need to go. We see some fields that we have to set.</p>
<p>We can set a timeout so let’s say this deposit by Alice has to happen by slot 10.</p>
<div class="figure align-default">
<img alt="_images/pic__00105.png" src="_images/pic__00105.png" />
</div>
<p>If it doesn’t happen, we can say what should happen afterwards, and there is not really a good choice to do anything except close in that case, so in that case
nothing will happen.</p>
<div class="figure align-default">
<img alt="_images/pic__00106.png" src="_images/pic__00106.png" />
</div>
<p>Here we say what external actions we wait for. Let’s say we only wait for one action, namely that Alice makes a deposit.</p>
<p>So we can check for actions and pick the deposit one and slide it in.</p>
<div class="figure align-default">
<img alt="_images/pic__00107.png" src="_images/pic__00107.png" />
</div>
<p>We see some slots that we have to fill. First of all, a party who has to make the deposit, and there are two choices - a public key or role.</p>
<div class="figure align-default">
<img alt="_images/pic__00108.png" src="_images/pic__00108.png" />
</div>
<p>Let’s take role because then we can just say Alice. Normally this would be the name of the role token, so whoever owns that token can incorporate that role.</p>
<div class="figure align-default">
<img alt="_images/pic__00109.png" src="_images/pic__00109.png" />
</div>
<p>So Alice makes a deposit. Now the amount. That’s a <em>Value</em> and let’s say we just pick a constant amount of 10 Ada.</p>
<div class="figure align-default">
<img alt="_images/pic__00110.png" src="_images/pic__00110.png" />
</div>
<p>The amount is 10, and the fact that it is Ada must be specified in the currency slot.</p>
<div class="figure align-default">
<img alt="_images/pic__00111.png" src="_images/pic__00111.png" />
</div>
<p>There’s also the option to use tokens than Ada, but let’s stick with Ada.</p>
<p>Now there are these internal accounts that also belong to one of the parties, so let’s say Alice pays it into her own internal account.</p>
<div class="figure align-default">
<img alt="_images/pic__00112.png" src="_images/pic__00112.png" />
</div>
<p>That can be copy/pasted rather than getting it from the <em>Party</em> menu again.</p>
<p>Now we must say what happens next, if Alice makes this deposit. Afterwards we want Bob to make a deposit, so we can start by just copying the whole <em>When</em> block.</p>
<div class="figure align-default">
<img alt="_images/pic__00113.png" src="_images/pic__00113.png" />
</div>
<p>First of all we change the timeout to 20 so as to give Bob also 10 slots to do something, and then wherever we have Alice, we now put Bob.</p>
<div class="figure align-default">
<img alt="_images/pic__00114.png" src="_images/pic__00114.png" />
</div>
<p>So at this point, if both these actions happen, Alice has deposited 10 into her internal account and Bob has deposited 10 into his external account.</p>
<p>Now we want Charlie to make a choice, and this is again an external action, so again we need a <em>When</em>, but this time it’s not a deposit so let’s delete
the deposit. Then let’s change the timeout to 30 to give Charlie 10 slots to make his choice.</p>
<div class="figure align-default">
<img alt="_images/pic__00115.png" src="_images/pic__00115.png" />
</div>
<p>Now we need a different action. Where earlier we had <em>Deposit</em>, now we pick the <em>Choice</em> action. We can give it a name, let’s say <em>Winner</em>. We must say who
makes the choice, so that’s will be Charlie, and now we must specify what values this choice can have.</p>
<div class="figure align-default">
<img alt="_images/pic__00116.png" src="_images/pic__00116.png" />
</div>
<p>That’s numeric so because Charlie is supposed to choose between Alice and Bobs, which is two choices, I can pick arbitrary values like one and two. One for Alice,
two for Bob. That’s already the default so that’s fine.</p>
<p>This allows Charlie to choose one or two.</p>
<div class="figure align-default">
<img alt="_images/pic__00117.png" src="_images/pic__00117.png" />
</div>
<p>Then if and when Charlie makes a choice, we continue, and it now depends on the choice that he has made. If he chose Alice then Alice must get all the money, if he
chose Bob then Bob must get all the money.</p>
<p>So we will add an <em>If</em> conditional.</p>
<div class="figure align-default">
<img alt="_images/pic__00118.png" src="_images/pic__00118.png" />
</div>
<p>Then we will add an observation to check if Alice is the winner. The observation we add is the <em>value is equal to</em> observation.</p>
<div class="figure align-default">
<img alt="_images/pic__00119.png" src="_images/pic__00119.png" />
</div>
<p>To see if it is Alice, we will use the <em>Choice by</em> option to ask if Charlie’s <em>Winner</em> name is equal to Alice.</p>
<div class="figure align-default">
<img alt="_images/pic__00120.png" src="_images/pic__00120.png" />
</div>
<p>In the <em>then</em> branch we now take a pay contract. The payee is who gets the money - it can be an internal account or it can be an external party. In this case it doesn’t
matter, because when we close, all the parties get the money from the internal accounts as well.</p>
<div class="figure align-default">
<img alt="_images/pic__00121.png" src="_images/pic__00121.png" />
</div>
<p>So, we’ll just pick Alice’s internal account.</p>
<div class="figure align-default">
<img alt="_images/pic__00122.png" src="_images/pic__00122.png" />
</div>
<p>We will pay 10 Ada.</p>
<div class="figure align-default">
<img alt="_images/pic__00123.png" src="_images/pic__00123.png" />
</div>
<p>So who pays? It must be an internal account because this pay contract is something that the contract has control over, so it is not an external action. So, payments are
triggered from internal accounts and in this case, it is Bob’s account.</p>
<div class="figure align-default">
<img alt="_images/pic__00124.png" src="_images/pic__00124.png" />
</div>
<p>So this now says: If Charlie picked 1, then pay from Bob’s internal account 10 Ada to Alice’s internal account.</p>
<p>After this we can just close. And when we close, all the internal accounts will be paid to the external owners. At this point, Alices internal account will have 20 Ada,
and when we close, she will get the 20 Ada paid to her.</p>
<div class="figure align-default">
<img alt="_images/pic__00125.png" src="_images/pic__00125.png" />
</div>
<p>And, if Charlie did not choose Alice, then we must pay to Bob. We can copy paste the previous Pay contract for this and make the necessary modifications.</p>
<div class="figure align-default">
<img alt="_images/pic__00126.png" src="_images/pic__00126.png" />
</div>
<p>And this should be enough for our contract.</p>
<p>Now we can, for example, look at the pure Marlowe. This is the value of the Marlowe data type called <em>Contract</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00127.png" src="_images/pic__00127.png" />
</div>
<p>And we can send it to the simulator.</p>
<div class="figure align-default">
<img alt="_images/pic__00128.png" src="_images/pic__00128.png" />
</div>
<p>We can start the simulation.</p>
<div class="figure align-default">
<img alt="_images/pic__00129.png" src="_images/pic__00129.png" />
</div>
<p>Now, whenever there is a <em>When</em>, we get prompted for which of the available actions to take. In our case we only ever have one available action at each point.</p>
<p>So in the first <em>When</em>, either Alice makes her deposit, or the timeout is reached.</p>
<p>If we wait for the timeout it is very boring. The contract is reduced to <em>Close</em>, and nothing happened.</p>
<div class="figure align-default">
<img alt="_images/pic__00130.png" src="_images/pic__00130.png" />
</div>
<p>If, however, she makes the deposit, then this contract simplifies - it reduces to what happens after she makes the deposit.</p>
<div class="figure align-default">
<img alt="_images/pic__00131.png" src="_images/pic__00131.png" />
</div>
<p>And now we can see we are in the second <em>When</em>, where we are waiting for Bob’s deposit. Again, he can choose not to deposit. If he does that, then we can see the
actions in the transaction log that Alice deposited 10 Ada and the contract pays this back to Alice upon close.</p>
<div class="figure align-default">
<img alt="_images/pic__00132.png" src="_images/pic__00132.png" />
</div>
<p>It is more interesting though if Bob also makes his deposit.</p>
<div class="figure align-default">
<img alt="_images/pic__00133.png" src="_images/pic__00133.png" />
</div>
<p>Now the contract has simplified again. Now we are in the <em>When</em> where the only available action is that Charlie chooses a winner.</p>
<p>If Charlie doesn’t do anything and the contract times out, Bob and Alice both get their money back.</p>
<div class="figure align-default">
<img alt="_images/pic__00134.png" src="_images/pic__00134.png" />
</div>
<p>If Charlie picks Alice (choice 1), then we see that the contract pays 20 Ada to Alice.</p>
<div class="figure align-default">
<img alt="_images/pic__00135.png" src="_images/pic__00135.png" />
</div>
<p>If instead he picks choice 2, then the contract pays 20 Ada to Bob.</p>
<div class="figure align-default">
<img alt="_images/pic__00136.png" src="_images/pic__00136.png" />
</div>
<p>Let’s now reset the contract.</p>
<p>We will copy the Marlowe code to the clipboard, then create a new Haskell project.</p>
<div class="figure align-default">
<img alt="_images/pic__00137.png" src="_images/pic__00137.png" />
</div>
<p>In the Haskell editor there is a template.</p>
<div class="figure align-default">
<img alt="_images/pic__00138.png" src="_images/pic__00138.png" />
</div>
<p>All this program does is to take a Marlowe contract, and then pretty prints it. This is then used to, for example, run in the simulator.</p>
<p>Instead of Close, we can paste what we just copied to the clipboard.</p>
<div class="figure align-default">
<img alt="_images/pic__00139.png" src="_images/pic__00139.png" />
</div>
<p>We can then compile this, and send it to the simulator and it should behave exactly as before.</p>
<p>There we don’t really see the benefit of doing it in Haskell, we could just as well do it in Blockly, although you may find that Blockly is really only useful for
learning and writing extremely simple contracts. We have just written a simple contract and already it was starting to get quite unwieldy in the Blockly editor. If you
do something more complicated it can start to get very confusing in the editor.</p>
<p>But, we can do other things in this Haskell program. We don’t have to literally define a contract. We can use the whole power of Haskell to help us to write the contract.</p>
<p>For example, we can see a lot of repetition because we always have the Alice, Bob and Charlie roles. We could define these separately.</p>
<p>Note that we can use overloaded string literals here because the <em>fromString</em> function uses the <em>Role</em> constructor for <em>Party</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00140.png" src="_images/pic__00140.png" />
</div>
<p>We can also define a constant for the deposit of 10 Ada.</p>
<div class="figure align-default">
<img alt="_images/pic__00141.png" src="_images/pic__00141.png" />
</div>
<p>For (Token “” “”), we can replace this with the <em>ada</em> abbreviation.</p>
<div class="figure align-default">
<img alt="_images/pic__00142.png" src="_images/pic__00142.png" />
</div>
<p>We can also simplify Charlie’s <em>ChoiceId</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00143.png" src="_images/pic__00143.png" />
</div>
<p>Now it is already cleaned up quite a bit.</p>
<p>It’s possible to do more sophisticated things. Our contract is slightly asymmetric even though it sounds like a symmetric situation. Alice and Bob are completely
symmetric, but in our contract, Alice has to deposit first.</p>
<p>What we could do is to allow Bob to deposit first as well. In the outermost <em>When</em> we would have two deposits - one where Alice deposits, and one where Bob
deposits.</p>
<p>Let’s make a little helper function. It takes two <em>Party</em>s - the party that deposits first and the party that deposits second and then it returns a <em>Case</em>. We can
use this to parameterise Alice and Bob as <em>x</em> and <em>y</em> in the <em>Case</em>. Note that we only need to do this for the deposits, the part where Charlie makes his choice can
remain the same, with Alice and Bob continuing to be represented by 1 and 2 respectively.</p>
<div class="figure align-default">
<img alt="_images/pic__00144.png" src="_images/pic__00144.png" />
</div>
<p>Now we can replace the originally-pasted code with our helper function, and we can create the symmetric case where Bob deposits first as an option to the outermost
<em>When</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00146.png" src="_images/pic__00146.png" />
</div>
<p>This should compile and we can now send to the simulator.</p>
<div class="figure align-default">
<img alt="_images/pic__00147.png" src="_images/pic__00147.png" />
</div>
<p>Now we have two possible actions that can happen in the first step. Alice can deposit 10, or Bob can deposit 10.</p>
<p>If Bob starts…</p>
<div class="figure align-default">
<img alt="_images/pic__00147.png" src="_images/pic__00147.png" />
</div>
<p>Then now it is Alice’s turn.</p>
<p>So, basically, to use the Haskell editor, we write a program that produces something of type <em>Contract</em> and you can use all the features of Haskell like local
functions or whatever to make your life easier.</p>
<p>When using Blockly, if we had wanted to give Bob the option of being the first to deposit, we would have had no choice but to have copy and pasted the whole <em>When</em>
construct.</p>
<p>Of course, there are other options when using Haskell. We could also paramterise the contract, for example, we could pass in the deposit value as an argument.</p>
<p>We could also parameterise the parties and even generalise it so that the number of parties could be variable. This would be very inconvenient if we were to have to
do this by hand using Blockly, but in Haskell it is quite straightforward.</p>
<p>What is noteworthy here is that Marlowe, in contrast to Plutus, is very simply Haskell. The Marlowe team made a point of using only basic Haskell features. You
don’t need lenses, you don’t need Template Haskell, you don’t even need monads or type-level programming.</p>
<p>Marlowe is not always appropriate because it is specifically for financial contracts, but if it is appropriate then it is a very nice option due to all the safety
assurances that Simon mentioned and because it is much simpler and easy to get right than Plutus.</p>
</div>
</div>
</div>
<div class="section" id="week-10-uniswap">
<h2><span class="section-number">1.10. </span>Week 10 - Uniswap<a class="headerlink" href="#week-10-uniswap" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These is a written version of <a class="reference external" href="https://youtu.be/Dg36h9YPMz4">Lecture
#10</a>.</p>
<p>In this lecture we look at an implementation of Uniswap in Plutus.</p>
<p>This is the last lecture in the Plutus Pioneer Program. However, there will be a special lecture once it is possible to deploy contracts to the testnet.</p>
</div>
<p>In this lecture we won’t be introducing any new topics or concepts. Instead we will do an end-to-end walk through of a demo that Lars wrote some months ago that
clones the very popular Uniswap contract from Ethereum.</p>
<p>The one new thing we will look at following several requests is how you can query the endpoints created by the PAB with Curl commands just from the console.</p>
<div class="section" id="what-is-uniswap">
<h3><span class="section-number">1.10.1. </span>What is Uniswap<a class="headerlink" href="#what-is-uniswap" title="Permalink to this headline">¶</a></h3>
<p>So for those of you who haven’t heard of Uniswap, what is Uniswap?</p>
<p>Uniswap is a so-called DeFi, or decentralized finance application, that allows swapping of tokens without any central authority. In
the case of Ethereum it’s ERC20 tokens.</p>
<p>So you don’t need a centralized exchange, the traditional way to exchange tokens or other crypto assets. Instead everything is governed by
smart contracts and works fully automatically on the blockchain.</p>
<p>Another interesting feature of Uniswap is that it doesn’t discover prices the usual way with the so-called order book, but uses a different
automatic price discovery system. The idea is that people can create so-called liquidity pools.</p>
<p>If they want other users to be able to swap two different tokens, then somebody can create a liquidity pool and put a certain amount of those two tokens
in this liquidity pool, and in return the creator of the pool will receive so-called liquidity tokens that are specific to this one pool.</p>
<p>Other users can use that pool to swap. They take some amount of one of the tokens out in exchange for putting an amount of the other token back in.</p>
<p>Additionally, people can also add liquidity to the pool and receive liquidity tokens, or they can also burn liquidity tokens in exchange for tokens from the pool.</p>
<p>And all these features are also implemented in the version of Uniswap that works on Cardano that we’re going to look at now.</p>
<div class="figure align-default">
<img alt="_images/pic__00149.png" src="_images/pic__00149.png" />
</div>
<p>So let’s look at the various operations that are available in turn.</p>
<p>It all starts by somebody setting up the whole system. So some organization or entity that wants to offer this Uniswap service.</p>
<p>It starts with a transaction that creates a UTxO at this script address, here we call that <em>factory</em> for Uniswap factory. It contains an NFT that identifies the factory,
the same trick that we have used a couple of times before, and as datum, it will contain the list of all liquidity pools.</p>
<p>So in the beginning, when the factory is just being created, that list will be empty.</p>
<p>Now let’s assume that one user, Alice wants to create a liquidity pool for tokens A and B. A pool that allows others to swap A against B or B against A.</p>
<div class="figure align-default">
<img alt="_images/pic__00150.png" src="_images/pic__00150.png" />
</div>
<p>She has to provide some initial liquidity for the pool. So she needs some amount of token A and some amount of token B, let’s say she has 1,000A and 2000B.</p>
<p>It’s important to note here that the ratio between A and B reflects Alice’s belief in the relative value of the tokens. So if she wants to set up a pool with
1000A and 2000B, then she believes that one A has the same value as two Bs.</p>
<p>In order to create the liquidity pool, she will create a transaction with two inputs and three outputs.</p>
<div class="figure align-default">
<img alt="_images/pic__00151.png" src="_images/pic__00151.png" />
</div>
<p>The two inputs will be the liquidity she wants to provide; the 1000A and 2000B and the Uniswap factory invoked with the create redeemer. The three outputs
will be the newly-created pool.</p>
<p>We call it <em>Pool AB</em> here to indicate that it contains tokens AB, which will contain the liquidity that Alice provided; the 1000A and the 2000B and a freshly-minted
token that identifies this pool, an NFT, called <em>AB NFT</em> here.</p>
<p>The datum of the pool, the 1415, will be the amount of liquidity tokens that Alice receives in return for setting up this pool and providing the liquidity. #</p>
<p>If you wonder about the number, that is the square root of the product of 1000 and 2000, so that’s how the initial amount of liquidity tokens is calculated. It
doesn’t really matter, you could scale it arbitrarily, but that’s the way Uniswap does it.</p>
<p>The second output is the Uniswap factory again, with the same NFT as before that identifies it. And now the datum has been updated. So in this list that was
empty before, the list of all liquidity pools, there is now an entry for the newly-created AB pool.</p>
<p>Finally, there’s a third output for Alice, where she receives the freshly-minted liquidity tokens, called <em>AB</em> here to indicate that they belong to the pool AB.</p>
<p>Now that the liquidity pool has been set up, other users can use it to swap.</p>
<div class="figure align-default">
<img alt="_images/pic__00152.png" src="_images/pic__00152.png" />
</div>
<p>So let’s assume that Bob wants to swap 100A against B. What will Bob do?</p>
<p>He will create a transaction that has two inputs and two outputs. The two inputs are the 100A he wants to swap, and the pool with the swap redeemer. The outputs
are the Bs he gets in return.</p>
<p>In this example, that would be 181B and the updated pool. So the pool now has the additional 100A that Bob provided. So now it’s 1,100A, and it has 181B fewer than before.</p>
<p>It still, of course, has the NFT that identifies the pool and the datum hasn’t changed because the amount of liquidity tokens that have been minted hasn’t changed.</p>
<p>Now, of course, the question is, where does this 181 come from? This is this ingenious idea, how price discovery works in Uniswap.</p>
<p>So the rule is roughly that the product of the amounts of the two tokens must never decrease. Initially we have 1000 As and 2000 Bs and the product is 2 million.</p>
<p>If you do the calculation, then you will see that after the swap 1100*1819 will be slightly larger than 2 million.</p>
<p>If you think about it or try a couple of examples by yourself, then you will see that in principle, you will always pay this ratio of the As and Bs in the pool, at least if you swap small amounts.</p>
<p>So originally the ratio from A to B was 1:2, 1000:2000. 100 is relatively small in comparison to the 1000 liquidity, so Bob should roughly get 200B, but he does get less
and there are two reasons for that.</p>
<p>One is that the amount of tokens in the liquidity pool is never allowed to go to zero. And the more of one sort you take out, the more expensive it gets -
the less you get in return. So 100 depletes the pool a bit of As, so Bob doesn’t get the full factor 2 out, he gets a little bit less out. That’s exactly how this product formula works.</p>
<p>This also makes it ingenious, because it automatically accounts for supply and demand. If the next person also wants to swap 100A, they would get even less out.</p>
<p>The idea is if a lot of people want to put A in and want to get B in return, that means the demand for B is high. And that means the price of B in relation to A
should rise. And that is exactly what’s happening.</p>
<p>So the more people do a swap in this direction, put A in and get B out, the less of the gap because the price of B rises. If there were swaps in the other direction,
you would have the opposite effect.</p>
<p>If there’s an equal amount of swaps from A to B and B to A, then this ratio between the two amounts would stay roughly the same.</p>
<p>There’s an additional reason why Bob doesn’t get the full 200 that he might expect, and that is fees.</p>
<p>We want to incentivize Alice to set up the pool in the first place. She won’t just do that for fun, she wants to profit from it, so she wants to earn on swaps that people make.</p>
<p>The original product formula is modified a bit to insist that the product doesn’t only not decrease, but that it increases by a certain amount, a certain percentage,
depending on how much people swap. That’s 3% in this example of the 100A that Bob swaps, and it would be the same if you swap B instead.</p>
<p>This is basically added on top of this product, so anytime somebody swaps, not only does the product not decrease, it actually increases. And the more people swap, the more it increases.</p>
<p>The idea is that if Alice now would close the pool by burning her liquidity tokens, she gets all the remaining tokens in the pool and the product
would be higher than what she originally put in.</p>
<p>So that’s her incentive to set up the pool in the first place.</p>
<p>The next operation we look at is the add operation where somebody supplies the pool with additional liquidity.</p>
<div class="figure align-default">
<img alt="_images/pic__00153.png" src="_images/pic__00153.png" />
</div>
<p>So let’s say that Charlie also believes that the ratio from A to B should be 1:2 and he wants to contribute 400A and 800B.</p>
<p>He could also have tokens in a different ratio; the ratio reflects his belief in the true relative value of the tokens.</p>
<p>So Charlie wants to add 400 As and 800 Bs, and he creates a transaction with two inputs and two outputs. The inputs are the pool and his contribution,
his additional liquidity, and the outputs are the updated pool where now his As and Bs have been added to the pool tokens. Note that now the datum has changed.</p>
<p>So we had 1415 liquidity tokens before, and now we have 1982, and the difference, the 567, go to Charlie. So that’s the second output of this transaction, and that’s the reward to Charlie for providing this liquidity.</p>
<p>And there the formula is a bit complicated, but in principle, it also works with the product. So you check how much the product was before and after the tokens
have been added and you take into account the number that have already been minted. That also ensures that now basically Alice profits from the fees that Bob
paid with the swap and Charlie doesn’t.</p>
<p>The specific formula doesn’t matter. The idea is just that it’s fair.</p>
<p>So people should receive liquidity tokens proportional to their contribution, but, if they only add liquidity after a couple of swaps have already happened,
then they shouldn’t profit from the fees that have accumulated in the meantime.</p>
<p>The next operation we look at is called <em>remove</em> and it allows owners of liquidity tokens for a pool to burn some of them.</p>
<div class="figure align-default">
<img alt="_images/pic__00154.png" src="_images/pic__00154.png" />
</div>
<p>So in this example, let’s assume that Alice wants to burn all her liquidity tokens. She could also keep some, she doesn’t have to burn all, but in this example, she wants
to burn all her 1415 liquidity tokens.</p>
<p>So for that, she creates another transaction with two inputs and two outputs, the inputs are the liquidity token she wants to burn and, of course,
the pool again with the <em>remove</em> redeemer.</p>
<p>The outputs are the tokens from the pool that she receives in return, so in this case, she would get 1078A and 1869B. The second output is the updated pool.</p>
<p>So the 1078A and 1869B have been removed from the pool and the datum has been updated, so the 1415 liquidity tokens that Alice burnt are now subtracted
from the 1982 we had before. We see that 567 are remaining which are exactly those that Charlie owns.</p>
<p>The formula for how many tokens Alice gets for burning liquidity tokens is again somewhat complicated, but it’s basically just proportional.</p>
<p>So we know how many liquidity tokens there are in total, 1982, from the datum. And she basically just gets 1415:1982 of the pool. And she gets the tokens in the ratio that they are in now.</p>
<p>So the 1072:1869 should be the same ratio as the 1500:2619 which means that by burning, you don’t change the ratio of the pool.</p>
<p>The last operation is <em>close</em> and it is for completely closing a pool and removing it.</p>
<div class="figure align-default">
<img alt="_images/pic__00155.png" src="_images/pic__00155.png" />
</div>
<p>This can only happen when the last remaining liquidity tokens are burnt.</p>
<p>So in our example, Charlie holds all the remaining 567 liquidity tokens and therefore he can close down the pool.</p>
<p>In order to do that, he creates a transaction with three inputs. One is the factory. Note that we only involve the factory when we create the
pool and now when we close it again, which also means that the contention on the factory is not very high.</p>
<p>So the factory only gets involved when new pools are created and when pools are closed down, but once they exist and as long as they are not closed, the
operations are independent of the factory.</p>
<p>We just need the factory when we want to update the list of existing pools, and by the way, this list is used to ensure that there won’t be duplicate pools. So
the create operation that we looked at in the beginning will fail if somebody tries to create a pool that already exists for a pair of tokens that already exist.</p>
<p>Okay, so let’s go back to the <em>close</em> operation.</p>
<p>So the first input is the factory with the <em>close</em> redeemer, second the input is the pool that we want to close. And third input is
all the remaining liquidity tokens.</p>
<p>We get two outputs, one is the updated factory. In this case we only had one pool, so the list only contains this one pool, and this is now removed from the
list. The second output contains of all the remaining tokens, all the tokens that are still in the pool when it gets closed down.</p>
<p>So the remaining liquidity tokens are burnt and Charlie gets all the remaining tokens from the pool.</p>
</div>
<div class="section" id="uniswap-in-plutus">
<h3><span class="section-number">1.10.2. </span>Uniswap in Plutus<a class="headerlink" href="#uniswap-in-plutus" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default">
<img alt="_images/pic__00156.png" src="_images/pic__00156.png" />
</div>
<p>Code for Uniswap is actually part of the Plutus repository and it is in the plutus-usecases library, split into four modules that are imported by the
Plutus.Contracts.Uniswap module - OnChain, OffChain, Types and Pool.</p>
<p>So as the names suggest, OnChain contains the on-chain validation, OffChain contains the off-chain contracts, Types contains common types, and
Pool contains the business logic, the calculations, how many liquidity tokens the creator of a pool gets, how many tokens you get when you add liquidity
to a pool, how many tokens you get back when you burn liquidity tokens and under which conditions a swap is valid.</p>
<p>We won’t go through all of that in too much detail. It contains nothing we haven’t talked about before, but let’s at least have a brief look.</p>
<p>So let’s look at the Types module first.</p>
<div class="figure align-default">
<img alt="_images/pic__00157.png" src="_images/pic__00157.png" />
</div>
<p><em>U</em> represents the Uniswap coin, the one that identifies the factory.</p>
<div class="figure align-default">
<img alt="_images/pic__00158.png" src="_images/pic__00158.png" />
</div>
<p><em>A</em> and <em>B</em> are used for pool operations where we have these two sorts of tokens inside the pool.</p>
<div class="figure align-default">
<img alt="_images/pic__00160.png" src="_images/pic__00160.png" />
</div>
<p><em>PoolState</em> is the token that identifies a pool, actually in the diagram earlier I said it’s an NFT. By definition, an NFT is something that only
exists once. Actually here in the implementation for each pool, an identical coin is created that identifies that pool. So it’s not strictly speaking an NFT.</p>
<p>All the liquidity pools have one coin of that sort.</p>
<div class="figure align-default">
<img alt="_images/pic__00161.png" src="_images/pic__00161.png" />
</div>
<p><em>Liquidity</em> is used for the liquidity tokens that the liquidity providers get.</p>
<div class="figure align-default">
<img alt="_images/pic__00162.png" src="_images/pic__00162.png" />
</div>
<p>And all these types are then used in the coin A type. So A is a type parameter, that’s a so-called <em>phantom</em> type. So that means it has no
representation at run time. It’s just used to not mix up the various coins to make it easier to see what goes where, so in the datum, a coin
is simply an asset class that we have seen before. Recall that <em>AssetClass</em> is a combination of currency symbol and token name.</p>
<div class="figure align-default">
<img alt="_images/pic__00163.png" src="_images/pic__00163.png" />
</div>
<p>Then amount is just a wrapper around integer that also contains such a phantom type parameter, so that we don’t confuse amounts for token A and token B, for example.</p>
<div class="figure align-default">
<img alt="_images/pic__00164.png" src="_images/pic__00164.png" />
</div>
<p>Then we have some helper functions, for example <em>valueOf</em> for constructing a <em>Value</em> from <em>Coin</em> and <em>Amount</em>. Here, for example, we see the use of this phantom type.</p>
<p>That’s actually a common trick in Haskell because now if you have, for example, pool operations that have two different coins and two different amounts for the different coins.
And if the one is tagged with this type capital A and the other with capital B, then normally one could easily confuse them and somehow do operations with the one
coin, with the amount for the other, and then make a mistake.</p>
<p>And here the type system enforces that we don’t do that. So we can only use this value of function, for example, if we a coin and an amount with the same tag type tag.</p>
<p>So as I said, that’s a common trick in Haskell, some lightweight type level programming that doesn’t need any fancy GHC extensions.</p>
<p>The <em>unitValue</em> function creates one amount of the given coin and <em>isUnity</em> checks whether this coin is contained in the value exactly once,</p>
<p>Then <em>amountOf</em> checks how often the coin is contained in the value, and finally <em>mkCoin</em> turns a currency symbol into a token name, into a coin.</p>
<div class="figure align-default">
<img alt="_images/pic__00165.png" src="_images/pic__00165.png" />
</div>
<p>Then we have the Uniswap type which identifies the instance of the Uniswap system we are running. So of course, nobody can stop anybody
from setting up a competing Uniswap system with the competing factory, but the value of this type identifies a specific system.</p>
<p>And all the operations that are specific to pool will be parameterized by a value of this type, but it’s just a wrapper around the coin U. And that is just the NFT that identifies the factory.</p>
<div class="figure align-default">
<img alt="_images/pic__00166.png" src="_images/pic__00166.png" />
</div>
<p>Then we have a type for liquidity pools, and that is basically just two coins, the two coins in there.</p>
<p>However, there is one slight complication, only the two types of tokens inside the pool matter, not the order, there is no first or second token.</p>
<div class="figure align-default">
<img alt="_images/pic__00167.png" src="_images/pic__00167.png" />
</div>
<p>And in order to achieve that, the <em>Eq</em> instance has a special implementation. If we want to compare two liquidity pools, we don’t just
compare the first field with the first field of the other, and the second with the second, but we also try the other way round.</p>
<p>So liquidity pool tokens AB would be the same as liquidity pool with tokens BA. So that’s the only slight complication here.</p>
<div class="figure align-default">
<img alt="_images/pic__00168.png" src="_images/pic__00168.png" />
</div>
<p>Then we define the actions, that’s basically the redeemers. So <em>Create</em> with argument <em>LiquidityPool</em> is for creating a new liquidity
pool, <em>Close</em> is  for closing one, <em>Swap</em> is for swapping, <em>Remove</em> is for removing liquidity and <em>Add</em> is for adding liquidity.</p>
<p>Note that in the diagrams we saw earlier for simplicity, the redeemer was called simply <em>Create</em>.
So I didn’t mention this argument of type liquidity pool.</p>
<div class="figure align-default">
<img alt="_images/pic__00170.png" src="_images/pic__00170.png" />
</div>
<p>The datum is a bit more complex than we have seen before. It’s not just a simple integer or similarly simple type, it’s the type <em>UniswapDatum</em>.</p>
<p>There are two constructors, one for the factory and one for each pool. The factory will use the <em>Factory</em> constructor and the pool will use the <em>Pool</em> constructor.</p>
<p>And we saw before, the datum contains a list of all liquidity pools that currently exist. And the datum for <em>Pool</em> contains the <em>LiquidityPool</em> that we didn’t
see in the diagram. It also contains something we did see in the diagram, the amount of liquidity that has been minted for this pool. Remember that gets updated when somebody adds liquidity or removes liquidity.</p>
<div class="figure align-default">
<img alt="_images/pic__00172.png" src="_images/pic__00172.png" />
</div>
<p>Next let’s look at the <em>Pool</em> module, which as I explained before, contains the business logic, the calculations.</p>
<p>So we have <em>calculateInitialLiquidity</em>. It gets the initial amount of token A and B that are put into the pool and returns the liquidity tokens that are
returned in exchange for those.</p>
<p>Then <em>calculateAdditionalLiquidity</em> for the case that the pool already exists and somebody provides additional liquidity. So the first two
arguments are the amount of token already in there. Then the third one is the liquidity tokens that have already been minted for the pool. And
the next two arguments are how many As and Bs are added to the pool. The result is how many liquidity tokens will be minted in exchange
for this additional amount.</p>
<div class="figure align-default">
<img alt="_images/pic__00173.png" src="_images/pic__00173.png" />
</div>
<p>The <em>calculateRemoval</em> function is for the opposite case. So given how many tokens are in the pool, how many liquidity tokens have been minted, how many
liquidity tokens should be removed? It gives how many of tokens A and B remain in the pool.</p>
<p>Now <em>checkSwap</em> is arguably the central function of the whole Uniswap system. It calculates a swap.</p>
<p>This is how many As and Bs are originally in the pool and this says how many As and Bs there are after the swap in the pool. And it just returns whether that’s okay or not.</p>
<p>So in principle, it just checks that the product of the last two arguments is larger than the product of the first two.</p>
<p>And we noted before, it’s a bit more complicated because the fee is taken into account. So in this case, it’s 0.3% and you can see this is taking into account here.</p>
<div class="figure align-default">
<img alt="_images/pic__00175.png" src="_images/pic__00175.png" />
</div>
<p>It also makes sure that none of the amounts ever drops to zero. So it’s not allowed to remove all coins of one sort or of both from a pool.
That also makes sense because of this product, if one of the factors was zero, then of course it couldn’t be larger than it was before.</p>
<p>Finally, there’s this <em>lpTicker</em> function. It’s just a helper function that given a liquidity pool, computes a token name for the liquidity token. The idea
here is that this token name should only depend on the liquidity pool and should be unique. So each pair of tokens should result in a unique token name. In
principle it just takes the currency symbols and the token names of the two tokens or coins, concatenates all of them and hashes that, and then uses
the hash of the concatenation to get something unique.</p>
<p>A slight complication here is that again we must make sure that the order of coins in the pool doesn’t matter.</p>
<div class="figure align-default">
<img alt="_images/pic__00176.png" src="_images/pic__00176.png" />
</div>
<p>Now let’s look at the on-chain part. Only two functions are exported.</p>
<p>First <em>mkUniswapValidator</em>, to make the validator for the Uniswap, both factory and pools, because they share the same script address. They are just distinguished by the datum and by the coins that identify them.</p>
<p>Then <em>validateLiquidityForging</em> which is the monetary policy script for the liquidity tokens, but there is a lot of code in this module and we
don’t want to go through it in detail, let’s rather look at the structure.</p>
<div class="figure align-default">
<img alt="_images/pic__00178.png" src="_images/pic__00178.png" />
</div>
<p>So this is the <em>mkUniswapValidator</em> function. This function contains all the cases for factories and pools and the various redeemers.</p>
<p>And we have the function <em>validateLiquidityForging</em>, which is the monetary policy for liquidity tokens. The idea here is that it doesn’t contain
any logic and simply delegates the logic to the Uniswap validator. The way it does that is it checks the inputs of the forging transaction
and checks that it either contains a factory or contains a pool, because if it does, then we know that this validator will
run and then the validator can check that the forging is okay.</p>
<p>The way it checks whether either the factory or pool is an input is via the coins that identify a factory or pool. So it checks whether this
Uniswap factory coin is in the input or whether one of the pool coins is in the input.</p>
<p>And then we just have helper functions for all the various cases and they look quite long but it’s all straightforward. It’s basically what we saw
in the diagram, just spelled out in detail so that all these conditions are satisfied for all the different cases.</p>
<div class="figure align-default">
<img alt="_images/pic__00179.png" src="_images/pic__00179.png" />
</div>
<p>Finally, let’s look at the off-chain code.</p>
<div class="figure align-default">
<img alt="_images/pic__00181.png" src="_images/pic__00181.png" />
</div>
<p>No surprises here, it’s the usual boiler plate.</p>
<div class="figure align-default">
<img alt="_images/pic__00182.png" src="_images/pic__00182.png" />
</div>
<p>We define two different schemas. The idea is that one is for the entity that creates the Uniswap factory, and that only has one endpoint <em>start</em> and no parameters.</p>
<p>Then once that is created a second schema for people that make use of this Uniswap system, and all the contracts in here will be parameterized by the uniswap
instance that the first action creates.</p>
<div class="figure align-default">
<img alt="_images/pic__00183.png" src="_images/pic__00183.png" />
</div>
<p>We make use of the state mechanism this monad writer mechanism that is accessible via <em>tell</em>, and basically for all the user operations,
we have our own state, we call it <em>UserContractState</em>.</p>
<p>So there will be a helper contract that queries for all existing pools. So then the state would be using the <em>Pools</em> constructor and will return a
list of pools in a simplified form - it’s just a nested pair of pairs of coin and amount in each pool.</p>
<p>Now the helper function to query the existing funds of a wallet that will just return a value.</p>
<p>Then constructors for all the other operations. So  if they have happened, then one of those will be the state. For example, if we did a swap, then afterwards the status will be updated to swapped. If we removed liquidity, it will be updated to removed and so on.</p>
<div class="figure align-default">
<img alt="_images/pic__00184.png" src="_images/pic__00184.png" />
</div>
<p>Then some names for the various tokens, so “Uniswap” will be the token name of the NFT in the Uniswap factory, “Pool State” will be the token name for the
coins that identify the liquidity pools.</p>
<p>Then our usual boiler plate to actually get a script instance.</p>
<div class="figure align-default">
<img alt="_images/pic__00185.png" src="_images/pic__00185.png" />
</div>
<p>And the policy for the liquidity tokens.</p>
<p>Some various helper functions,</p>
<div class="figure align-default">
<img alt="_images/pic__00186.png" src="_images/pic__00186.png" />
</div>
<p>Then all the parameters for the endpoints. So, for example, if we want to create a pool we need to know the tokens and the amounts.</p>
<p>If you want to swap, it must know the tokens and how much to swap and the idea in the <em>SwapParams</em> datatype that one of the two last fields should be zero. So
if you want to put in A and get out B, we’ve would specify the <em>spAmountA</em> for how many As we want to put in, but we would leave the <em>spAmountB</em> at zero,
and the other way round if we want to swap Bs against As.</p>
<p><em>CloseParams</em> for if you want to close a pool - we just have to specify which pool. So we give the two tokens that are in there.</p>
<p><em>RemoveParams</em> - you have to specify the pool and how much liquidity we want to burn.</p>
<p><em>AddParams</em> - again, identify the pool and how many As and how many Bs we want to add.</p>
<div class="figure align-default">
<img alt="_images/pic__00188.png" src="_images/pic__00188.png" />
</div>
<p>Now here we have the implementation.</p>
<p>So <em>start</em>, as we saw, sets up the whole system and it again makes use of this other use case we have used before, the <em>Currency.forgeContract</em> to mint
the factory NFT that’s then used to identify the Uniswap factory.</p>
<div class="figure align-default">
<img alt="_images/pic__00189.png" src="_images/pic__00189.png" />
</div>
<p>The <em>create</em> contract is the contract that creates a liquidity pool. We see all of these will be, as we mentioned before, identified by the Uniswap value,
which is the result of this <em>start</em> contract here.</p>
<p>So we have <em>create</em>,</p>
<div class="figure align-default">
<img alt="_images/pic__00190.png" src="_images/pic__00190.png" />
</div>
<p>We have <em>close</em>, again parameterized by Uniswap,</p>
<div class="figure align-default">
<img alt="_images/pic__00191.png" src="_images/pic__00191.png" />
</div>
<p><em>remove</em> ,</p>
<div class="figure align-default">
<img alt="_images/pic__00192.png" src="_images/pic__00192.png" />
</div>
<p><em>add</em>,</p>
<div class="figure align-default">
<img alt="_images/pic__00193.png" src="_images/pic__00193.png" />
</div>
<p>and <em>swap</em>.</p>
<p>All these functions also make use of the functions from the <em>Pools</em> module, that contain the business logic. So that will be used both in the validator,
on the on-chain side, as well as on the off chain side in these contracts here.</p>
<div class="figure align-default">
<img alt="_images/pic__00194.png" src="_images/pic__00194.png" />
</div>
<p>The <em>pools</em> contract just queries the existing pools. So it looks for the factory UTxO and checks the datum, and, as we know,
the datum of the factory contains the list of all pools.</p>
<div class="figure align-default">
<img alt="_images/pic__00195.png" src="_images/pic__00195.png" />
</div>
<p>And finally <em>funds</em> just checks our own funds, the funds in the wallet, and returns them.</p>
<p>So these all return values but we want to write that in the state, and this is now done these endpoint definitions.</p>
<div class="figure align-default">
<img alt="_images/pic__00197.png" src="_images/pic__00197.png" />
</div>
<p>So first we have <em>ownerEndpoint</em> for setting up the whole system, which just uses the stop contract.</p>
<p>And then we have <em>userEndpoints</em>, which combine all these operations that a user can do.</p>
<p>Now there is no return value anymore, and instead we make use of the state. So we use the <em>Last</em> monoid again, so only the last <em>told</em> state will be kept.</p>
<p>And we also allow for error, so if there’s an error in one of these contracts, then we will catch that error, but use a <em>Left</em> to write it in the state. If there was no error we write the appropriate user contract state value in the state with the <em>Right</em> constructor of <em>Either</em>.</p>
<div class="figure align-default">
<img alt="_images/pic__00198.png" src="_images/pic__00198.png" />
</div>
<p>Finally, we also have a <em>stop</em> endpoint that simply stops, it doesn’t do anything. At any time you can invoke <em>stop</em> or one of the others,
and if it was one of the others then recursively <em>userEndpoints</em> is called again, but in the case of <em>stop</em> not, so if the <em>stop</em> endpoint
is ever called then the contract stops.</p>
<p>There are also tests for Uniswap contained in this Plutus use-cases library, but we won’t look at them now.</p>
<p>Let’s rather look at the Plutus PAB part and how you can write a front-end for Uniswap.</p>
<p>There is actually one also contained in the Plutus repo. It’s in the plutus-pab library and in the examples folder there’s a Uniswap folder that
contains an example on how to do that.</p>
<div class="figure align-default">
<img alt="_images/pic__00200.png" src="_images/pic__00200.png" />
</div>
<p>This has been copied it into our Plutus Pioneer Program repo and slightly modified it to make it more suitable for our purposes.</p>
<p>When we look at the Cabal file for this week’s code, there are two executables.</p>
<p>One uniswap-pab, which will run the PAB server, and then uniswap-client, which is a simple console based front-end for the Uniswap application.</p>
<div class="figure align-default">
<img alt="_images/pic__00201.png" src="_images/pic__00201.png" />
</div>
<p>You see, in the <em>other-modules</em> field there is a module Uniswap and that’s listed in both. That contains some common definitions that are used by both parts.</p>
<p>So let’s first look at that.</p>
<div class="figure align-default">
<img alt="_images/pic__00202.png" src="_images/pic__00202.png" />
</div>
<p>First of all, as we saw with oracle demo, we need some data type that captures the various instances we can run for the wallets. In this case, we have three.</p>
<p><em>Init</em> hasn’t been mentioned before, that has nothing specifically to do with Uniswap, this is just used to create some example tokens and distribute them in the beginning.</p>
<p><em>UniswapStart</em> corresponds to the Uniswap start or Uniswap owner schema that we saw just now for setting up the whole system.</p>
<p><em>UniswapUser</em> corresponds to the other part, to the various endpoints to interact with the system. And this class constructor is parameterized by a value of type Uniswap,
which is the result of starting. So after having started the system, the result would be of type Uniswap and this is then needed to parameterize the client.</p>
<div class="figure align-default">
<img alt="_images/pic__00203.png" src="_images/pic__00203.png" />
</div>
<p>Then there is some boiler plate, then this <em>initContract</em> function that distributes the initial funds. So it again makes use of <em>forgeContract</em> that we have seen before.</p>
<p>And it now produces tokens with token names A, B, C, D with 1 million of each. Actually it also multiplies that by the number of wallets. So in this case,
I want to use four wallets, wallets one to four, so it’s actually 4 million of each of the tokens that will be forged.</p>
<p>And once they have been forged, they are sent from the forging wallet to all the other wallets. So one wallet forges four million of each, and then loops over the other
wallets and sends them 1 million each.</p>
<p>So this is just needed to set up example tokens and distribute them amongst the wallets.</p>
<p>The <em>cidFile</em> function is just a helper function because in order to communicate the various contract instance IDs and other things we need, we
use helper files and this is function gives the file name for a given wallet.</p>
<div class="figure align-default">
<img alt="_images/pic__00205.png" src="_images/pic__00205.png" />
</div>
<p>So now let’s look at the PAB part.</p>
<p>First there is the boiler plate that we saw earlier to actually hook up the PAB mechanism with actual contracts. It uses the Uniswap contracts that we just
defined with the three constructors <em>Init</em>, <em>UniswapStart</em> and <em>UniswapUser</em>.</p>
<p>So, <em>UniswapUser</em> user will use the <em>UniswapUser</em> schema that we defined before, <em>UniswapStart</em> will use the <em>UniswapOwner</em> schema that we defined before and
<em>Init</em> will use a schema without endpoints.</p>
<p>And we connect these constructors with actual contracts. So <em>UniswapUser</em> with argument <em>us</em> will use the <em>userEndpoints</em> that we looked at earlier,
<em>UniswapStart</em> will use the <em>ownerEndpoint</em>, and <em>Init</em> will use the <em>initContract</em> that we just defined, and that’s just for demonstration to create these initial coins.</p>
<div class="figure align-default">
<img alt="_images/pic__00206.png" src="_images/pic__00206.png" />
</div>
<p>Now we can look at the main program.</p>
<p>So in the <em>Simulator</em> monad, we execute certain things. First we set up the whole system, we start the server and get the handle to shut it down again.</p>
<p>The first thing is that Wallet 1 activates the <em>Init</em> contract. We know from looking at the code what that will do, it will mint all these example tokens, ABCD,
4 million of each, and then distribute them so that wallets one to four end up with 1 million of each of the four different tokens.</p>
<p>This will concurrently start this contract, but then immediately continue - it won’t block - so we use the <em>waitForState</em> that we saw when
we talked about oracles, to wait until <em>Init</em> returns.</p>
<p>What <em>Init</em> will do is that it will write the currency symbol of the forged example tokens into the state. So we wait until we see that and then we
remember it and we wait until the <em>Init</em> contract has finished.</p>
<p>And then we write the currency symbol into the file <em>symbol.json</em>. We use the <em>encode</em> function from Data.Aeson, the json standard json library for Haskell.</p>
<p>Then again for Wallet 1, we start the Uniswap system. So we use the <em>UniswapStart</em> constructor and we again use <em>waitForState</em> to wait until we
get the result. The result of the <em>UniswapStart</em> as we saw earlier will be a value of type Uniswap, and we need that value in order to parameterize the user contracts.</p>
<p>So we wait until we get this, and call it <em>us</em>, and now Uniswap, the system is running and now we can start the user instances for all the wallets.</p>
<p>So we loop over all wallets and activate the <em>UniswapUser</em> contract which is now parameterized by the <em>us</em> value we got in the previous step here.</p>
<p>Now we have these handles and in order to interact, to communicate, from the front-end with the server, we need these handles. So we write them
into a file and this is where we use the helper function <em>cidFile</em> that we saw earlier.</p>
<p>So we will end up with four files <em>w1.cid</em> through to <em>w4.cid</em>, which contain these contract instance IDs for the four contracts.</p>
<p>Then we just wait until the user types a key and then we can shut down the server.</p>
<div class="figure align-default">
<img alt="_images/pic__00208.png" src="_images/pic__00208.png" />
</div>
<p>Let’s try this out with <em>cabal run uniswap-pab</em>.</p>
<p>A lot of stuff is happening. Remember, first we forge these example tokens ABCD, and then we need to distribute them to the other wallets.</p>
<p>Then we have to start the Uniswap system. And for that, we again have to first forge the Uniswap NFT that identifies the factory and then create the initial
UTxO for the factory that contains an empty list of pools.</p>
<div class="figure align-default">
<img alt="_images/pic__00209.png" src="_images/pic__00209.png" />
</div>
<p>Now we see that all the <em>UniswapUser</em> contracts have started for each of the the four wallets.</p>
<p>If we look, we see the various files, so we can look at those.</p>
<p>So <em>symbol.json</em> is the currency symbol of the example tokens and we need that to refer to them.</p>
<div class="figure align-default">
<img alt="_images/pic__00211.png" src="_images/pic__00211.png" />
</div>
<p>And then we have these <em>w1.cid</em> - <em>w4.cid</em> files. If you look at one of those, they hold the contract instance IDs for the contract instances for the four wallets.</p>
<p>We need these in order to find the correct HTTP endpoints to communicate with them.</p>
<div class="figure align-default">
<img alt="_images/pic__00212.png" src="_images/pic__00212.png" />
</div>
<p>Let’s look at the client next.</p>
<p>As for the oracle, this is also written that in Haskell using the same library for doing HTTP requests.</p>
<p>In the main program we expect one command line parameter, just a number from one to four, so that the main program knows for which wallet it’s running.</p>
<p>Then we read the corresponding CID file to get the contract instance ID for that wallet. We read this <em>symbol.json</em> file to get the currency symbol of
the example tokens. We use the <em>readFile</em> function the ByteString library, and <em>decode</em> comes from the Data.Aeson library to
decode the json back to Haskell data type.</p>
<p>We check whether there was an error, and if not, we invoke the <em>go</em> function where we pass the contract instance ID and the currency symbol.</p>
<div class="figure align-default">
<img alt="_images/pic__00213.png" src="_images/pic__00213.png" />
</div>
<p>And then it’s just a loop. We read a command from the console, and then depending on the command, we involve various helper functions. The
commands exactly correspond to the endpoints we have, except for stop, which is not implemented.</p>
<p>So we can query our funds, we can look for existing pools, we can create a pool, we can add liquidity to a pool, we can remove liquidity from
a pool, we can close a pool, and we can swap, which is the whole point.</p>
<p>So for each of those, we have a constructor in the <em>Command</em> data type.</p>
<p>Because the currency symbol will always be <em>cs</em> - our example tokens, we don’t need to parameterise the currency symbol. And because the
token names are just A, B, C and D we can just use a character for that.</p>
<p>So for example, <em>Create Integer Character Integer Character</em> means create a liquidity pool with a certain amount of a given token and
a certain amount of a second token.</p>
<div class="figure align-default">
<img alt="_images/pic__00214.png" src="_images/pic__00214.png" />
</div>
<p>The <em>readCommandIO</em> function reads from the keyboard and then tries to pass that as a command. If it fails it will just recursively call the read command again. If it
succeeds, it returns the command.</p>
<p>Then there are just various helper functions to convert something of type <em>Command</em> into the corresponding parameter types, like <em>CreateParams</em>
or <em>AddParams</em> from the Uniswap module that we saw earlier.</p>
<div class="figure align-default">
<img alt="_images/pic__00215.png" src="_images/pic__00215.png" />
</div>
<p>The functions <em>showCoinHeader</em> and <em>showCoin</em> are just to make it look a bit prettier when we query the funds or the pools, and then we have the various endpoints
and that all makes use of some helper functions.</p>
<div class="figure align-default">
<img alt="_images/pic__00216.png" src="_images/pic__00216.png" />
</div>
<p>There is <em>getStatus</em>, which we need in order to get something back from the contracts, and <em>callEndpoint</em> which uses the <em>Req</em> library, just as last time.</p>
<p>The interesting part is the request. It will be the post request, and we must give the instance ID. This is of type UUID, so we just convert
it into a string and then pack it to a text because this HTTP library expects <em>Text</em>.</p>
<p>The request body depends on the third argument in the function.</p>
<p>The response will always be <em>Unit</em> and we just check whether we get a 200 status code or not.</p>
<p>The <em>getStatus</em> is a get request that invokes the <em>status</em> HTTP endpoint, again with the CID.</p>
<p>We have to tell it what we’re dealing with so that’s why we need the <em>UniswapContracts</em> type, and that’s also why this Uniswap client executable also needs
access to this Uniswap module.</p>
<p>And then we just check if the state is empty, which happens right in the beginning because that is before anything has told anything to the state. Then we wait a
second and recurse and if there’s a state (if it’s <em>Just e</em>), then we know that this is of type <em>Either Text UserContractState</em>.</p>
<p>Recall this UserContractState had one constructor for each of the endpoints, but if there’s an error during contract execution, we get the error message as a <em>Text</em>.</p>
<p>And if something went wrong, then we end in the third case. With these two functions - <em>getStatus</em> and <em>getEndpoint</em> - it’s easy to write all the cases for the endpoints.</p>
<div class="figure align-default">
<img alt="_images/pic__00217.png" src="_images/pic__00217.png" />
</div>
<p>So let’s maybe look at one, <em>getFunds</em>. We use the <em>callEndpoint</em> helper function that we just saw. For the endpoint named “funds”, and in this case, the argument,
the request body, is just <em>Unit</em>.</p>
<p>We wait for two seconds and then use the <em>getStatus</em> helper function. If we get a <em>Right</em>, then we show the funds, otherwise we recurse.</p>
<p>So we wait until we get the <em>Right</em>, because in this case “funds” should never fail. There’s no way that can fail, therefore we can safely wait forever.</p>
<div class="figure align-default">
<img alt="_images/pic__00218.png" src="_images/pic__00218.png" />
</div>
<p>The <em>getPools</em> function is similar. It’s more or less the same, except that instead of “funds”, we have “pools”.</p>
<p>Let’s look at one more example, for creating a pool.</p>
<div class="figure align-default">
<img alt="_images/pic__00219.png" src="_images/pic__00219.png" />
</div>
<p>Again we call the endpoint and we wait for two seconds. Here something could actually go wrong. For example, if we try to create a pool where both
coins are the same, or if we specify a larger liquidity than exists in the wallet, then we would get an error.</p>
<p>So in this case, if we get an error, we just log it to the console.</p>
<p>The cases for all the other endpoints are very similar.</p>
</div>
<div class="section" id="trying-it-out">
<h3><span class="section-number">1.10.3. </span>Trying it Out<a class="headerlink" href="#trying-it-out" title="Permalink to this headline">¶</a></h3>
<p>Now let’s try it out.</p>
<p>Let’s start three instances for wallets one, two and three, and try to recreate the scenario from the diagrams at the beginning.</p>
<p>We start it simply by using <em>cabal run</em> with a command line parameter for the number of the wallet.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cabal</span> <span class="n">run</span> <span class="n">uniswap</span><span class="o">-</span><span class="n">client</span> <span class="c1">-- 1</span>
</pre></div>
</div>
<p>And we do the same for wallets 2 and 3.</p>
<div class="figure align-default">
<img alt="_images/pic__00220.png" src="_images/pic__00220.png" />
</div>
<p>Here we see the log messages for the contract instance ID and the symbol for token that we can use.</p>
<p>So what can we do?</p>
<p>We can, for example, query our funds.</p>
<div class="figure align-default">
<img alt="_images/pic__00221.png" src="_images/pic__00221.png" />
</div>
<p>And we see that we have A, B, C, D with 1 million each and 100,000 Ada.</p>
<p>We can also look for pools, but right now, there shouldn’t be any, and indeed none are listed.</p>
<div class="figure align-default">
<img alt="_images/pic__00222.png" src="_images/pic__00222.png" />
</div>
<p>So let’s switch to Wallet 1, let’s say this is Alice, Bob is 2 and Charlie is 3.</p>
<p>In the diagrams, we started with Alice setting up a liquidity pool for 1000 tokens A and 2000 B tokens.</p>
<p>So to do this here, we can type</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Create</span> <span class="mi">1000</span> <span class="sc">&#39;A&#39;</span> <span class="mi">2000</span> <span class="sc">&#39;B&#39;</span>
</pre></div>
</div>
<p>Remember that was of type <em>Char</em>, so we use single quotes.</p>
<p>We get the created status spec.</p>
<div class="figure align-default">
<img alt="_images/pic__00223.png" src="_images/pic__00223.png" />
</div>
<p>So it seems to have worked. We can query for pools again, and indeed there is one now.</p>
<div class="figure align-default">
<img alt="_images/pic__00224.png" src="_images/pic__00224.png" />
</div>
<p>We see that it has A and B and with the correct amounts, 1000 and 2000 respectively.</p>
<p>The next step was that Bob swaps 100A for Bs. So, in the console that is running Bob’s wallet, we can write</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Swap</span> <span class="mi">100</span> <span class="sc">&#39;A&#39;</span> <span class="sc">&#39;B&#39;</span>
</pre></div>
</div>
<p>Let’s check how many funds Bob now has. As expected, he has 100 fewer As and 181 as many Bs.</p>
<div class="figure align-default">
<img alt="_images/pic__00225.png" src="_images/pic__00225.png" />
</div>
<p>Next Charlie added liquidity.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Add</span> <span class="mi">400</span> <span class="sc">&#39;A&#39;</span> <span class="mi">800</span> <span class="sc">&#39;B&#39;</span>
</pre></div>
</div>
<p>Now we check the pools again.</p>
<p>It’s 1500 and 2619. We had 1000 at the beginning, then 100 where added by Bob and now 400 by Charlie.</p>
<div class="figure align-default">
<img alt="_images/pic__00226.png" src="_images/pic__00226.png" />
</div>
<p>Now, if we go back to Alice, she wants to remove her liquidity. So let’s first query her funds.</p>
<div class="figure align-default">
<img alt="_images/pic__00227.png" src="_images/pic__00227.png" />
</div>
<p>So she has less A and Bs now because she provided them as liquidity for the pool, but she has 1415 of the liquidity token.</p>
<p>So for example, she can burn the liquidity tokens and get tokens in exchange. She doesn’t have to burn all, but in the diagram she did.
So let’s do this, so</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Remove</span> <span class="mi">1415</span> <span class="sc">&#39;A&#39;</span> <span class="sc">&#39;B&#39;</span>
</pre></div>
</div>
<p>And let’s query her funds again.</p>
<div class="figure align-default">
<img alt="_images/pic__00228.png" src="_images/pic__00228.png" />
</div>
<p>So now she doesn’t have liquidity token anymore, but she got As and Bs back.</p>
<p>So she received 1869Bs and 1070 As.</p>
<p>The last step was that Charlie closes the pool. So let’s switch to Charlie</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Close</span> <span class="sc">&#39;A&#39;</span> <span class="sc">&#39;B&#39;</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="_images/pic__00229.png" src="_images/pic__00229.png" />
</div>
<p>And if now we look for pools, then again, we don’t get any. So it all seems to work.</p>
<p>Finally, we will look at how to use the front-end without Haskell and just use something like curl.</p>
<p>Let’s look at the file <em>status.sh</em> which you will find in the code folder.</p>
<div class="figure align-default">
<img alt="_images/pic__00230.png" src="_images/pic__00230.png" />
</div>
<p>This script expects one argument, that’s the wallet.</p>
<p>Then we just <em>curl</em> to this URL and interpolate the content of the correct wallet file given by the first parameter.</p>
<p>And because the output is very unwieldy, we pipe it through <em>jq</em> and get the current state and observable state of the resulting json.</p>
<p>So if I try this right now for Wallet 1, for example, we see that wallet one at the moment has these amounts of the tokens ABCD.</p>
<div class="figure align-default">
<img alt="_images/pic__00230.png" src="_images/pic__00230.png" />
</div>
<p>At least that was the last status. Maybe it’s not up to date.</p>
<p>Let’s also look at the <em>funds.sh</em> script.</p>
<div class="figure align-default">
<img alt="_images/pic__00231.png" src="_images/pic__00231.png" />
</div>
<p>So that again, only takes one parameter, one argument, the wallet, in order to put the correct instance ID in the URL, and then uses the <em>funds</em> endpoint.</p>
<p>And this is a POST request, so we need a request body. This is <em>Unit</em> because the funds endpoint doesn’t require any arguments except the <em>Unit</em> argument.</p>
<p>A bit more interesting is what to do with the post request that do have interesting arguments. For example, if now, Wallet 1 wants to create a pool
again with 1000A and 2000 B. In that case we need a request body for the correct parameters for the <em>CreateParams</em>.</p>
<p>So let’s look at this in <em>create.sh</em></p>
<div class="figure align-default">
<img alt="_images/pic__00232.png" src="_images/pic__00232.png" />
</div>
<p>In principle, the curl is simple, so now again, contract instance ID but now with endpoint <em>create</em>. But the question is what to write in this body.</p>
<p>We use similar arguments to in the Haskell implementation. So first the wallet and then the A amount, A token, B amount, and B token.</p>
<p>So maybe we should first check whether it works.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">create</span><span class="o">.</span><span class="n">sh</span> <span class="mi">1</span> <span class="mi">1000</span> <span class="kt">A</span> <span class="mi">2000</span> <span class="kt">B</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="_images/pic__00233.png" src="_images/pic__00233.png" />
</div>
<p>And now if we wait a few seconds and then query the status, it should have updated.</p>
<div class="figure align-default">
<img alt="_images/pic__00234.png" src="_images/pic__00234.png" />
</div>
<p>We can now run</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">status</span><span class="o">.</span><span class="n">sh</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="figure align-default">
<img alt="_images/pic__00235.png" src="_images/pic__00235.png" />
</div>
<p>Now we have this new liquidity pool with A and B.</p>
<p>So the remaining question is, how did we get the JSON body for the curl call? It’s hard to do this by hand, but if we look back at the Haskell output, what we
did was here, for example, for create, to always write the URL we are calling and also the request body.</p>
<p>And we can check the code for this. If we look at uniswap-client. It is in the helper function <em>callEndpoint</em> on lines 216 and 217.</p>
<div class="figure align-default">
<img alt="_images/pic__00237.png" src="_images/pic__00237.png" />
</div>
<p>So we get the <em>a</em>, that’s just a Haskell value with an instance of <em>ToJSON</em> so that can be encoded to JSON, and we just use encode from the Aeson library.
This is now a byte string, but in order to write that to the console, we need two strings, so we use something from the ByteString library</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Data</span><span class="o">.</span><span class="kt">ByteString</span><span class="o">.</span><span class="kt">Lazy</span><span class="o">.</span><span class="kt">Char8</span>
</pre></div>
</div>
<p>And we unpack this ByteString to a string and then log it. So this is a good way to figure out what requests bodies to use.</p>
<p>You don’t, of course, have to write a whole program, you can also do that in the REPL. You just need a value of the correct type and then use Aeson to
encode it and look at the result and then you see the shape of the json that is expected.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="alonzo_white.html" class="btn btn-neutral float-right" title="2. Alonzo White Walkthrough" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="index.html" class="btn btn-neutral float-left" title="Plutus Pioneer Program Video Notes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>