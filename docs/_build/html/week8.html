

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>9. Week 08 - Property Based Testing &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="8. Week 07 - State Machines" href="week7.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="week1.html">2. Week 01 - Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week2.html">3. Week 02 - Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week3.html">4. Week 03 - Script Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="week4.html">5. Week 04 - Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="week5.html">6. Week 05 - Native Tokens</a></li>
<li class="toctree-l1"><a class="reference internal" href="week6.html">7. Week 06 - Oracles</a></li>
<li class="toctree-l1"><a class="reference internal" href="week7.html">8. Week 07 - State Machines</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Week 08 - Property Based Testing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#token-sale">9.1. Token Sale</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#on-chain-code">9.1.1. On-chain code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#off-chain-code">9.1.2. Off-chain code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing">9.1.3. Testing</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">9. </span>Week 08 - Property Based Testing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week8.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-08-property-based-testing">
<h1><span class="section-number">9. </span>Week 08 - Property Based Testing<a class="headerlink" href="#week-08-property-based-testing" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://youtu.be/JMRwkMgaBOg">Lecture
#8</a>.</p>
<p>In this lecture we cover another state machine example, automatic testing using emulator traces, optics, and property-based testing.</p>
<p>This week we were using Plutus commit 530cc134364ae186f39fb2b54239fb7c5e2986e9, the same commit as we used in the last lecture.</p>
</div>
<div class="section" id="token-sale">
<h2><span class="section-number">9.1. </span>Token Sale<a class="headerlink" href="#token-sale" title="Permalink to this headline">¶</a></h2>
<p>In the last lecture we looked at state machines, and saw how they often allow us to write much less code to express the logic of a smart contract, partly because
there is a lot of sharing between on-chain and off-chain code and partly because a lot of boilerplate is encapsulated in the state machine machinery.</p>
<p>In this lecture we will see another example using a state machine, because the concept is very important. We will also take a look at testing.
First we will look at the code, then we will explore various ways to go about testing.</p>
<p>The example we will use is a contract that allows somebody to sell tokens. The idea is that someone call lock some tokens in a contract, set a price, and then
other people can buy them.</p>
<p>To begin, the seller starts with an NFT. It can be an arbitrary NFT and it will just be used, as before, to identify the correct UTxO that contains the contract state.</p>
<p>The first step is to lock the NFT at the script address of the smart contract that we are about to write. We’ll call that contract <em>TS</em> for Token Sale. As a datum, we will
use a simple integer, which will represent the price of the token we are selling, and this will start off as zero.</p>
<div class="figure align-default">
<img alt="_images/week08__00001.png" src="_images/week08__00001.png" />
</div>
<p>There will be several operations that the seller can do. One of those will be setting the price to a different value. In order to do that the seller will submit
a transaction which has the current UTxO as input and the updated UTxO as output, where the datum has been changed to a different price per token.</p>
<div class="figure align-default">
<img alt="_images/week08__00002.png" src="_images/week08__00002.png" />
</div>
<p>Another thing that the seller can do is to lock some tokens in the contract. In order to do that they have to create another transaction which has as input the UTxO of
the contract and a UTxO containing some tokens and, as output, the updated UTxO at the contract address which now contains the provided tokens.</p>
<div class="figure align-default">
<img alt="_images/week08__00003.png" src="_images/week08__00003.png" />
</div>
<p>In this example, the seller provides five tokens to the contract.</p>
<p>In order to buy tokens, there needs to be a transaction created by the buyer. This transaction has as input the UTxO sitting at the TS script address,
and the buying price in Ada.</p>
<p>So, if a buyer wants to buy two tokens, they will create a transaction that has, as input, 12 Ada, and the UTxO at the script address. Then, two outputs. One
the updated contract state where now the tokens are taken out and the Ada has been added, and one output going to the buyer with the tokens that they have just
bought.</p>
<div class="figure align-default">
<img alt="_images/week08__00004.png" src="_images/week08__00004.png" />
</div>
<p>Finally, there must be a way for the seller to retrieve tokens and Ada. In this example if, after the sale, the seller wants to retrieve all the Ada and one token, they
would create a transaction that, again, has the script UTxO as input, and, as output, the updated script UTxO with the reduced balances, and one to themselves with the
retrieved funds.</p>
<p>The diagram just shows one scenario, but these operations can be performed in any order - tokens can be added, the price can be changed, tokens can be bought, and so on,
in an arbitrary order.</p>
<div class="section" id="on-chain-code">
<h3><span class="section-number">9.1.1. </span>On-chain code<a class="headerlink" href="#on-chain-code" title="Permalink to this headline">¶</a></h3>
<p>This week’s first example is implemented in</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week08.TokenSale</span>
</pre></div>
</div>
<p>Let’s first look at the type that we will use as the parameter that we will use for the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TokenSale</span> <span class="ow">=</span> <span class="kt">TokenSale</span>
    <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>This has three fields - the seller’s public key has, the token being sold, and the NFT used to identify the UTxO.</p>
<p>For the redeemer, we provide exactly the operations we saw in the diagram</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TSRedeemer</span> <span class="ow">=</span>
      <span class="kt">SetPrice</span> <span class="kt">Integer</span>         <span class="c1">-- the price</span>
    <span class="o">|</span> <span class="kt">AddTokens</span> <span class="kt">Integer</span>        <span class="c1">-- the number of tokens to add</span>
    <span class="o">|</span> <span class="kt">BuyTokens</span> <span class="kt">Integer</span>        <span class="c1">-- the number of tokens to buy</span>
    <span class="o">|</span> <span class="kt">Withdraw</span> <span class="kt">Integer</span> <span class="kt">Integer</span> <span class="c1">-- first argument is the number of tokens, the second is the number of lovelace</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Again we have the helper function that we have used in previous examples</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>Now, we get to the <em>transition</em> function of the state machine. We see the <em>TokenSale</em> parameter which holds the state machines configuration values, the <em>State</em>
object with an <em>Integer</em> value to represent the price of the token, then the redeemer <em>TsRedeemer</em>. Again, we return a <em>Maybe</em>, which will be <em>Nothing</em> if the
corresponding transition is illegal, or, if it is legal, a <em>Just</em> containing constraints and the new state.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">transition</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">TSRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxConstraints</span> <span class="kt">Void</span> <span class="kt">Void</span><span class="p">,</span> <span class="kt">State</span> <span class="kt">Integer</span><span class="p">)</span>
<span class="nf">transition</span> <span class="n">ts</span> <span class="n">s</span> <span class="n">r</span> <span class="ow">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">stateValue</span> <span class="n">s</span><span class="p">,</span> <span class="n">stateData</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="kr">of</span>
</pre></div>
</div>
<p>If the <em>SetPrice</em> redeemer is provided, then we only consider it to be legal if the price is not negative. We then return a <em>Just</em> with the constraint that the
transaction must be signed by the token seller, and with the new state. The new state will be the new price <em>p</em>, and the <em>Value</em> in the contract
remains the same, except for one thing.</p>
<p>It is a little unfortunate, but there is a discrepancy between the <em>v</em> on the left and the <em>v</em> on the right. On the left it does not contain the NFT, but
on the right it does not. So, even though we want to say that we don’t want the value changed, in fact we have to remove the NFT, because the Plutus libraries will
add it again. This is perhaps not an ideal design, but that is how it currently is.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kt">SetPrice</span> <span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">tsSeller</span> <span class="n">ts</span><span class="p">)</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span> <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>We use a helper function to reference the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nft</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Value</span>
<span class="nf">nft</span> <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsNFT</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
<p>When adding tokens, we could check that the seller has signed the transaction, but this contract would be provided by the seller, and the seller doesn’t mind if someone
wants to give them a free gift! Therefore, once we have the <em>AddTokens</em> redeemer and <em>n</em> is greater than zero, we are happy to return the
new state without constraints.</p>
<p>The state that we return is untouched, except for the unfortunate trick we need to do with the NFT, and the addition of the new tokens.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">AddTokens</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                      <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="n">n</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>For the <em>BuyTokens</em> redeemer, again we check the number of tokens is positive, and again we don’t need any constraints, because anybody can buy tokens.</p>
<p>For the new state, we don’t touch the price. We again correct for the NFT. Then we subtract the tokens that were bought, and we add the lovelace that were paid for them.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">BuyTokens</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="n">mempty</span>
                                    <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                      <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                      <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                      <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">negate</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                      <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
                                    <span class="p">)</span>
</pre></div>
</div>
<p>Finally, for <em>WithDraw</em>, we insist that the token amount and the lovelace amount are both nonnegative. This time we again add a constraint that the seller must sign
the transaction. We modify the state in a similar way to the way we did for the <em>BuyTokens</em> redeemer, but this time we adjust the token and lovelace amounts according
to how much has been withdrawn.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="kt">Withdraw</span> <span class="n">n</span> <span class="n">l</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustBeSignedBy</span> <span class="p">(</span><span class="n">tsSeller</span> <span class="n">ts</span><span class="p">)</span>
                                                <span class="p">,</span> <span class="kt">State</span> <span class="n">p</span> <span class="o">$</span>
                                                  <span class="n">v</span>                                       <span class="o">&lt;&gt;</span>
                                                  <span class="n">nft</span> <span class="p">(</span><span class="n">negate</span> <span class="mi">1</span><span class="p">)</span>                          <span class="o">&lt;&gt;</span>
                                                  <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">tsToken</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">negate</span> <span class="n">n</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                                                  <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">negate</span> <span class="n">l</span><span class="p">)</span>
                                                <span class="p">)</span>
</pre></div>
</div>
<p>All other state transitions are illegal.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>In this example we are able to construct our state machine more simply that we could in the previous lecture. This is because, in the previous lecture we had one
condition that could not be expressed in the regular constraints.</p>
<p>In these situations, there is a helper function called <em>mkStateMachine</em> that takes three arguments. The first one is the state token, the second is the transition
function. The last one is to indicate which states are final. In this case, there is no final state. Once this token sale has been setup, it will always be there.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tsStateMachine</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">StateMachine</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>
<span class="nf">tsStateMachine</span> <span class="n">ts</span> <span class="ow">=</span> <span class="n">mkStateMachine</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">$</span> <span class="n">tsNFT</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">transition</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">const</span> <span class="kt">False</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now use the usual boilerplate to turn it into a Plutus smart contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TS</span> <span class="ow">=</span> <span class="kt">StateMachine</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>

<span class="nf">tsInst</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">TS</span>
<span class="nf">tsInst</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">TS</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkTSValidator</span> <span class="o">||</span><span class="p">])</span> <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">ts</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">Integer</span> <span class="o">@</span><span class="kt">TSRedeemer</span>

<span class="nf">tsValidator</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">tsValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">tsInst</span>

<span class="nf">tsAddress</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">tsAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">tsValidator</span>

<span class="nf">tsClient</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">StateMachineClient</span> <span class="kt">Integer</span> <span class="kt">TSRedeemer</span>
<span class="nf">tsClient</span> <span class="n">ts</span> <span class="ow">=</span> <span class="n">mkStateMachineClient</span> <span class="o">$</span> <span class="kt">StateMachineInstance</span> <span class="p">(</span><span class="n">tsStateMachine</span> <span class="n">ts</span><span class="p">)</span> <span class="p">(</span><span class="n">tsInst</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two helper functions to convert specialised error types to <em>Text</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mapErrorC</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">C</span><span class="o">.</span><span class="kt">CurrencyError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapErrorC</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>

<span class="nf">mapErrorSM</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">SMContractError</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="n">a</span>
<span class="nf">mapErrorSM</span> <span class="ow">=</span> <span class="n">mapError</span> <span class="o">$</span> <span class="n">pack</span> <span class="o">.</span> <span class="n">show</span>
</pre></div>
</div>
</div>
<div class="section" id="off-chain-code">
<h3><span class="section-number">9.1.2. </span>Off-chain code<a class="headerlink" href="#off-chain-code" title="Permalink to this headline">¶</a></h3>
<p>For the off-chain code, we start by defining a constant for the token name of the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nftName</span> <span class="ow">::</span> <span class="kt">TokenName</span>
<span class="nf">nftName</span> <span class="ow">=</span> <span class="s">&quot;NFT&quot;</span>
</pre></div>
</div>
<p>The first contract we define is to start the token sale. This contract is designed to be invoked by the seller.</p>
<p>This first argument is a <em>Maybe CurrencySymbol</em>. The idea here is that if you pass in <em>Nothing</em>, the contract will mint a new NFT. Alternatively, you can provide a
<em>Just CurrencySymbol</em> if the token already exists. We have done it this way mainly to make testing easier.</p>
<p>The <em>AssetClass</em> argument is the token the seller wants to trade.</p>
<p>For the return type, we are using the writer monad type with the <em>Last</em> type. The ideas is that once the token sale has been setup, it will get written here so that other
contracts are able to discover it. In addition, we return the created token sale.</p>
<p>To begin, we lookup the seller’s public key hash. We then need to get hold of the NFT. So, we determine if we need to mint the NFT, and, if we do, we mint it, otherwise we just use the one that was
passed into the function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startTS</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="kt">CurrencySymbol</span> <span class="ow">-&gt;</span> <span class="kt">AssetClass</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="n">s</span> <span class="kt">Text</span> <span class="kt">TokenSale</span>
<span class="nf">startTS</span> <span class="n">mcs</span> <span class="n">token</span> <span class="ow">=</span> <span class="kr">do</span>

    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="n">cs</span>  <span class="ow">&lt;-</span> <span class="kr">case</span> <span class="n">mcs</span> <span class="kr">of</span>
        <span class="kt">Nothing</span>  <span class="ow">-&gt;</span> <span class="kt">C</span><span class="o">.</span><span class="n">currencySymbol</span> <span class="o">&lt;$&gt;</span> <span class="n">mapErrorC</span> <span class="p">(</span><span class="kt">C</span><span class="o">.</span><span class="n">forgeContract</span> <span class="n">pkh</span> <span class="p">[(</span><span class="n">nftName</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="kt">Just</span> <span class="n">cs&#39;</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">cs&#39;</span>
</pre></div>
</div>
<p>And now we can define the <em>TokenSale</em> and create the state machine client.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">ts</span> <span class="ow">=</span> <span class="kt">TokenSale</span>
        <span class="p">{</span> <span class="n">tsSeller</span> <span class="ow">=</span> <span class="n">pkh</span>
        <span class="p">,</span> <span class="n">tsToken</span>  <span class="ow">=</span> <span class="n">token</span>
        <span class="p">,</span> <span class="n">tsNFT</span>    <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">nftName</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="n">client</span> <span class="ow">=</span> <span class="n">tsClient</span> <span class="n">ts</span>
</pre></div>
</div>
<p>We then use the <em>runInitialise</em> function that we discussed in the last lecture, using the client, an initial price of zero, and no initial funds, except for the NFT
which will be automatically added.</p>
<p>We write the <em>ts</em> into the log, then log a message, and return the <em>ts</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runInitialise</span> <span class="n">client</span> <span class="mi">0</span> <span class="n">mempty</span>
<span class="nf">tell</span> <span class="o">$</span> <span class="kt">Last</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">ts</span>
<span class="nf">logInfo</span> <span class="o">$</span> <span class="s">&quot;started token sale &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">ts</span>
<span class="nf">return</span> <span class="n">ts</span>
</pre></div>
</div>
<p>The functions for all the other operations are extremely short. This example is ideal for the state machine approach.</p>
<p>They are all very similar. They all invoke <em>runStep</em> and then invoke the correct transition from the state machine.</p>
<p>For example, for <em>setPrice</em>, we need the <em>TokenSale</em> argument to identify the correct contract and the new value of the price. Then we use <em>runStep</em> using the client and
<em>SetPrice</em> as the redeemer. We wrap that using <em>mapErrorSM</em> to convert to <em>Text</em> error messages, and we ignore the result.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">setPrice</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">setPrice</span> <span class="n">ts</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">SetPrice</span> <span class="n">p</span>
</pre></div>
</div>
<p>The remaining three follow the same pattern.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">addTokens</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">addTokens</span> <span class="n">ts</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">void</span> <span class="p">(</span><span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">AddTokens</span> <span class="n">n</span><span class="p">)</span>

<span class="nf">buyTokens</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">buyTokens</span> <span class="n">ts</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">BuyTokens</span> <span class="n">n</span>

<span class="nf">withdraw</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">withdraw</span> <span class="n">ts</span> <span class="n">n</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">mapErrorSM</span> <span class="o">$</span> <span class="n">runStep</span> <span class="p">(</span><span class="n">tsClient</span> <span class="n">ts</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Withdraw</span> <span class="n">n</span> <span class="n">l</span>
</pre></div>
</div>
<p>Now we define three schemas.</p>
<p>One for the seller which just has one endpoint which takes the <em>CurrencySymbol</em> and the <em>TokenName</em> of the asset to be traded.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSStartSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
    <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>For testing purposes, we create <em>TSStartSchema’</em> which additionally takes the <em>CurrencySymbol</em> of the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSStartSchema&#39;</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
    <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;start&quot;</span>      <span class="p">(</span><span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">CurrencySymbol</span><span class="p">,</span> <span class="kt">TokenName</span><span class="p">)</span>
</pre></div>
</div>
<p>Lastly we have a <em>use</em> schema, with endpoints for the four operations - set price, add tokens, buy tokens and withdraw.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">TSUseSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;set price&quot;</span>  <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;add tokens&quot;</span> <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;buy tokens&quot;</span> <span class="kt">Integer</span>
  <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;withdraw&quot;</span>   <span class="p">(</span><span class="kt">Integer</span><span class="p">,</span> <span class="kt">Integer</span><span class="p">)</span>
</pre></div>
</div>
<p>Now to implement the start endpoint. It simply calls <em>startTs’</em> and recurses. <em>startTs’</em> blocks until the parameters are provided and then calls <em>startTs</em> with
<em>Nothing</em>, indicating that the NFT has to be minted. We wrap it in <em>handleError</em> and if there is an error, we simply log that error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startEndpoint</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">startEndpoint</span> <span class="ow">=</span> <span class="n">startTS&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">startEndpoint</span>
  <span class="kr">where</span>
    <span class="n">startTS&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">void</span> <span class="o">.</span> <span class="n">startTS</span> <span class="kt">Nothing</span> <span class="o">.</span> <span class="kt">AssetClass</span>
</pre></div>
</div>
<p>The <em>startEndpoint’</em> function is very similar, but we add the NFT parameter, as per <em>TSStartSchema’</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">startEndpoint&#39;</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="p">(</span><span class="kt">Last</span> <span class="kt">TokenSale</span><span class="p">)</span> <span class="kt">TSStartSchema&#39;</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">startEndpoint&#39;</span> <span class="ow">=</span> <span class="n">startTS&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">startEndpoint&#39;</span>
  <span class="kr">where</span>
    <span class="n">startTS&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;start&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="p">(</span><span class="n">cs1</span><span class="p">,</span> <span class="n">cs2</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span> <span class="ow">-&gt;</span>  <span class="n">void</span> <span class="o">$</span> <span class="n">startTS</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">cs1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">cs2</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span>
</pre></div>
</div>
<p>No surprises in the <em>use</em> endpoints. We give a choice between the four endpoints and just call the functions we defined earlier with the arguments fed in
from the endpoint call, and with everything wrapped inside an error handler so that the contract won’t crash in the event of an error.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">useEndpoints</span> <span class="ow">::</span> <span class="kt">TokenSale</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">TSUseSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">useEndpoints</span> <span class="n">ts</span> <span class="ow">=</span> <span class="p">(</span><span class="n">setPrice&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">addTokens&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">buyTokens&#39;</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">withdraw&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">useEndpoints</span> <span class="n">ts</span>
  <span class="kr">where</span>
    <span class="n">setPrice&#39;</span>  <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;set price&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">setPrice</span> <span class="n">ts</span>
    <span class="n">addTokens&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;add tokens&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">addTokens</span> <span class="n">ts</span>
    <span class="n">buyTokens&#39;</span> <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;buy tokens&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">buyTokens</span> <span class="n">ts</span>
    <span class="n">withdraw&#39;</span>  <span class="ow">=</span> <span class="n">handleError</span> <span class="n">logError</span> <span class="o">$</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;withdraw&quot;</span>   <span class="o">&gt;&gt;=</span> <span class="n">uncurry</span> <span class="p">(</span><span class="n">withdraw</span> <span class="n">ts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="testing">
<h3><span class="section-number">9.1.3. </span>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h3>
<p>In order to try it out, let’s run it in the emulator.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week7.html" class="btn btn-neutral float-left" title="8. Week 07 - State Machines" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>