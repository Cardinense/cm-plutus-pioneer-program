

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>8. Week 07 - State Machines &mdash; Plutus Pioneer Program Lecture Notes  documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="7. Week 06 - Oracles" href="week6.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Plutus Pioneer Program Lecture Notes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="week1.html">2. Week 01 - Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week2.html">3. Week 02 - Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week3.html">4. Week 03 - Script Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="week4.html">5. Week 04 - Monads</a></li>
<li class="toctree-l1"><a class="reference internal" href="week5.html">6. Week 05 - Native Tokens</a></li>
<li class="toctree-l1"><a class="reference internal" href="week6.html">7. Week 06 - Oracles</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Week 07 - State Machines</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">8.1. Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#code-example-1">8.1.1. Code Example 1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#on-chain">8.1.1.1. On chain</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#code-example-2">8.1.2. Code Example 2</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Plutus Pioneer Program Lecture Notes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">8. </span>Week 07 - State Machines</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/week7.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="week-07-state-machines">
<h1><span class="section-number">8. </span>Week 07 - State Machines<a class="headerlink" href="#week-07-state-machines" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a written version of <a class="reference external" href="https://www.youtube.com/watch?v=oJupInqvJUI">Lecture
#7</a>.</p>
<p>It covers commit schemes and state machines.</p>
<p>This week we were using Plutus commit 530cc134364ae186f39fb2b54239fb7c5e2986e9</p>
</div>
<div class="section" id="introduction">
<h2><span class="section-number">8.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this lecture we will look at state machines. State machines can be very useful to shorter and more concise contracts, both on-chain and off-chain. There is higher level support for state machines in the Plutus libraries that builds on top of the lower level mechanisms we have seen so far.</p>
<p>As a running example, we are going to implement a little game, played between Alice and Bob. It’s a bit like Rock, Paper, Scissors, but even simpler, because there are
only two options.</p>
<p>Alice and Bob both have two options, they can either play 0 or 1.</p>
<div class="figure align-default">
<img alt="_images/week07__00000.png" src="_images/week07__00000.png" />
</div>
<p>If there were to play this game while being physically in the same room, they would make their moves at the same time. There would be one gesture for 0 and one
gesture for 1, they would raise their hands simultaneously, and, depending on what they play, one of them wins.</p>
<p>If they both play the same number, Alice wins. If they play different numbers, Bob wins.</p>
<div class="figure align-default">
<img alt="_images/week07__00001.png" src="_images/week07__00001.png" />
</div>
<p>Now let’s imagine that Alice and Bob can’t meet in person but that they still want to play the game. So, they decide to play it via mail - email or snail mail, it doesn’t
matter. How would that work?</p>
<p>Alice could send her move to Bob.</p>
<div class="figure align-default">
<img alt="_images/week07__00004.png" src="_images/week07__00004.png" />
</div>
<p>This, however, gives a very unfair advantage to Bob, because now he opens Alice’s mail, see that she has played 0, and he can simply reply with 1, and he wins.</p>
<div class="figure align-default">
<img alt="_images/week07__00003.png" src="_images/week07__00003.png" />
</div>
<p>And, if Alice plays 1, Bob can simply respond with 1. So Bob always wins, at least if he is unfair.</p>
<div class="figure align-default">
<img alt="_images/week07__00005.png" src="_images/week07__00005.png" />
</div>
<p>What can we do about that?</p>
<p>There’s a very clever trick which is often used in cryptographic protocols, and that is commit schemes. The idea is that Alice doesn’t reveal her choice to Bob, but she commits to it, so that she cannot later change her mind.</p>
<p>One way to make that work is using hash functions.</p>
<p>Hashes are all over the place in the blockchain world. We have seen that script addresses are just the hash of the Plutus code script, and we have seen lots of examples of
public key hashes.</p>
<p>A hash function is a one-way function. Given a hash, tt is difficult, or impossible, to reconstruct the original byte string that was hashed.</p>
<p>So, one way we could try to make this work is that, instead of Alice sending her choice to Bob, she instead sends the hash of her choice.</p>
<div class="figure align-default">
<img alt="_images/week07__00006.png" src="_images/week07__00006.png" />
</div>
<p>Bob then sees this cryptic byte string and he has no idea whether Alice picked 0 or 1.</p>
<p>Bob then replies with his move, picking, for example 0. There is no need for him to use a hash, he can just send his response in clear text.</p>
<p>Now, Alice would have won. But perhaps Bob doesn’t believe her. So there is one additional step that Alice has to take.</p>
<p>Alice has to send her actual choice to Bob in clear text. Bob then has to check that the hash of her choice is indeed the same as the hash Alice sent earlier.</p>
<div class="figure align-default">
<img alt="_images/week07__00007.png" src="_images/week07__00007.png" />
</div>
<p>If it is, then he knows sees that Alice is not lying and that indeed he lost. If it does not match, then he knows that Alice is cheating and he would win.</p>
<p>This all sounds promising, but there is one big problem with it.</p>
<p>In this game there are only two choices, 0 and 1. Which means that there are only two possible hashes. They may look very cryptic to Bob the first time they play,
but before long he will notice that he always sees one of only two possible hashes, and then he can know which choice Alice made.</p>
<p>This is almost as bad as if Alice had just sent her choice in clear text.</p>
<p>What we can do about this is that, instead of sending the hash of her choice, she instead first selects an arbitrary byte string and then hashes the
concatenated of this byte string and her choice. The arbitrary byte string that Alice chooses is called a <em>nonce</em> - a number to be used just once.</p>
<div class="figure align-default">
<img alt="_images/week07__00008.png" src="_images/week07__00008.png" />
</div>
<p>So now, it is not always the same byte string if she picks 0, provided she chooses some random, unpredictable nonce.</p>
<p>Now, Bob receives this and we proceed as before - Bob sends his choice, and then, in the third message Alice needs to send not only her original choice, but she also
has to send the nonce as well.</p>
<div class="figure align-default">
<img alt="_images/week07__00010.png" src="_images/week07__00010.png" />
</div>
<p>And then Bob checks that the hash of Alice’s claimed nonce concatenated with her choice is indeed the hash that he originally received. If it is, he knows he lost, and
if it is not, he knows that she tried to cheat him.</p>
<p>This works very nicely and this is what we will try to implement in Cardano. First we will do it using techniques we have already seen, and then we will see how, by using
state machines, the code can be much clearer and much shorter.</p>
<div class="section" id="code-example-1">
<h3><span class="section-number">8.1.1. </span>Code Example 1<a class="headerlink" href="#code-example-1" title="Permalink to this headline">¶</a></h3>
<p>We can imagine that, at the start of the game, Alice and Bob have put down the same amount of money each and that the winner will take it all.</p>
<p>The game starts with Alice posting her hash, as described above. Bob, if he plays along, will post his own choice. At this point, we have Alice’s hash and Bob’s choice.</p>
<div class="figure align-default">
<img alt="_images/week07__00011.png" src="_images/week07__00011.png" />
</div>
<p>If, at this point, Alice realizes that she has won, based on Bob’s choice, she can reveal her secret, the game ends, and she has won.</p>
<div class="figure align-default">
<img alt="_images/week07__00012.png" src="_images/week07__00012.png" />
</div>
<p>If, however, after Bob makes his move, Alice sees that she has lost, there is no need for her to do anything. After a certain deadline has been reached, if Alice has
not responded, Bob will be able to claim the funds.</p>
<div class="figure align-default">
<img alt="_images/week07__00013.png" src="_images/week07__00013.png" />
</div>
<p>There is a scenario. Perhaps, after Alice starts playing, Bob simply isn’t interested. In this case, there must be a way for Alice to get her own money back.</p>
<div class="figure align-default">
<img alt="_images/week07__00016.png" src="_images/week07__00016.png" />
</div>
<p>As mentioned, our first attempt at coding this in Plutus will be using the techniques we have learned in previous lectures.</p>
<p>The code we are working with is in the following module</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Week07.EvenOdd</span>
</pre></div>
</div>
<p>We call the game <em>EvenOdd</em> due to the fact that if the sum of the numbers is even, then the first player wins, and if the sum is odd, the second player wins.</p>
<p>In our code we will call the players <em>first</em> and <em>second</em> rather than Alice and Bob.</p>
<div class="section" id="on-chain">
<h4><span class="section-number">8.1.1.1. </span>On chain<a class="headerlink" href="#on-chain" title="Permalink to this headline">¶</a></h4>
<p>We define a data type <em>Game</em> which will be used as a parameter for the contract.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Game</span> <span class="ow">=</span> <span class="kt">Game</span>
    <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">AssetClass</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>The players are identified by their public key hashes as <em>gFirst</em> and <em>gSecond</em>.</p>
<p>The number of lovelace to be used as stake in the game is represented by <em>gStake</em> - This stake must be provided by each player.</p>
<p>There are two deadlines. The <em>gPlayDeadline</em> is the slot by which the second player must make their move. In the case where the second player has made a move,
the <em>gRevealDeadline</em> is the slot by which player 1 must claim victory by revealing his nonce.</p>
<p>Finally we have a token represented by <em>gToken</em>. This will be the same trick that we used for the oracle. It will be an arbitrary NFT, used to identify the right
instance of the UTxO that we are using. The idea is to use the datum sitting at a UTxO in this contract’s script address to keep track of where we are in the game.</p>
<p>Next, we define the two moves that the players can make.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameChoice</span> <span class="ow">=</span> <span class="kt">Zero</span> <span class="o">|</span> <span class="kt">One</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Prelude</span><span class="o">.</span><span class="kt">Ord</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameChoice</span> <span class="kr">where</span>
    <span class="cm">{-# INLINABLE (==) #-}</span>
    <span class="kt">Zero</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">One</span>  <span class="o">==</span> <span class="kt">One</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span>    <span class="o">==</span> <span class="kr">_</span>    <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>We need Plutus <em>Eq</em> for the instance, but it is not possible to declare that in the deriving clause, which is why the <em>Eq</em> in the deriving clause is qualified as being
from the standard Haskell Prelude.</p>
<p>Note that we have used the <em>INLINABLE</em> pragma on the <em>Eq</em> instance for <em>GameChoice</em>. This is again to make it compatible with the Template Haskell we will need to
use.</p>
<p>For state, we will use a type called <em>GameDatum</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameDatum</span> <span class="ow">=</span> <span class="kt">GameDatum</span> <span class="kt">ByteString</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">GameChoice</span><span class="p">)</span>
<span class="kr">deriving</span> <span class="kt">Show</span>

<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">GameDatum</span> <span class="kr">where</span>
    <span class="cm">{-# INLINABLE (==) #-}</span>
    <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="n">mc</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs&#39;</span> <span class="n">mc&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">bs</span> <span class="o">==</span> <span class="n">bs&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mc</span> <span class="o">==</span> <span class="n">mc&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the <em>ByteString</em> is the hash that the first player submits, and <em>Maybe GameChoice</em> is either <em>Just</em> the move of the second player, or <em>Nothing</em>, if they have not yet moved.</p>
<p>Now we come to the redeemer, and we will use a custom type for this as well.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">GameRedeemer</span> <span class="ow">=</span> <span class="kt">Play</span> <span class="kt">GameChoice</span> <span class="o">|</span> <span class="kt">Reveal</span> <span class="kt">ByteString</span> <span class="o">|</span> <span class="kt">ClaimFirst</span> <span class="o">|</span> <span class="kt">ClaimSecond</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>Here <em>Play</em> is where the second player moves and, as an argument, it has a <em>GameChoice</em>. <em>Reveal</em> is for the case where the first player has won and must prove that
by revealing their nonce, and the nonce is represented by the <em>ByteString</em> argument. We don’t need to include the move for the <em>Reveal</em>, as they will only reveal if they
have won, and we know what move makes them win.</p>
<p><em>ClaimFirst</em> is when the first player claims back the stake in the even that the second player does not make a move by the play deadline. <em>ClaimSecond</em> is for the
case when the first player does not reveal by the reveal deadline.</p>
<p>We then have our <em>lovelaces</em> helper function which we have used in other scripts, which gets the number of lovelaces held in a <em>Value</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lovelaces</span> <span class="ow">::</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">lovelaces</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">getLovelace</span> <span class="o">.</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">fromValue</span>
</pre></div>
</div>
<p>And we have a helper function <em>gameDatum</em> which behaves exactly the same way as the function <em>oracleValue</em>, which you can find in the notes from lecture 6.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameDatum</span> <span class="ow">::</span> <span class="kt">TxOut</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">DatumHash</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Datum</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">GameDatum</span>
<span class="nf">gameDatum</span> <span class="n">o</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">dh</span>      <span class="ow">&lt;-</span> <span class="n">txOutDatum</span> <span class="n">o</span>
    <span class="kt">Datum</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">dh</span>
    <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">fromData</span> <span class="n">d</span>
</pre></div>
</div>
<p>Now we come to the core business logic in the <em>mkGameValidator</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">mkGameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameDatum</span> <span class="ow">-&gt;</span> <span class="kt">GameRedeemer</span> <span class="ow">-&gt;</span> <span class="kt">ScriptContext</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">mkGameValidator</span> <span class="n">game</span> <span class="n">bsZero&#39;</span> <span class="n">bsOne&#39;</span> <span class="n">dat</span> <span class="n">red</span> <span class="n">ctx</span> <span class="ow">=</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first argument is the <em>Game</em> parameter discussed above.</p>
<p>The second and the third arguments are somewhat of a nuisance. We just need them due to the fact that it is not possible to use string literals to
get <em>ByteStrings</em> in Haskell that is compiled to Plutus core. And, we want string literals representing the 0 and 1 choices. So <em>bsZero’</em> will hold “0” and
<em>beOne’</em> will hold “1”. You will see how we pass these in as auxiliary arguments later.</p>
<p>Then we pass in the usual arguments for datum, redeemer and context.</p>
<p>Let’s look at some helper functions first. There are three functions we have used before and discussed in lecture 6.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">info</span> <span class="ow">::</span> <span class="kt">TxInfo</span>
<span class="nf">info</span> <span class="ow">=</span> <span class="n">scriptContextTxInfo</span> <span class="n">ctx</span>

<span class="nf">ownInput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownInput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">findOwnInput</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;game input missing&quot;</span>
    <span class="kt">Just</span> <span class="n">i</span>  <span class="ow">-&gt;</span> <span class="n">txInInfoResolved</span> <span class="n">i</span>

<span class="nf">ownOutput</span> <span class="ow">::</span> <span class="kt">TxOut</span>
<span class="nf">ownOutput</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">getContinuingOutputs</span> <span class="n">ctx</span> <span class="kr">of</span>
    <span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">o</span>
    <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;expected exactly one game output&quot;</span>
</pre></div>
</div>
<p>Note the <em>ownInput</em> should never fail as we are in the process of validating a UTxO.</p>
<p>The <em>outputDatum</em> helper makes use of the <em>GameDatum</em> type which we defined earlier. Given the case we have exactly one output (the return from <em>ownOutput</em>), it will
give us the datum.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">outputDatum</span> <span class="ow">::</span> <span class="kt">GameDatum</span>
<span class="nf">outputDatum</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">gameDatum</span> <span class="n">ownOutput</span> <span class="p">(`</span><span class="n">findDatum</span><span class="p">`</span> <span class="n">info</span><span class="p">)</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">traceError</span> <span class="s">&quot;game output datum not found&quot;</span>
    <span class="kt">Just</span> <span class="n">d</span>  <span class="ow">-&gt;</span> <span class="n">d</span>
</pre></div>
</div>
<p>The <em>checkNonce</em> function is for the case where the first player as won and wants to prove it by revealing their nonce. The first argument is hash that was original sent,
the second argument is the nonce that is being revealed.</p>
<p>For the <em>GameChoice</em>-typed parameter, we will be passing in the move made by player 2. This should be the same as the move made by player 1, and this is what this function will determine using the hash and the nonce.</p>
<p>In order to check the hash of the nonce concatenated with the <em>GameChoice</em>, we use a helper function to convert the <em>GameChoice</em> to a <em>ByteString</em>. Note that the use
of the <em>cFirst</em> and <em>cSecond</em> in the <em>checkNonce</em> function could be swapped around, and the function would work just the same - the difference between the two is that
one is a <em>GameChoice</em> and one is a <em>ByteString</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">checkNonce</span> <span class="ow">::</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">cSecond</span> <span class="ow">=</span> <span class="n">sha2_256</span> <span class="p">(</span><span class="n">nonce</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="n">cFirst</span><span class="p">)</span> <span class="o">==</span> <span class="n">bs</span>
  <span class="kr">where</span>
    <span class="n">cFirst</span> <span class="ow">::</span> <span class="kt">ByteString</span>
    <span class="n">cFirst</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">cSecond</span> <span class="kr">of</span>
        <span class="kt">Zero</span> <span class="ow">-&gt;</span> <span class="n">bsZero&#39;</span>
        <span class="kt">One</span>  <span class="ow">-&gt;</span> <span class="n">bsOne&#39;</span>
</pre></div>
</div>
<p>Finally, there is the question of what happens to the NFT once the game is over and there is no game address anymore. The way we have implemented it here, is that the NFT goes back to the first player. The first player needs it in the beginning to kick off the game and put the NFT
into the correct UTxO, so it is reasonable to give it back the player 1 in the end.</p>
<p>To verify that this condition is met, we have created a helper function called <em>nftToFirst</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nftToFirst</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">nftToFirst</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">valuePaidTo</span> <span class="n">info</span> <span class="o">$</span> <span class="n">gFirst</span> <span class="n">game</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Now that we have covered the helper functions, let’s look at the conditions.</p>
<p>There is one condition that covers all the cases, and that is that the input we are validating must contain the NFT.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from input&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</pre></div>
</div>
<p>After that, the rules depend on the situation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">red</span><span class="p">)</span> <span class="kr">of</span>
</pre></div>
</div>
<p>The first situation is the one where the second player has not yet moved, and they are just now making their move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span>            <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>                             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>         <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span>     <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the first part is the <em>GameDatum</em> and it contains the first player’s hash and a <em>Nothing</em> which shows that the second player has not yet moved. The second part is the <em>GameRedeemer</em> and has been determined
to be of type <em>Play GameChoice</em>. We assign the <em>GameChoice</em> part to <em>c</em> using pattern matching.</p>
<p>We check that the second player has signed the transaction.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span> <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>
</pre></div>
</div>
<p>Then, we check that the first player’s stake is present in the input.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>The output should have the second player’s stake added to the total stake.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;second player&#39;s stake missing&quot;</span> <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>
</pre></div>
</div>
<p>We now exactly what the datum of the output must be. It must be the same hash, plus the move made by the second player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;wrong output datum&quot;</span> <span class="p">(</span><span class="n">outputDatum</span> <span class="o">==</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">))</span>
</pre></div>
</div>
<p>The, the move must happen before the play deadline.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span> <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>
</pre></div>
</div>
<p>And finally, the NFT must be passed on in the output UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">traceIfFalse</span> <span class="s">&quot;token missing from output&quot;</span> <span class="p">(</span><span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownOutput</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The second situation is where both players have moved, and the second player discovers that they have won. In order to prove that and get the winnings, they have
to reveal their nonce.</p>
<p>So, the transaction must be signed by the first player, the nonce must indeed agree with the hash submitted earlier, it must be done before the reveal deadline,
the input must contain both players’ stakes and, finally, the NFT must go back to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c</span><span class="p">),</span> <span class="kt">Reveal</span> <span class="n">nonce</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;commit mismatch&quot;</span>               <span class="p">(</span><span class="n">checkNonce</span> <span class="n">bs</span> <span class="n">nonce</span> <span class="n">c</span><span class="p">)</span>                                            <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;missed deadline&quot;</span>               <span class="p">(</span><span class="n">to</span> <span class="p">(</span><span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>       <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>Next we have the case where the second player doesn’t move within the deadline, and the first player is reclaiming their stake. Here, the first player must have signed
the transaction, the play deadline must have passed, their stake must be present, and the NFT must go back to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">ClaimFirst</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by first player&quot;</span>    <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gFirst</span> <span class="n">game</span><span class="p">))</span>                                    <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gPlayDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span>   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;first player&#39;s stake missing&quot;</span>  <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">)</span>                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>Finally, the case where both players have moved and the first player has either lost or not revealed in time, so the second player is claiming the winnings. This time, the
transaction must be signed by the second player, the reveal deadline must have passed, both players’ stakes must be present, and the NFT must, as usual, go back
to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">),</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="ow">-&gt;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;not signed by second player&quot;</span>   <span class="p">(</span><span class="n">txSignedBy</span> <span class="n">info</span> <span class="p">(</span><span class="n">gSecond</span> <span class="n">game</span><span class="p">))</span>                                   <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;too early&quot;</span>                     <span class="p">(</span><span class="n">from</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gRevealDeadline</span> <span class="n">game</span><span class="p">)</span> <span class="p">`</span><span class="n">contains</span><span class="p">`</span> <span class="n">txInfoValidRange</span> <span class="n">info</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;wrong stake&quot;</span>                   <span class="p">(</span><span class="n">lovelaces</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="n">ownInput</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gStake</span> <span class="n">game</span><span class="p">))</span>             <span class="o">&amp;&amp;</span>
    <span class="n">traceIfFalse</span> <span class="s">&quot;NFT must go to first player&quot;</span>   <span class="n">nftToFirst</span>
</pre></div>
</div>
<p>These four cases are all the legitimate cases that we can have, so in all other cases we fail validation.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">False</span>
</pre></div>
</div>
<p>So now let’s look at the rest of the on-chain code.</p>
<p>As usual, we define a data type that holds the information about the types the datum and redeemer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Gaming</span>
<span class="kr">instance</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptType</span> <span class="kt">Gaming</span> <span class="kr">where</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">DatumType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameDatum</span>
    <span class="kr">type</span> <span class="kr">instance</span> <span class="kt">RedeemerType</span> <span class="kt">Gaming</span> <span class="ow">=</span> <span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>And we define the <em>ByteStrings</em> that will be used to represent the two choices. These values are completely arbitrary - they just can’t be the same as each other.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">bsZero</span><span class="p">,</span> <span class="n">bsOne</span> <span class="ow">::</span> <span class="kt">ByteString</span>
<span class="nf">bsZero</span> <span class="ow">=</span> <span class="s">&quot;0&quot;</span>
<span class="nf">bsOne</span>  <span class="ow">=</span> <span class="s">&quot;1&quot;</span>
</pre></div>
</div>
<p>Boilerplate to compile our parameterized <em>mkGameValidator</em> to Plutus code. We apply the three parameters, <em>Game</em> and the two <em>ByteStrings</em>s. Remember that, we need
to pass in these <em>ByteString</em> parameters because we can’t refer to <em>ByteString</em>s as string literals within Plutus.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameInst</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Scripts</span><span class="o">.</span><span class="kt">ScriptInstance</span> <span class="kt">Gaming</span>
<span class="nf">gameInst</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validator</span> <span class="o">@</span><span class="kt">Gaming</span>
    <span class="p">(</span><span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">mkGameValidator</span> <span class="o">||</span><span class="p">])</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">game</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">bsZero</span>
        <span class="p">`</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">applyCode</span><span class="p">`</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">liftCode</span> <span class="n">bsOne</span><span class="p">)</span>
    <span class="o">$$</span><span class="p">(</span><span class="kt">PlutusTx</span><span class="o">.</span><span class="n">compile</span> <span class="p">[</span><span class="o">||</span> <span class="n">wrap</span> <span class="o">||</span><span class="p">])</span>
  <span class="kr">where</span>
    <span class="n">wrap</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">wrapValidator</span> <span class="o">@</span><span class="kt">GameDatum</span> <span class="o">@</span><span class="kt">GameRedeemer</span>
</pre></div>
</div>
<p>The usual boilerplate for validator and address.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gameValidator</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Validator</span>
<span class="nf">gameValidator</span> <span class="ow">=</span> <span class="kt">Scripts</span><span class="o">.</span><span class="n">validatorScript</span> <span class="o">.</span> <span class="n">gameInst</span>

<span class="nf">gameAddress</span> <span class="ow">::</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Ledger</span><span class="o">.</span><span class="kt">Address</span>
<span class="nf">gameAddress</span> <span class="ow">=</span> <span class="n">scriptAddress</span> <span class="o">.</span> <span class="n">gameValidator</span>
</pre></div>
</div>
<p>Now, as preparation for the off-chain code, we will need to be able to find the right UTxO - the one that carries the NFT. To do this we will write a helper function
called <em>findGameOutput</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findGameOutput</span> <span class="ow">::</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">Game</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">,</span> <span class="kt">GameDatum</span><span class="p">))</span>
<span class="nf">findGameOutput</span> <span class="n">game</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">utxos</span> <span class="ow">&lt;-</span> <span class="n">utxoAt</span> <span class="o">$</span> <span class="n">gameAddress</span> <span class="n">game</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">find</span> <span class="n">f</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="n">utxos</span>
        <span class="n">dat</span>       <span class="ow">&lt;-</span> <span class="n">gameDatum</span> <span class="p">(</span><span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(`</span><span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span><span class="p">`</span> <span class="n">txData</span> <span class="p">(</span><span class="n">txOutTxTx</span> <span class="n">o</span><span class="p">))</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TxOutRef</span><span class="p">,</span> <span class="kt">TxOutTx</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">f</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="ow">=</span> <span class="n">assetClassValueOf</span> <span class="p">(</span><span class="n">txOutValue</span> <span class="o">$</span> <span class="n">txOutTxOut</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The <em>findGameOutput</em> function takes the <em>Game</em>, then uses the <em>Contract</em> monad to try to find the UTxO with the NFT. It returns a <em>Maybe</em>, because it may not find one.
If we find it, we return a <em>Just</em> of a triple containing the transaction reference, the transaction itself, and the <em>GameDatum</em>.</p>
<p>First we get a list of all the UTxOs at the game address, then we use the <em>find</em> function, passing in a helper function <em>f</em>, which checks whether the output contains the
NFT.</p>
<p>The <em>find</em> function is found in module <em>Data.List</em> and is defined as</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">find</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>This works for more general containers than just lists, but you can think of lists in this example. It gets a predicate for an element of the <em>Foldable</em> type - the list in
this case, and also takes a container of <em>a</em>s - again a list in this example, and returns a <em>Maybe a</em>.</p>
<p>The logic is that if it finds an element that satisfies the predicate, it will return it as a <em>Just</em>, otherwise it will return <em>Nothing</em>. For example</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">EvenOdd</span><span class="o">&gt;</span> <span class="n">find</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">8</span>

<span class="kt">Prelude</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">EvenOdd</span><span class="o">&gt;</span> <span class="n">find</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<div class="section" id="the-firstgame-contract">
<h5><span class="section-number">8.1.1.1.1. </span>The <em>firstGame</em> contract<a class="headerlink" href="#the-firstgame-contract" title="Permalink to this headline">¶</a></h5>
<p>We have two contracts, one for each of the players.</p>
<p>Each contract has its own params type. For the <em>firstGame</em> contract, we call this type <em>FirstParams</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">FirstParams</span> <span class="ow">=</span> <span class="kt">FirstParams</span>
    <span class="p">{</span> <span class="n">fpSecond</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">fpStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">fpPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">fpRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">fpNonce</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">ByteString</span>
    <span class="p">,</span> <span class="n">fpCurrency</span>       <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">fpTokenName</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">fpChoice</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">GameChoice</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>We don’t need a <em>fpFirst</em> field here, as the first player is the owner of the wallet, so we know their public key hash. But we need <em>fpSecond</em> and also the familiar
fields for stake, play deadline and reveal deadline.</p>
<p>Then we need the nonce, the NFT (split into <em>fpCurrency</em> and <em>fpTokenName</em>), and finally the move that the player wants to make.</p>
<p>Now, for the contract</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">firstGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">FirstParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">firstGame</span> <span class="n">fp</span> <span class="ow">=</span> <span class="kr">do</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The first thing we do is to get our own public key hash.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
</pre></div>
</div>
<p>Then we populate the fields of the game.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Game</span>
        <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">pkh</span>
        <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">fpSecond</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">fpStake</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span>
        <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">fpCurrency</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fpTokenName</span> <span class="n">fp</span><span class="p">)</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>The <em>v</em> value is our stake plus the NFT, which must both go into the UTxO.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">v</span>    <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">fpStake</span> <span class="n">fp</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We then calculate the hash that we need to send as our disguised move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">c</span>    <span class="ow">=</span> <span class="n">fpChoice</span> <span class="n">fp</span>
    <span class="n">bs</span>   <span class="ow">=</span> <span class="n">sha2_256</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span> <span class="p">`</span><span class="n">concatenate</span><span class="p">`</span> <span class="kr">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kt">Zero</span> <span class="kr">then</span> <span class="n">bsZero</span> <span class="kr">else</span> <span class="n">bsOne</span>
</pre></div>
</div>
<p>We then submit the transaction and wait as usual. The constraints are very simple. We just need to create a UTxI with the datum of our move (nothing yet for the second player), and the value <em>v</em> we defined above.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="o">...</span>
    <span class="n">tx</span>   <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="n">v</span>
<span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraints</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span> <span class="n">tx</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">fpChoice</span> <span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
<p>And we wait for the play deadline slot, at which point the winner can be determined.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fpPlayDeadline</span> <span class="n">fp</span>
</pre></div>
</div>
<p>Once the deadline passed, we get hold of the UTxO. If, at this point, the UTxO is not found, something has gone very wrong. We know that we have produced the UTxO, and the
only thing that the second player should be able to do is create a new one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
<span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>             <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="s">&quot;game output not found&quot;</span>
</pre></div>
</div>
<p>So, assuming we find it, the first case we define is the one where the second player hasn’t moved. So we can use the <em>ClaimFirst</em> redeemer to get the stake back.</p>
<p>As lookups we need to provide the UTxO and the validator of the game.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">dat</span> <span class="kr">of</span>
    <span class="kt">GameDatum</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player did not play&quot;</span>
        <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                      <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
            <span class="n">tx&#39;</span>     <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">ClaimFirst</span><span class="p">)</span>
        <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx&#39;</span>
        <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;reclaimed stake&quot;</span>
</pre></div>
</div>
<p>The second case is that the second player did move, and they lost. In which case we must now reveal our nonce, which we do using the <em>Reveal</em> redeemer.</p>
<p>We must put an additional constraint that the transaction must be submitted before the reveal deadline has passed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">GameDatum</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">c&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">c&#39;</span> <span class="o">==</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and lost&quot;</span>
    <span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>                                         <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
        <span class="n">tx&#39;</span>     <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">Reveal</span> <span class="o">$</span> <span class="n">fpNonce</span> <span class="n">fp</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                  <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">fpRevealDeadline</span> <span class="n">fp</span><span class="p">)</span>
    <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;victory&quot;</span>
</pre></div>
</div>
<p>If the second player moved and won, there is nothing for use to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player played and won&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-secondgame-contract">
<h5><span class="section-number">8.1.1.1.2. </span>The <em>secondGame</em> contract<a class="headerlink" href="#the-secondgame-contract" title="Permalink to this headline">¶</a></h5>
<p>The params for the second player are similar to those of the first player. This time we don’t need the second player’s public key hash, because that is ours, and we already
know what it is. Instead we need the first player’s public key hash. Also, we don’t need the nonce.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">SecondParams</span> <span class="ow">=</span> <span class="kt">SecondParams</span>
    <span class="p">{</span> <span class="n">spFirst</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">PubKeyHash</span>
    <span class="p">,</span> <span class="n">spStake</span>          <span class="ow">::</span> <span class="o">!</span><span class="kt">Integer</span>
    <span class="p">,</span> <span class="n">spPlayDeadline</span>   <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">spRevealDeadline</span> <span class="ow">::</span> <span class="o">!</span><span class="kt">Slot</span>
    <span class="p">,</span> <span class="n">spCurrency</span>       <span class="ow">::</span> <span class="o">!</span><span class="kt">CurrencySymbol</span>
    <span class="p">,</span> <span class="n">spTokenName</span>      <span class="ow">::</span> <span class="o">!</span><span class="kt">TokenName</span>
    <span class="p">,</span> <span class="n">spChoice</span>         <span class="ow">::</span> <span class="o">!</span><span class="kt">GameChoice</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">FromJSON</span><span class="p">,</span> <span class="kt">ToJSON</span><span class="p">,</span> <span class="kt">ToSchema</span><span class="p">)</span>
</pre></div>
</div>
<p>First we get our own public key hash then we set up the game values, in a similar way as we did for the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">secondGame</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">w</span> <span class="n">s</span><span class="o">.</span> <span class="kt">HasBlockchainActions</span> <span class="n">s</span> <span class="ow">=&gt;</span> <span class="kt">SecondParams</span> <span class="ow">-&gt;</span> <span class="kt">Contract</span> <span class="n">w</span> <span class="n">s</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">secondGame</span> <span class="n">sp</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">pkh</span> <span class="ow">&lt;-</span> <span class="n">pubKeyHash</span> <span class="o">&lt;$&gt;</span> <span class="kt">Contract</span><span class="o">.</span><span class="n">ownPubKey</span>
    <span class="kr">let</span> <span class="n">game</span> <span class="ow">=</span> <span class="kt">Game</span>
            <span class="p">{</span> <span class="n">gFirst</span>          <span class="ow">=</span> <span class="n">spFirst</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gSecond</span>         <span class="ow">=</span> <span class="n">pkh</span>
            <span class="p">,</span> <span class="n">gStake</span>          <span class="ow">=</span> <span class="n">spStake</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gPlayDeadline</span>   <span class="ow">=</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gRevealDeadline</span> <span class="ow">=</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
            <span class="p">,</span> <span class="n">gToken</span>          <span class="ow">=</span> <span class="kt">AssetClass</span> <span class="p">(</span><span class="n">spCurrency</span> <span class="n">sp</span><span class="p">,</span> <span class="n">spTokenName</span> <span class="n">sp</span><span class="p">)</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>Now, we try to find the UTxO that contains the NFT</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
</pre></div>
</div>
<p>If we don’t find it, then there is nothing to do, but if we do find it…</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">oref</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kt">GameDatum</span> <span class="n">bs</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;running game found&quot;</span>
</pre></div>
</div>
<p>Then we want to call the script with the <em>Play</em> redeemer.</p>
<p>We assign the NFT to <em>token</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">token</span>   <span class="ow">=</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="n">gToken</span> <span class="n">game</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
<p>We now calculate the value that we must put in the new output. Remember, if we decide to play, we must consume the existing UTxO and create a new one at the same address. The
first will contain the stake that the first player added, and now we must add our own stake, and we must keep the NFT in there.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">lovelaceValueOf</span> <span class="p">(</span><span class="n">spStake</span> <span class="n">sp</span><span class="p">)</span> <span class="kr">in</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">x</span> <span class="o">&lt;&gt;</span> <span class="n">token</span>
</pre></div>
</div>
<p>Next, our choice.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">spChoice</span> <span class="n">sp</span>
</pre></div>
</div>
<p>Then the constraints and their required lookups.</p>
<p>We must consume the existing UTxO using the Play redeemer with our choice</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">tx</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="o">$</span> <span class="kt">Play</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
</pre></div>
</div>
<p>And create a new UTxO with the updated datum (the same <em>bs</em>, but with our choice), and with the <em>v</em> that we computed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToTheScript</span> <span class="p">(</span><span class="kt">GameDatum</span> <span class="n">bs</span> <span class="o">$</span> <span class="kt">Just</span> <span class="n">c</span><span class="p">)</span> <span class="n">v</span> <span class="o">&lt;&gt;</span>
</pre></div>
</div>
<p>And it must be done before the deadline passes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">to</span> <span class="o">$</span> <span class="n">spPlayDeadline</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>For lookups, we need the UTxO, the validator, and, because we are producing a UTxO for the script, we need the script instance.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">lookups</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref</span> <span class="n">o</span><span class="p">)</span>                            <span class="o">&lt;&gt;</span>
              <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>                                 <span class="o">&lt;&gt;</span>
              <span class="kt">Constraints</span><span class="o">.</span><span class="n">scriptInstanceLookups</span> <span class="p">(</span><span class="n">gameInst</span> <span class="n">game</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we do the usual thing, we submit, we wait for confirmation and we log.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ledgerTx</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups</span> <span class="n">tx</span>
<span class="kr">let</span> <span class="n">tid</span> <span class="ow">=</span> <span class="n">txId</span> <span class="n">ledgerTx</span>
<span class="nf">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="n">tid</span>
<span class="nf">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;made second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">spChoice</span> <span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we wait until the reveal deadline has passed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="o">$</span> <span class="n">awaitSlot</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span>
</pre></div>
</div>
<p>And we again try to find the UTxO, which could now be a different one.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">m&#39;</span> <span class="ow">&lt;-</span> <span class="n">findGameOutput</span> <span class="n">game</span>
</pre></div>
</div>
<p>If <em>m’</em> is <em>Nothing</em> - in other words, if we did not find a UTxO, then that means that while we were waiting, the first player revealed and won. So there is nothing
for us to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">m&#39;</span> <span class="kr">of</span>
    <span class="kt">Nothing</span>             <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player won&quot;</span>
</pre></div>
</div>
<p>However, if we do find the UTxO, it means the first player didn’t reveal, which means that either they decided not to play, probably because they lost. In any case, we
can now claim the winnings.</p>
<p>Our constraints are that we must spend the UTxO that we found after the deadline has passed, and we must hand back the NFT to the first player.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Just</span> <span class="p">(</span><span class="n">oref&#39;</span><span class="p">,</span> <span class="n">o&#39;</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
    <span class="kr">let</span> <span class="n">lookups&#39;</span> <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">unspentOutputs</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="n">oref&#39;</span> <span class="n">o&#39;</span><span class="p">)</span>                              <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">otherScript</span> <span class="p">(</span><span class="n">gameValidator</span> <span class="n">game</span><span class="p">)</span>
        <span class="n">tx&#39;</span>      <span class="ow">=</span> <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustSpendScriptOutput</span> <span class="n">oref&#39;</span> <span class="p">(</span><span class="kt">Redeemer</span> <span class="o">$</span> <span class="kt">PlutusTx</span><span class="o">.</span><span class="n">toData</span> <span class="kt">ClaimSecond</span><span class="p">)</span> <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustValidateIn</span> <span class="p">(</span><span class="n">from</span> <span class="o">$</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">spRevealDeadline</span> <span class="n">sp</span><span class="p">)</span>                      <span class="o">&lt;&gt;</span>
                   <span class="kt">Constraints</span><span class="o">.</span><span class="n">mustPayToPubKey</span> <span class="p">(</span><span class="n">spFirst</span> <span class="n">sp</span><span class="p">)</span> <span class="n">token</span>
    <span class="n">ledgerTx&#39;</span> <span class="ow">&lt;-</span> <span class="n">submitTxConstraintsWith</span> <span class="o">@</span><span class="kt">Gaming</span> <span class="n">lookups&#39;</span> <span class="n">tx&#39;</span>
    <span class="n">void</span> <span class="o">$</span> <span class="n">awaitTxConfirmed</span> <span class="o">$</span> <span class="n">txId</span> <span class="n">ledgerTx&#39;</span>
    <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;second player won&quot;</span>
</pre></div>
</div>
<p>If we didn’t find the NFT, then there is nothing for use to do.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">logInfo</span> <span class="o">@</span><span class="kt">String</span> <span class="s">&quot;no running game found&quot;</span>
</pre></div>
</div>
<p>That is all the code we need for the two on-chain contracts.</p>
<p>To make them more accessible, we define two <em>Endpoint</em>s, one for the first player, and one for the second. And then we define a contract
called <em>endpoints</em> which offers a choice between these two <em>Endpoint</em>s, and recursively calls itself.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">GameSchema</span> <span class="ow">=</span> <span class="kt">BlockchainActions</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;first&quot;</span> <span class="kt">FirstParams</span> <span class="o">.\/</span> <span class="kt">Endpoint</span> <span class="s">&quot;second&quot;</span> <span class="kt">SecondParams</span>

<span class="nf">endpoints</span> <span class="ow">::</span> <span class="kt">Contract</span> <span class="nb">()</span> <span class="kt">GameSchema</span> <span class="kt">Text</span> <span class="nb">()</span>
<span class="nf">endpoints</span> <span class="ow">=</span> <span class="p">(</span><span class="n">first</span> <span class="p">`</span><span class="n">select</span><span class="p">`</span> <span class="n">second</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">endpoints</span>
  <span class="kr">where</span>
    <span class="n">first</span>  <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;first&quot;</span>  <span class="o">&gt;&gt;=</span> <span class="n">firstGame</span>
    <span class="n">second</span> <span class="ow">=</span> <span class="n">endpoint</span> <span class="o">@</span><span class="s">&quot;second&quot;</span> <span class="o">&gt;&gt;=</span> <span class="n">secondGame</span>
</pre></div>
</div>
<p>So this concludes the first version of the game - the version that does not use state machines.</p>
<p>Now, let’s test it using the <em>EmulatorTrace</em> monad.</p>
</div>
<div class="section" id="testing">
<h5><span class="section-number">8.1.1.1.3. </span>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h5>
<p>The <em>test</em> function tests each of the four combinations by calling the <em>test’</em> function which takes the first and second players’ choices respectively.</p>
<p>The <em>test’</em> function uses the <em>runEmulatorTraceIO’</em> variant which allows us to set up the initial wallet distributions using an <em>EmulatorConfig</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">test</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">test&#39;</span> <span class="kt">Zero</span> <span class="kt">Zero</span>
    <span class="n">test&#39;</span> <span class="kt">Zero</span> <span class="kt">One</span>
    <span class="n">test&#39;</span> <span class="kt">One</span> <span class="kt">Zero</span>
    <span class="n">test&#39;</span> <span class="kt">One</span> <span class="kt">One</span>

<span class="nf">test&#39;</span> <span class="ow">::</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">test&#39;</span> <span class="n">c1</span> <span class="n">c2</span> <span class="ow">=</span> <span class="n">runEmulatorTraceIO&#39;</span> <span class="n">def</span> <span class="n">emCfg</span> <span class="o">$</span> <span class="n">myTrace</span> <span class="n">c1</span> <span class="n">c2</span>
  <span class="kr">where</span>
    <span class="n">emCfg</span> <span class="ow">::</span> <span class="kt">EmulatorConfig</span>
    <span class="n">emCfg</span> <span class="ow">=</span> <span class="kt">EmulatorConfig</span> <span class="o">$</span> <span class="kt">Left</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
        <span class="p">[</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">&lt;&gt;</span> <span class="n">assetClassValue</span> <span class="p">(</span><span class="kt">AssetClass</span> <span class="p">(</span><span class="n">gameTokenCurrency</span><span class="p">,</span> <span class="n">gameTokenName</span><span class="p">))</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">,</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="n">v</span> <span class="ow">::</span> <span class="kt">Value</span>
    <span class="n">v</span> <span class="ow">=</span> <span class="kt">Ada</span><span class="o">.</span><span class="n">lovelaceValueOf</span> <span class="mi">1000_000_000</span>
</pre></div>
</div>
<p>As NFTs are not the focus of this lecture, we have conjured a test NFT out of thin air. In a real world scenario, we would need to mint a real NFT, using one of the methods we have seen before.</p>
<p>Now the trace. We pass the two game choices into the <em>myTrace</em> function.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myTrace</span> <span class="ow">::</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">GameChoice</span> <span class="ow">-&gt;</span> <span class="kt">EmulatorTrace</span> <span class="nb">()</span>
<span class="nf">myTrace</span> <span class="n">c1</span> <span class="n">c2</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kt">Extras</span><span class="o">.</span><span class="n">logInfo</span> <span class="o">$</span> <span class="s">&quot;first move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c1</span> <span class="o">++</span> <span class="s">&quot;, second move: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">c2</span>
</pre></div>
</div>
<p>Then we start two instances of the contract, one for wallet 1 and one for wallet 2.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">h1</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">1</span><span class="p">)</span> <span class="n">endpoints</span>
<span class="nf">h2</span> <span class="ow">&lt;-</span> <span class="n">activateContractWallet</span> <span class="p">(</span><span class="kt">Wallet</span> <span class="mi">2</span><span class="p">)</span> <span class="n">endpoints</span>
</pre></div>
</div>
<p>We look up the two public key hashes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">pkh1</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">1</span>
    <span class="n">pkh2</span> <span class="ow">=</span> <span class="n">pubKeyHash</span> <span class="o">$</span> <span class="n">walletPubKey</span> <span class="o">$</span> <span class="kt">Wallet</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Then we define the parameters that we are going to use for the contracts. In reality <em>fpNonce</em> would be some random string, but here we just hardcode as “SECRETNONCE”.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fp</span> <span class="ow">=</span> <span class="kt">FirstParams</span>
        <span class="p">{</span> <span class="n">fpSecond</span>         <span class="ow">=</span> <span class="n">pkh2</span>
        <span class="p">,</span> <span class="n">fpStake</span>          <span class="ow">=</span> <span class="mi">5000000</span>
        <span class="p">,</span> <span class="n">fpPlayDeadline</span>   <span class="ow">=</span> <span class="mi">5</span>
        <span class="p">,</span> <span class="n">fpRevealDeadline</span> <span class="ow">=</span> <span class="mi">10</span>
        <span class="p">,</span> <span class="n">fpNonce</span>          <span class="ow">=</span> <span class="s">&quot;SECRETNONCE&quot;</span>
        <span class="p">,</span> <span class="n">fpCurrency</span>       <span class="ow">=</span> <span class="n">gameTokenCurrency</span>
        <span class="p">,</span> <span class="n">fpTokenName</span>      <span class="ow">=</span> <span class="n">gameTokenName</span>
        <span class="p">,</span> <span class="n">fpChoice</span>         <span class="ow">=</span> <span class="n">c1</span>
        <span class="p">}</span>
<span class="nf">sp</span> <span class="ow">=</span> <span class="kt">SecondParams</span>
        <span class="p">{</span> <span class="n">spFirst</span>          <span class="ow">=</span> <span class="n">pkh1</span>
        <span class="p">,</span> <span class="n">spStake</span>          <span class="ow">=</span> <span class="mi">5000000</span>
        <span class="p">,</span> <span class="n">spPlayDeadline</span>   <span class="ow">=</span> <span class="mi">5</span>
        <span class="p">,</span> <span class="n">spRevealDeadline</span> <span class="ow">=</span> <span class="mi">10</span>
        <span class="p">,</span> <span class="n">spCurrency</span>       <span class="ow">=</span> <span class="n">gameTokenCurrency</span>
        <span class="p">,</span> <span class="n">spTokenName</span>      <span class="ow">=</span> <span class="n">gameTokenName</span>
        <span class="p">,</span> <span class="n">spChoice</span>         <span class="ow">=</span> <span class="n">c2</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>And then we call the endpoints.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;first&quot;</span> <span class="n">h1</span> <span class="n">fp</span>

<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">3</span>

<span class="nf">callEndpoint</span> <span class="o">@</span><span class="s">&quot;second&quot;</span> <span class="n">h2</span> <span class="n">sp</span>

<span class="nf">void</span> <span class="o">$</span> <span class="kt">Emulator</span><span class="o">.</span><span class="n">waitNSlots</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Now, we can run this test from the REPL.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">cabal</span> <span class="n">repl</span>
<span class="kt">Prelude</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">StateMachine</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">Test</span>
<span class="kt">Prelude</span> <span class="kt">Week07</span><span class="o">.</span><span class="kt">Test</span><span class="o">&gt;</span> <span class="n">test</span>
</pre></div>
</div>
<div class="section" id="test-1">
<h6><span class="section-number">8.1.1.1.3.1. </span>Test 1<a class="headerlink" href="#test-1" title="Permalink to this headline">¶</a></h6>
<p>The first scenario is that both play zero, so the first wallet should win.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">fbe753823edc9d69538ae9a03702708ccac2b9ae58b8426bcfcf99e274dd552</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">USER</span> <span class="kt">LOG:</span> <span class="n">first</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span><span class="p">,</span> <span class="n">second</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
</pre></div>
</div>
<p>The first wallet creates the initial UTxO with its stake, and logs a message that it made the move.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;first&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;fpChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;fpCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpNonce&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;5345435245544e4f4e4345&quot;</span><span class="p">),(</span><span class="s">&quot;fpPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;fpRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;fpSecond&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;fpTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made first move: Zero&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Slot</span> <span class="mi">00003</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">4</span>
</pre></div>
</div>
<p>While the first wallet is waiting, the second wallet kicks in and finds the UTxO, sees that it can make a move, and does so.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;second&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;spChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;spCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;spFirst&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9&quot;</span><span class="p">)])),(</span><span class="s">&quot;spPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;spRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;spStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;spTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;running game found&quot;</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="mi">9</span><span class="n">ff5cf1ce61c0395b653a57449c39ed14f06bb75600057ea0e32a8d1588d048e</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">ff5cf1ce61c0395b653a57449c39ed14f06bb75600057ea0e32a8d1588d048e</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">5</span>
<span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made second move: Zero&quot;</span>
</pre></div>
</div>
<p>The first player realizes that they have won, and so must reveal. And we see in the final balances that Wallet 1 does indeed have the NFT back and it also has
almost 5 ada more than it started with. The difference is, of course, due to transaction fees. And the second wallet has a little more than 5 ada less.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">6</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player played and lost&quot;</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="n">ea946a524a7a3959743fc4c5dbc3982bf1510a84d973fecbb660a328bb58c0b5</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">ea946a524a7a3959743fc4c5dbc3982bf1510a84d973fecbb660a328bb58c0b5</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">7</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;victory&quot;</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">8</span>
<span class="kt">Slot</span> <span class="mi">00008</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">9</span>
<span class="kt">Slot</span> <span class="mi">00009</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">10</span>
<span class="kt">Slot</span> <span class="mi">00010</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">11</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;first player won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">12</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">13</span>
<span class="kt">Slot</span> <span class="mi">00013</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">14</span>
<span class="kt">Slot</span> <span class="mi">00014</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">15</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1004999980</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">994999990</span>
</pre></div>
</div>
</div>
<div class="section" id="test-2">
<h6><span class="section-number">8.1.1.1.3.2. </span>Test 2<a class="headerlink" href="#test-2" title="Permalink to this headline">¶</a></h6>
<p>In the second case, Wallet 1 again plays Zero, but this time Wallet 2 plays One.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">9</span><span class="n">fbe753823edc9d69538ae9a03702708ccac2b9ae58b8426bcfcf99e274dd552</span>
<span class="kt">Slot</span> <span class="mi">00000</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">1</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">USER</span> <span class="kt">LOG:</span> <span class="n">first</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">Zero</span><span class="p">,</span> <span class="n">second</span> <span class="n">move</span><span class="kt">:</span> <span class="kt">One</span>
</pre></div>
</div>
<p>The beginning is the same.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">started</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000000</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">1</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;first&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;fpChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;Zero&quot;</span><span class="p">),(</span><span class="s">&quot;fpCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpNonce&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;5345435245544e4f4e4345&quot;</span><span class="p">),(</span><span class="s">&quot;fpPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;fpRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;fpSecond&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;39f713d0a644253f04529421b9f51b9b08979d08295959c4f3990ee617f5139f&quot;</span><span class="p">)])),(</span><span class="s">&quot;fpStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;fpTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">W1:</span> <span class="kt">TxSubmit:</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">6</span><span class="n">f41600a05f16728a64f9f227bd2e828a0ccbbf9b56f46503f06873d3e8906a6</span>
<span class="kt">Slot</span> <span class="mi">00001</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">2</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made first move: Zero&quot;</span>
<span class="kt">Slot</span> <span class="mi">00002</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">3</span>
<span class="kt">Slot</span> <span class="mi">00003</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Now the second wallet finds the game, and makes its move, but now the move is One.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="mi">00000000</span><span class="o">-</span><span class="mi">0000</span><span class="o">-</span><span class="mi">4000</span><span class="o">-</span><span class="mi">8000</span><span class="o">-</span><span class="mi">000000000001</span> <span class="p">{</span><span class="kt">Contract</span> <span class="kr">instance</span> <span class="n">for</span> <span class="n">wallet</span> <span class="mi">2</span><span class="p">}</span><span class="kt">:</span>
  <span class="kt">Receive</span> <span class="n">endpoint</span> <span class="n">call</span><span class="kt">:</span> <span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;tag&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;second&quot;</span><span class="p">),(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unEndpointValue&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;spChoice&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;One&quot;</span><span class="p">),(</span><span class="s">&quot;spCurrency&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unCurrencySymbol&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;ff&quot;</span><span class="p">)])),(</span><span class="s">&quot;spFirst&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getPubKeyHash&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;21fe31dfa154a261626bf854046fd2271b7bed4b6abe45aa58877ef47f9721b9&quot;</span><span class="p">)])),(</span><span class="s">&quot;spPlayDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5.0</span><span class="p">)])),(</span><span class="s">&quot;spRevealDeadline&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;getSlot&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">10.0</span><span class="p">)])),(</span><span class="s">&quot;spStake&quot;</span><span class="p">,</span><span class="kt">Number</span> <span class="mf">5000000.0</span><span class="p">),(</span><span class="s">&quot;spTokenName&quot;</span><span class="p">,</span><span class="kt">Object</span> <span class="p">(</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;unTokenName&quot;</span><span class="p">,</span><span class="kt">String</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">)]))]))]))])</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;running game found&quot;</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="mi">3200</span><span class="n">aab18d986869a7e9aa65ff45a635e0bc2dff9b04df26a0864355990f9c10</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="mi">3200</span><span class="n">aab18d986869a7e9aa65ff45a635e0bc2dff9b04df26a0864355990f9c10</span>
<span class="kt">Slot</span> <span class="mi">00004</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">5</span>
<span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;made second move: One&quot;</span>
</pre></div>
</div>
<p>Now the first wallet realizes it has lost and does nothing.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00005</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">6</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player played and won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00006</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">7</span>
<span class="kt">Slot</span> <span class="mi">00007</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">8</span>
<span class="kt">Slot</span> <span class="mi">00008</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">9</span>
<span class="kt">Slot</span> <span class="mi">00009</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">10</span>
<span class="kt">Slot</span> <span class="mi">00010</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">11</span>
</pre></div>
</div>
<p>The second wallet detects that the deadline has passed without a reveal, and invokes the <em>ClaimSecond</em> endpoint to get the money. When we look at the final balances,
Wallet 1 again has the NFT back, but the Ada balance situation is reversed.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;first player didn&#39;t reveal&quot;</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">W2:</span> <span class="kt">TxSubmit:</span> <span class="n">a66744d7b4692db9457d9c3a5d832db7d1471299bd36ffe27827f41ec3e999f1</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">TxnValidate</span> <span class="n">a66744d7b4692db9457d9c3a5d832db7d1471299bd36ffe27827f41ec3e999f1</span>
<span class="kt">Slot</span> <span class="mi">00011</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">12</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="o">***</span> <span class="kt">CONTRACT</span> <span class="kt">LOG:</span> <span class="s">&quot;second player won&quot;</span>
<span class="kt">Slot</span> <span class="mi">00012</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">13</span>
<span class="kt">Slot</span> <span class="mi">00013</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">14</span>
<span class="kt">Slot</span> <span class="mi">00014</span><span class="kt">:</span> <span class="kt">SlotAdd</span> <span class="kt">Slot</span> <span class="mi">15</span>
<span class="kt">Final</span> <span class="n">balances</span>
<span class="kt">Wallet</span> <span class="mi">1</span><span class="kt">:</span>
    <span class="p">{</span><span class="n">ff</span><span class="p">,</span> <span class="s">&quot;STATE TOKEN&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">994999990</span>
<span class="kt">Wallet</span> <span class="mi">2</span><span class="kt">:</span>
    <span class="p">{,</span> <span class="s">&quot;&quot;</span><span class="p">}</span><span class="kt">:</span> <span class="mi">1004999980</span>
</pre></div>
</div>
<p>The remaining two cases are very similar, so we won’t post the logs here.</p>
<p>So, this all seems to work as expected.</p>
</div>
</div>
</div>
</div>
<div class="section" id="code-example-2">
<h3><span class="section-number">8.1.2. </span>Code Example 2<a class="headerlink" href="#code-example-2" title="Permalink to this headline">¶</a></h3>
<p>Now we will rewrite this code using state machines.</p>
<p>A state machine has nothing in particular to do with blockchain. It is a system that starts with some sort of state, there are one or more transitions to other states,
and from those states there are further transitions, and so on, like a directed graph. Some states can be <em>final</em> states, from which there can be no further
transitions.</p>
<div class="figure align-default">
<img alt="_images/week07__00014.png" src="_images/week07__00014.png" />
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="week6.html" class="btn btn-neutral float-left" title="7. Week 06 - Oracles" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright .

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>