
 so
that you'll see the steps as a series of
um cards like this
but that's that's work in progress
okay so we've talked about um
we've talked about usability what about
the sort of assurance that marlow
can give users
there are two gen apart from the things
we've seen already we've seen
we've seen that making the system
transparent making
code readable is itself an advantage
we've seen that there's simulation to
give people
um to give people uh
the ability to understand to validate
their intuition about a contract
but rather more formally we can use the
power of logic to do
two things for us we can do what's
called static analysis so we could
automatically verify
properties of individual contracts that
means we can guarantee
this contract will behave as it should
checking every route through the
contract and also we can do machine
supported proof so
not automatic any longer written by
written by a user but we can prove
properties of the
the overall system let's talk about
those two now
what about static analysis well what
static analysis
allows us to do is check all execution
paths through a milo contract
all choices all choices of slots
for a submission of a transaction so
every possible
way in which the contract might be
executed
we examine and the canonical example
here
is the example of whether a pay
construct
might fail is it possible a pay
construct
could fail and the answer is that we
will
we have we we use what's called an smt
solver
um it's an automatic logic tool that
the powerful logic tool called z3 which
is
the one we use others are available um
that effectively checks checks all
execution parts
and what it does is if um
if the property is is satisfied that's
fine
we get get the result yes it's satisfied
if it's not satisfied we get a counter
example
we get told here's a way here's a path
through this contract
that leads to
a failed payment a payment that can't be
fulfilled
so here's an example of how it can go
wrong and that's really helpful because
it means that you can debug if you don't
if if you really want to make sure that
failed payment can't happen
then this gives you a mechanism to
understand
and to debug how that
eventuality happens and so gives you a
chance to think about how to avoid it
so very powerful and entirely push
button you push a button
and um you get the results and here you
can see
um just again to to emphasize these
here's the assurance we can do this
high-level check through
all execution piles so here you see
a fragment of a milo contract it's an
escrow contract
where the contract starts with a deposit
of 450 lovelace
um and checking the analysis
in um in the playground
we've got the results static analysis
could not find any any
execution that results in any warning so
that's saying
you're okay it's not going to give you a
warning whatever you do
but if we change that deposit of 450
lovelace to a deposit of 40
and analyze we then get this warning
we get a transaction partial payment
we're told we get to a payment
where we're meant to pay 450 units of
ada that is lovelace
but there are only 40 available and we
get
given a list of transactions that take
us there
so we're able to see from that how we
got to that
and the problem is that we didn't put
enough money in and then we reached a
a place where we needed to make a
payment of 450.
so it's easy for us to see that we need
to
either make the payment smaller or the
initial deposit bigger
but it's entirely push button so you
know we do get that sort of assurance
for free as it were
but thinking about verification
we can do rather more than that we can
do
prove things prove properties of the
system once and for all
so for example just looking on the
left-hand side here
we can prove that accounts local
accounts inside
um a milo contract as it executes
we can we can prove from the semantics
that these accounts
never go negative you can't ever
overdraw
an account in a marlow contract
and we can also prove this theorem of
money preservation we can prove
that if we look at all the money that's
gone into the contract so far
that's equal to the sum of two things
the amount of money that's um in the
count
held inside the contract plus the amount
of money that has been paid
out and that's that gives a clear
picture of money preservation so we're
able to
um we're able to write
proofs of these very general properties
of the system
now we're also able to to prove other
more technical things about the system
so for example that um a close
construct will never produce any
warnings so if we're analyzing for
warnings
we don't need to worry about close
constructs
so that allows us to optimize the
static analysis and we're also able to
prove that the static analysis
the way it works which is is makes a
number of simplifications to speed
things up
is sound and complete that means the
static analysis
will give us an error warning when
the real contract can generate an error
warning and it won't give us an error
warning if the real contract
can't do that and one thing that we
haven't done but we're you know is again
on our roadmap is we we can do these
sorts of proofs for individual contracts
or individual contract templates
too things that we can't necessarily
prove with static analysis
we can prove by proving them by hand
so high level assurance we get
if you're prepared to write proofs the
system is amenable to being
having these proofs written about it and
they give us the highest level of
assurance about how it works
so i think i've i've said enough for the
moment about marlowe where
can you go to find out more well there's
a marlow github repository that has the
semantics
and the basics about marlow quite a lot
of the
the implementation of the tools from
arlo
are in the pl is in the pluto's
repository because it
has that repository as a dependency so
we include it in that repository
so that's where you can find out find
the code itself
if you look in the iohk online research
library and search for marlow you'll
find a number of
research papers we've written about how
the system works
you'll also find an online tutorial in
the milo playground
and finally alex is going to give some
more information in his presentation
coming up next so just to summarize what
we have in milo is a dsl a special
purpose language for financial contracts
running on top of pluto's because it's a
dsl
it gives us assurance it allows us to
give
assurance that it's harder to give for a
general purpose language
and also it allows us to to orient its
design around users as well as
developers
and also that we get assurance of
contracts behaviors they should and
and um don't do what they shouldn't
that's some of that is built into the
way that language is designed
um language is simple and therefore we
get readability
we also get simulatability and we get
these stronger assurances of
um static analysis and verification
so okay thanks very much for listening
and um
here's the the link to go and see the
marlo playground
in action thanks very much hello my name
is alex namish
i'm one of the merlot developers
and today i'm gonna show you a bit of
marlo semantics and
part of pab contracts moral opap
contracts
that we are going to use
i'll start with a brief description
of marlo semantics that's implemented in
this
semantics.hs file and then i'll show you
the pab contracts
i assume you're familiar with haskell
if you're familiar with marvel semantics
and high level and i expect you to
see the lars presentations
so i expect you to know how
bab works in a nutshell
and how state machine library
works and state machine library based
contracts
let's get started here are the
main data types for model
it's a contract essentially those are
six constructors that you can start
model contract with
and here's the state that is going to be
stored on a blockchain
so we have a state of balances of
accounts
[Music]
by party here we store the
choices a part is made
here with store bound variables that
are essentially led bindings
and here is main slot is essentially a
first slot that the contract sees
and this just to prevent to go back in
time
the input data type contains essentially
actions for a marvel contract it's
either deposit or choice or a
notification
of a slot change and
here is the
here is the transaction input data type
that's what we give us an input
so we have a slot interval so every
transaction must be
must have a defined slot interval
and the list of uh inputs so
you can you can combine multiple inputs
within a
single transactions you can make
multiple deposits or choices
and notifications and we get a
transaction output which
contains the payments that we expect to
happen
the output state and the output contract
resulting state and resulting contract
here's the moral data that's essentially
what's going to be stored on the
blockchain
so it's a current state of a contract
and the
actual contract so the main
function the main entrance
to the semantics is a compute
transaction function
that that gets
transaction inputs current state current
contract and gives the transaction
output first of all
we fix the interval we check the
slot interval for
um errors example
we these allow
slot interval to contain any
uh timeouts inside so for example we
have a contract with a one construct
with a slot
10 for example you cannot produce a
transaction
that has a slot interval from 5 to 15
because it's gonna contain a timeout
inside of it
it's going to be invalid
slot interval so here we check this
then we apply all inputs if it's
successful
we return the transaction output with
warnings we found the payments we expect
new state and a continuation
so what happens in apply on inputs
essentially it's a loop that first of
all reduces
current contract until it's quiescent
and then when we get
this question state we
take first input and try to apply it
until we get applied
and essentially continue
with this loop if it's applied
successfully
until we get an empty uh
input list then we return current state
and continuation
reduce contract until questioned is
essentially a function
that again goes through a loop
and tries to apply reduce contract step
function which
uh essentially evaluates a contract
so if we get a close then we are in a
question state
if we get a payment we evaluate
value and update balances
and return return that the contract
was reduced
we do the same with if
latin assert but for when
we only evaluate it if it's timed out
otherwise we say it's not reduced
so when we get this note reduced then we
say that the contract is questioned
so in a nutshell moral contract
evaluation
consists of two steps we reduce
current contract until it's quiescent so
essentially it's either
closed or we get to a when
that's not timed out yet um
and second part we try to apply
inputs and evaluate the contract
further okay
let's see how it works
from the client side
as you may have noticed the marlo
semantics code is quite abstract and
it does not depend on the cordano
nuances transactions and stuff
so let's take a look at the actual
marlow
validator that's been executed on chain
so here's the script instance
essentially just
calls this make marlow validator code
that uses a state machine library make
state machine call
and provides a two functions
state transition function and finality
check
for state machine so finality check is
very simple we just
check the the current contract
is close then the state machine is done
and the state machine transition
function is the actual
uh made of the validator
so it receives the marlo params data
type we're going to talk a bit
later current state of the state machine
model data milo input this is
essentially a transaction input
expressed in cardano types
and it's going to return either nothing
in case of an error
or a set of transaction constraints that
must
apply to validate a transaction
and a new state a new model of data
a continuation contract and a calculated
state
so here we check that
valid the balances are valid
so we require balances
in a state to be positive
here we produce in input constraints
given these
inputs so in case of
deposits we expect money
uh go into a contract in case of choices
we expect signatures or witnesses
of uh respective parties
we calculated little balance that the
contract claims it contains
and we check that it actually contains
these values
we construct a transaction input given
the slot interval and list of inputs
and we call the compute transaction
functions
that we saw in semantics dot hs
and we given a computed result
we can start the new marlow data with a
new contract continuation and updated
state
and producing output constraints that
can contain payouts
to respective parties
and we calculate new balance
new total balance
given the income and outcome of
the transaction and inputs and we
combine
all those constraints with
range validation
while validating inputs we
check that there are signatures
from parties presented
by public key hashes and
there is a spending of raw tokens for
parties that
represented by a role
payments two parties
go either by checking that there is a
transaction
output goes to a public key
for all for all four parties that
presented by
public key hashes or the payment goes to
role payout validator
hash that is a
custom validator that you can provide
on your own within marlow params
or we have a default one
this is a roll payout validator that is
used by default
that it simply checks
that a transaction contains
a spending
of a role token given currency
for off-chain execution we provide
three marlow peb contracts milo follower
contract
marlow control contract and marlo
companion contract
let's go through all of those let's
start with
marlow follower contract it's a very
simple one
it um it contains only only one endpoint
called
follow and it
basically subscribes to a validator
address a marlow contract address
essentially and it subscribes to all
changes to this address so we get all
the transactions
that spend
the span transaction output with this uh
marlow contract so we can
store all the inputs
um all the inputs that
are applied to a merlot contract
so here you can see that we call this
update history from
transaction that um
in a nutshell finds an input
of marlow inputs in the transaction
and if it finds it it constructs a
transaction
input data type
and update
the pab contract state with this
transition
so if you're connected to a websocket
of this contract he will be notified
about state transition changes
and this um state of this contract
called contract history it's
essentially
stores an initial marlow params
initial marlow data and the list of all
transaction inputs
that were applied
to this contract and you can always
restore the latest state by applying
list of transaction inputs to an initial
state
this contract is used by marlo ron to
show a marlow
contract execution history and you can
use
it for same purposes
on your own this marlow pluto's contract
is essentially a control contract
it allows you to create
a marlow contract an instance of milo
contract
apply inputs to the
the instance how to execute the contract
if it's possible
redeem tokens from
payments to roles to your role
by spending transaction output protected
by role payout validator script
or just close this contract
let's go through marvel contract
creation
so when you're calling the
create endpoint you provide
an actual marlow contract to be created
and a map of
uh roles to public keys
of role token owners
so what happens here
is we need to set up a milo params
let's take a look at this data type so
milo params is a way to parameterize
uh a mrlo contract and a following way
you can specify
your own role payout validator by
providing
um its hash so you can write anything
you want we have a default one that
checks that the role token is spent
within transaction but you can do
whatever you like
and you can do this by specifying
this hash in milo prompts also when your
contract uses
roles we need
to know a currency symbol
of a role currency so you specify it
here
so when we create a new contract that
uses
roles as parties we need to create new
currency
and distribute uh raw tokens to their
owners
that's why we need this map
of raw tokens to their to their owners
so let's take a look a look at the setup
milo brands
function so what happens here
we get roles that are used within this
contract
and if we have roles and we have
owners or provided for
these roles we
[Music]
create tokens with role names
uh by default we create a one token
parole
then we use this uh forge contract
function
that's essentially we reusing other
pb contracts this one is
from currency contract that creates a
new
new currency and
all these tokens
go to the creator so whoever
creates a marlo contract gets initially
gets all the roles
uh for this contract but uh
we get full symbol from that
and we immediately within the same
transaction
[Music]
uh same transaction that creates marvel
contract we distribute
role tokens to their owners so we give
them to respective parties
and we create milo prompts that contains
the
royal symbol a currency symbol of
currency we just created
for role tokens currently we use
the default role payout validator hash
so this is how this is a
set of constraints that create uh
new currency and distributor tokens and
create transaction output
with the marble data
so we use
[Music]
state machine library
to create state machine client
and we construct a transaction
that distribute tokens and
[Music]
create a transaction output with
immortal data and pay value this is a
deposit
value currently zero but at later point
it's going to be some
value i believe it's going to be one ada
[Music]
all transaction outputs must contain
some ada in it just to
[Music]
essentially it's preventing the ddos
attacks
and we submit this transaction that's
the way we
create a marlow contract on chain
apply and point is very simple apply
inputs and point
um just call the supply inputs
which is very very straightforward we
construct a slot range
and we use state machine library run
step to
run a state machine transition
uh function when we provide merlot input
which is a pair of
slot range and list of model inputs
a list of inputs
redeem and point allows you to get
money from the that's been paid to
a roll payout script
so we get this address
um given roles currency
and
spend all these outputs to
a token owner
auto is quite interesting
though complicated thing there is a
set of contracts that can be executed
automatically
imagine any contract that contains only
deposits
and payouts
[Music]
so if this contract is eligible so so no
no participant need to provide
choices um or any like interactive
stuff so only scheduled payments
these contracts can be executed
automatically and this is
this endpoint allows exactly that
so if the contract can be executed
automatically
for party we call out execute contract
this is essentially a state machine that
pays deposit or wait for other parties
to
do their their part
the last interesting contract is marvel
companion contract
this is a contract that monitors
a participant wallet
and notifies
when a role token goes to to your own
address
so it runs it listens to
transactions that
go to your own address and
if there is a token and this token
is generated by marvel contract creation
it tries to find the marlow contract
and if it succeeds
it notifies this contract it updates its
state
and again if you're subscribed to this
contract websocket you get a
notification
about a role token
and you'll get marlow params and model
data
so if you check this marlow companion
state this
is essentially a map of marlow params to
marvel data
so you can always get notified
about receiving a raw token
hope this helps thank you very much for
listening
thank you very much simon and alex for
these very nice introductions and
explanations to
marlow i thought it would be nice if we
play a bit with marlo in the
playground and when you go to the
playground by the way i
went to a different version than the one
simon
showed in his lecture on his slides
because
there was a problem with that one right
now but this one works
so it's alpha.mallow.iohkdev.io
and when you go there you first get
presented
with three options in which language you
want to write your milo contracts
so you can do it in haskell you can
do it in javascript or you can do it in
blockly or directly in malo
so let's first look at this option
because this is very nice and you don't
need
any programming experience to do this
so i start a new project and pick
blockly
this is a graphical editor so we can
just click and
drop a milo contract together and as an
example i want to
write a contract where there are three
parties
alice bob and charlie and the idea is
that alice and bob
deposit an amount of ada into the
contract let's say
10ada and then charlie decides whether
alice or bob
gets the total amount and
depending on charlie's decision either
alice gets 20 or bob gets 20.
and of course there's always the
possibility
that one of the three doesn't play along
and alice doesn't
make her deposit bob doesn't make his
deposit or charlie doesn't make his
choice in which case
everybody should just get reimbursed
what they have paid
up to that point so when we start with
blockly
there is a contract and it's just a
closed contract which
in this case doesn't do anything if
there was money in
internal accounts it would pay back the
money to the owners of the accounts
but we want to do something else so
let's first wait for a deposit by alice
and because that's an
external action that's triggered by one
of the parties in this case alice
we need this when construct that simon
mentioned
and we can slide that into here and we
see all the
slots where other things need to go
and we see some fields that we have to
set so let's start here
so um we can set a timeout so let's say
this deposit by alice has to happen
until slot 10
and if it doesn't happen we can say what
should happen afterwards
and there is not really a good choice to
do anything except
close in that case so in that case
nothing will happen so we can
slide that in there so now here we say
what external actions we wait for let's
say we
only wait for one action namely that
alice makes a deposit
so we can check for actions and pick the
deposit
one and slide it in here and we see a
couple of slots we have to fill
first of all who has to make the deposit
that's
a party and there are two choices public
key or role
let's take roll because then i
can just say ls normally this would be
the name of the role token
so whoever owns that token can
incorporate that role
okay so alice makes a deposit now the
amount
that's a value and let's say we just
pick a constant amount of
10 eta so amount is 10
and that it is ada we must specify here
in the currency slot
there's also the option to use other
tokens than ada but let's stick with ada
okay now there are these internal
accounts
that also belong to one of the parties
so
let's say alice pays it into her own
internal account
so i just copy pasted this and now we
must say what happens
next if alice makes this deposit
so afterwards we want bob to make a
deposit
so i can just copy this whole when block
here
and slide it in here and now
change so first of all i change the
timeout to 20.
so to give bob also 10 slots to do
something
and then wherever i set alice i now say
bob
so at this point if both these actions
happen
alice has deposited 10 into her internal
account and bob has deposited 10
into his inter external account so now
we want
charlie to make a choice so we need and
this is again an external action
so again we need a win
and put that in here but this time it's
not a deposit so let me delete
the deposit but let's change the timeout
to 30
to give charlie 10 slots to make his
choice
and now i need a different action where
earlier i had deposit
now i pick the choice action
i can give it a name let's say winner
i must say who makes the choice so
that's supposed to be
charlie
and now i must specify what values this
choice can have
and that's numeric so
somehow because l charlie is supposed to
choose between alice and bobs where
that's two choices
so i can pick arbitrary values like one
and two
one for ls two for bob so
that's already the default so that's
fine so this allows charlie to only
choose one or two
and then after he has made the choice if
he has made the choice
we continue and now it depends of course
on
what choice charlie has made if he chose
alice then alice must get all the money
if
he chose bob then bob must get all the
money so
here in this continued contract we now
can use
if simple conditional
slide that in here so first we need the
observation
so we must somehow check whether the
choice was
let's say one for alice so this is an
observation
and there is value equality is one of
the options
so we want to compare the choice that
charlie made
with one or two it doesn't matter but
let's say one
so value
there is this one
which gives us the value of a choice so
here we need the name
again so winner was our name for that
choice because there can be several
choices so we must
be able to distinguish between them and
we again need who made that choice
so this is now either one or two and we
can compare to for example one
so we can use the constant value one
okay and in this case so if this is true
then charlie chose
alice so we want alice to get all the
money
so in the then branch we can now
take a pay contract
the payees who gets the money and now we
have two choices that can be an internal
account or it can be an external party
and in this case it doesn't matter
because in the end when we close
all the parties get the money from the
internal accounts as well so i
it doesn't matter i can just pick the
internal account alice's
internal account so let's do that
pick ls
so this now means that the payee is
alice's internal account
now how much that's this constant
10 the amount that bob paid in
currency is ada
and now who pays and that must be an
internal account
because this is something the this pay
contract is something the
contract has control over so that's not
an external action
so payments are triggered from internal
accounts that are
under the control of the contract and
that in this case is bob's account
so this now says if charlie picked one
which stands for alice then pay
from bob's internal account 10 ada to
alice's internal account
and afterwards we can just close
and when we close all the internal
accounts will be
paid to the external owners so
at this point alice's internal account
will have 28r and when we close
she will get the 28 are paid out
okay and else this is now if charlie
didn't choose alice if he chose bob
well then we must do the same but with
reversed roles so let me
copy paste this whole pay thing and just
exchange bob and alice
and this should do it now we can
for example look at the pure mallow
so this is now the value what i did
graphically as a milo
value a value of the haskell data type
called
marlow or called contract actually
and i can send it to the simulator
i can start the simulation
and now whenever there is a when so when
there are
available actions i get prompted
which of those to take in our case we
always only had
one available action at every point
so in the first when there are only two
possibilities either alice makes her
deposit
or she doesn't until the timeout is
reached so in this case if we
wait for the timeout it's very boring
the contract is over
is reduced to close and nothing happened
so if she makes the deposit
then this contract simplifies so it's
now reduced
to what happens after she made the
deposit
and we see now we are in the second when
where we are waiting for
bob's deposit and again he can
choose not to deposit so if he does that
then we see here the actions alice
deposits the 10
and then after the timeout because bob
didn't do any anything
the contract paid 10 back to alice
okay of course it's more interesting if
bob also makes this deposit
so we see that locked here as well
and now we are the contract has
simplified again
so now we are in the when where the
only available action is that charlie
chooses so
charlie can now choose one or two if he
chooses or
don't do anything if he doesn't do
anything
bob and alice both get her money their
money back
if he picks alice so choice one
then we see that the contract pays 20
units of ada to alice
so she gets all the money and
if instead we pick two
then the contract pays 20 units to bob
so it seems to work let me
reset this now and let me
copy this marlo contract
and do a new project and go to the
haskell editor instead
and let's not save
and here in this haskell editor there's
a template
basically all this haskell pro program
does
is it takes a contract this is a milo
contract
and then it's a it's a simple executable
haskell executable
that just pretty prints the contract so
all it does is it basically produces
a nicely printed value of type contract
and this is then used to for example run
in the simulator
so we should be able to simply instead
of close paste
this expression here that we got
from our blockly probably i should
indent okay and
that should compile so i can compile
this
and i can send it to the simulator and
it should behave exactly as before
so alice makes a deposit bob makes his
deposit
let's say charlie picks bob
and bob gets the money so
there we don't really see a benefit of
twins and haskell we could just as well
do it in broccoli although
i find that blockly is really only
useful
for learning and for writing extremely
simple contracts because
this is arguably a simple contract and
already it
was quite unwieldy in the blockly editor
and if you do something slightly more
complicated
it gets really very confusing in the
editor
but the point is we can do other things
in this haskell program as well we don't
have to
literally define a contract we can use
the whole power of haskell to help us
write this contract
so for example we see there's lots of
repetition because we always have these
roles
ls bob and charlie so for example we can
define them separately and just say
alice
the type is party
and the role constructor
we can just use this overloaded string
here to
skip the role constructor and just write
it like this
so party implements is string
and the from string method uses the role
constructor
charlie
okay and now i can replace
this everywhere with those
here as well
and here as well i can do the
same for bob and charlie
okay i think i have all the places
now i can do the same this constant 10
is all over the place
so let's give that a name as well let's
call it deposit
and that's of type value
okay
um this token empty empty there's
the ada abbreviation for that
okay and there's slightly more
computation
duplication this choice id so let's also
give that a name
choice id type
choice id
and it takes two parameters the name
which was winner in our case
and the role which is char
okay now it's already
cleaned up quite a bit
and now it's also easy to do more
sophisticated things for example
our contract is slightly asymmetric even
though it sounds like a
symmetric situation i mean alice and bob
are completely symmetric but in our
contract
alice has to deposit first and what we
could do instead is
allow bob to deposit first as well so in
the outermost when
we have two cases one where ls deposits
and one where bob deposits
so we can of course just now copy this
case here and paste it
below and change alice and bob
where appropriate which is not
everywhere because in this choice thing
here
um alice keeps being choice one and bob
keeps being choice too
so would have to concentrate on that but
of course it's much nicer to
extract that into a helper function so
this is of type case
so let me just copy paste or copy this
until there
and now make a local definition
and i don't know what to call it let's
just call it f
and it takes two parties the party that
deposits first
and the party that deposits afterwards
and it gives us a case
let's call it x and y
and just paste this whole thing there
okay and now of course i am not using
the x and y so in this case
alex alice was first so alice is x
and after alice's deposit
we wait for bob okay and this here
can stay the same this
choice okay now i can replace this whole
thing
with my helper function
and write f lsbop
and the advantage is that i know it's
now easy to also add the symmetric case
that
bob can deposit first so i just add a
new line
with another case bob alice
and if all goes well that should still
compile
and if i now send it to the simulator
and start the simulation
now i have two possible actions that can
happen in the first step
alice can deposit 10 or bob can deposit
10.
so let's bob start this time so bob
deposits 10
and now it's alice's turn
and if charlie picks alice then as
before alice wins
so the point i'm making is that
it's of a big advantage to use the
haskell editor to write milo contracts
in haskell
so basically you write a program that
produces
something of type contract and you can
use all the features of haskell
like local functions or whatever to make
your life
easier and avoid co-duplication
and in the blocky editor there's no such
option if we had
wanted to do the same in blockly because
there are no local definitions that you
can do you can't
define local contracts or something like
that so we would have to
paste copy paste this whole big
case and then manually change ls to bob
and bob to alice in the first two
deposits
and we would have lots of good
duplication because this
choice thing here the third win would
have been copy-pasted and there would
have been no way to
abstract that away and only write it
once
and of course you have other options for
example we could also parameterize our
contract
so for example we could use the leaflet
deposit
variable so we could instead do
contract is a function from value to
contract and the first parameter is
deposit
and i delete this here
and now in the main program i can pick a
value for the parameter for example 50
and now if i compile
oh sorry it must be constant 50.
so now if i compile
i have a version of the contract where
now
alice and bob have to deposit 58 each
and then the winner gets 100.
and obviously i could do the same for
the parties
so i could parameterize it over the
three parties
party party
party
and then if i call those ls bob and
charlie
delete this here
then i must also be careful and this
must now depend on a party
let's call it p
and at the appropriate spot here where
the choice happens
i must say choice at d charlie
here as well and now
the contract is parameterized by all
participants
so instead of alice bob and charlie i
can use
charts simon
and alex and
constant 100
what did i do now
oh yes just a parenthesis
problem
okay and now i have
charles and simon and deposits of 100
and alex picks the winner
and it works as before so it's
very nice and easy to using haskell
parameterizing contracts and saving a
lot of
code duplication by just using usual
haskell thank
features like local definitions helper
functions and so on
i could even relatively easily
generalize this to more than three
participants
maybe there are three people i could
even write a contract that's
generic in the number of parties so i
get a list of parties
and then each of them has to deposit and
that would be
very inconvenient if i had to do that by
hand
but just using haskell it's quite
straightforward
and what is also noteworthy here is that
milo
in contrast to pluto's is extremely
basic haskell
so the milo team made a point of only
using very basic haskell functions
of on features so you don't need
lenses you don't need template haskell
you don't even need monarchs
um type level programming all of that is
not present in
malo it's extremely basic standard
haskell
so after what you have learned while
learning pluto is about haskell
milo should be a walk in the park for
you and
very relaxing and simple of course marlo
is not always appropriate because it's
specifically for financial contracts but
if it is appropriate it's a very nice
option because of all the
safety assurances that simon mentioned
and because it's much simpler and easier
to get right than pluto's
for homework i would like you to modify
the contract that i wrote
as follows charlie should
put down a deposit in the very beginning
of twice
the deposit that alice and bob put down
and if he then doesn't choose when it's
his turn to choose
alice and bob get half of what he put
down so
alice and bob each end up with 20 in
this example
so in the very beginning charlie
supposed to put down 20 then
it proceeds as usual so if all goes well
as
and bob both put down 10 and charlie
makes this choice
for example for alice then as before
alice gets the 20 and charlie gets his
original deposit back
but if charlie does not make a choice
and the deadline is reached then his 20
are split amongst alice and bob so
alice and bob both end up with 20.
... work in progress

